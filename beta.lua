--[[
⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀      ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⡿⠀⢿⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⢸⠇⠀⠸⡇⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀  ⠀  ⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⢀⡿⠀⠀⠀⢿⡀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⣶⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦
  ⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⣸⠃⠀⠀⠀⠘⣇⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⣿⠀⠴⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣶⣤⣤⡀⠀⢀⣤⣤⣤⡀⠀⢠⣤⣦⣼⡏⢀⣤⣞⠁⠀⠀⠀⠀⠀⢀⡟⠀⠀⠀⠀⠀⢻⡀⠀⠀⠀⠀⠀⠈⣳⣤⡀⠀⠀⢸⡟⠀⣦⠀⣶⣦⣦⣄⠀⠀⣠⣤⣤⡀⠀⠀⠀⠀⠀⠀⠀✦
⠀⠀⠀⠀⠀⠀⠀⢸⡏⠀⠈⠛⠀⣼⡇⠀⢹⡇⠀⣿⠁⠀⣿⡇⠈⠛⢯⡙⠛⠶⠦⣤⣄⣼⡃⠀⠀⠀⠀⠀⢘⣧⣠⣤⠴⠶⠛⢋⡽⠛⠁⠀⠀⢸⡇⢸⡏⢀⣿⠁⠀⣿⠆⢸⡏⠀⢈⣿⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⣿⠟⠛⠛⠁⢸⣏⠀⠀⣿⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⢹⡏⠛⠓⠶⠚⠛⢹⡏⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⣿⠃⢸⡇⢸⡟⠀⠀⣿⠀⢾⡟⠛⠛⠁⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠾⠃⠀⠀⠀⠀⠘⠻⠾⠿⠂⠀⠙⠿⠿⠿⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⣷⠀⠀⠀⠀⠀⣾⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠿⠀⠿⠃⠸⠇⠀⠀⠟⠀⠈⠻⠷⠿⠆⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⢸⡆⠀⠀⠀⢰⡇⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀✦⠀⠀⠀  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢶⣷⠀⠀⠀⣾⡶⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢧⣀⡼⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
]]--


--[[
★☆
]]--

if (_G.RLLoaded) then
    if (printconsole) then 
        printconsole("Already loaded Redline", 255, 64, 64)
        printconsole("Destroy the current script by pressing [End].\nIf you don't have an end key too bad", 192, 192, 192)
        return
    else
        warn("Already loaded Redline")
        return
    end
end

-- { The funny } --
pcall(function()
    -- Some shitter exploits error on this
    -- so im wrapping it in a pcall
    
    
    local inf = getinfo or debug.getinfo(2)
    if (inf) then
        if (inf.source ~= "redline is pretty cool") then
            warn("Looks like you're using an older version of Redline")
            warn("The newest script has been automatically downloaded to your workspace.")
            warn("Replace this script with the one located at workspace/REDLINE.lua")
            return
        end
    end
end)


-- { Handle file system } --
if (not isfile('REDLINE')) then
    makefolder('REDLINE')
end

if (not isfile('REDLINE/config.json')) then
    --writefile('REDLINE/config.json', '')
end



-- { Wait for load } --
if not game:IsLoaded() then game.Loaded:Wait() end

-- { Microops } --

-- Services
local serv_rs = game:GetService('RunService')
local serv_uis = game:GetService('UserInputService')
local serv_ts = game:GetService('TweenService')
local serv_gui = game:GetService('GuiService')
local serv_ctx = game:GetService('ContextActionService')
local serv_http = game:GetService('HttpService')
local serv_tp = game:GetService('TeleportService')
local serv_players = game:GetService('Players')

-- Colors
local rgb,hsv,c3n = Color3.fromRGB, Color3.fromHSV, Color3.new
-- UDim2
local dim2off, dim2sca, dim2 = UDim2.fromOffset, UDim2.fromScale, UDim2.new
-- Instances
local inst = Instance.new
-- Vectors
local vec3, vec2 = Vector3.new, Vector2.new
-- CFrames
local cfn = CFrame.new
-- Task
local wait, delay, spawn = task.wait, task.delay, task.spawn
-- Math
local mr = math.random
local mf = math.floor
local mc = math.clamp
-- Utf8
local uc = utf8.char
-- Table
local ins,rem = table.insert, table.remove
-- Os
local date = os.date
local time = tick


-- { UI Colors } --
local colors = _G.RLTHEME or {} do 
    -- generic
    colors['outline']       = rgb(075, 075, 080) -- outline color
    colors['shadow']        = rgb(005, 005, 010) -- go figure
    colors['bg']            = rgb(023, 022, 027) -- window background
    colors['enabled']       = rgb(225, 035, 035) -- enabled
    -- backgrounds 
    colors['bg_header']     = rgb(035, 035, 040) -- header background
    colors['bg_object']     = rgb(030, 030, 035) -- object background
    colors['bg_setting']    = rgb(025, 025, 030) -- setting background
    colors['bg_dropdown']   = rgb(020, 020, 025) -- dropdown background
    -- backgrounds selected
    colors['bg_header-b']   = rgb(038, 038, 043) -- header hovering
    colors['bg_object-b']   = rgb(033, 033, 038) -- object hovering
    colors['bg_setting-b']  = rgb(028, 028, 033) -- setting hovering
    colors['bg_dropdown-b'] = rgb(023, 023, 028) -- dropdown hovering
    -- slider
    colors['slider_fg']     = rgb(160, 160, 165) -- slider foreground
    colors['slider_bg']     = rgb(055, 055, 060) -- slider background
    colors['slider_head']   = rgb(130, 130, 135) -- slider head
    -- text
    colors['text1']         = rgb(255, 255, 255) -- main text
    colors['text2']         = rgb(170, 170, 255) -- sub text
    colors['text3']         = rgb(020, 020, 025) -- sub text
end

-- { UI functions / variables } --
local shadow,twn,ctwn,getnext,stroke,round,uierror
do
    shadow = function(parent)
        local _ = inst('ImageLabel')
        _.BackgroundTransparency  = 1
        _.ImageTransparency       = 0.5
        _.SliceScale              = 1.3
        _.Image                   = 'rbxassetid://7603818383'
        _.AnchorPoint             = vec2(0.5,0.5)
        _.ImageColor3             = colors['shadow']
        _.Position                = dim2sca(0.5, 0.5)
        _.Size                    = dim2(1, 20, 1, 20)
        _.SliceCenter             = Rect.new(15, 15, 175, 175)
        _.ScaleType               = 'Slice'
        _.ZIndex                  = parent.ZIndex - 1 
        _.Parent                  = parent
    
        return _
    end
    stroke = function(parent,inset) 
        local _ = inst('UIStroke')
        _.ApplyStrokeMode = 'Contextual'
        _.Thickness = 1
        _.Color = colors['outline']
        _.Transparency = 0
        if (inset) then
            parent.Size -= dim2off(1,1)
        end
        
        _.Parent = parent
        return _
    end
    
    local info1, info2 = TweenInfo.new(0.1,10,1), TweenInfo.new(0.2,10,1)
    function twn(twn_target, twn_settings, twn_long) 
        local tween = serv_ts:Create(
            twn_target,
            twn_long and info2 or info1,
            twn_settings
        )
        tween:Play()
        return tween
    end
    function ctwn(twn_target, twn_settings, twn_dur) 
        local tween = serv_ts:Create(
            twn_target,
            TweenInfo.new(twn_dur,10,1),
            twn_settings
        )
        tween:Play()
        return tween
    end
    function getnext() 
        local a = ''
        for i = 1, 5 do a = a .. uc(mr(50,2000)) end 
        return a 
    end
    function round(num, place) 
        return mf(((num+(place*.5)) / place)) * place
    end
    function uierror(func, prop, type) 
        error(('%s failed; %s is not of type %s'):format(func,prop,type), 3)
    end
end




-- { UI } --
local ui = {} do 
    local W_WindowOpen = false
    
    local ui_Hotkeys = {}
    local ui_Connections = {}
    local ui_Menus = {}
    local ui_Modules = {}
    
    local rgbinsts = {}
    
    local monitor_resolution = serv_gui:GetScreenResolution()
    local monitor_inset = serv_gui:GetGuiInset()
    
    -- connections
    ui_Connections['i'] = serv_uis.InputBegan:Connect(function(io, gpe) 
        if (gpe) then return end
        if (io.UserInputType.Value == 8) then
            local kcv = io.KeyCode.Value
            for i = 1, #ui_Hotkeys do 
                local hk = ui_Hotkeys[i]
                if (hk[1] == kcv) then
                    hk[2]()
                end
            end
        end
    end)
    do
        local _ = 0
        local __ = hsv
        
        ui_Connections['r'] = serv_rs.RenderStepped:Connect(function(___) 
            _ = (_ > 1 and 0 or _)+(___*.05)
            ___ = __(_,.9,1)
            for i = 1, #rgbinsts do 
                local v = rgbinsts[i]
                v[1][v[2]] = ___
            end
        end)
    end
    
    -- Gui creation
    local w_Screen
     local w_TooltipHeader
      local w_Tooltip
    local w_Backframe
    local w_ModList
     local w_ModListLayout
     local w_ModListTitle
    
    
    do 
        w_Screen = inst('ScreenGui')
        w_Screen.IgnoreGuiInset = true
        w_Screen.ZIndexBehavior = Enum.ZIndexBehavior.Global
        w_Screen.Name = getnext()
        pcall(function() 
            --syn.protect_gui(w_Screen)
        end)
        w_Screen.DisplayOrder = 939393
        w_Screen.Parent = gethui and gethui() or get_hidden_gui and get_hidden_gui() or game.CoreGui
        
        
        w_Backframe = inst('Frame')
        w_Backframe.Size = dim2sca(1,1)
        w_Backframe.BackgroundColor3 = colors['bg']
        w_Backframe.BackgroundTransparency = 0.3
        w_Backframe.BorderSizePixel = 0
        w_Backframe.Visible = false
        w_Backframe.Parent = w_Screen
        
        local w_Icon = inst("ImageLabel")
        w_Icon.Image = "rbxassetid://8677436980"
        w_Icon.Size = dim2off(256, 256)
        w_Icon.Position = dim2off(0, -64)
        w_Icon.BackgroundTransparency = 1
        w_Icon.Parent = w_Backframe
        
        w_ModList = inst('Frame')
        w_ModList.Size = dim2(0,200,0.3,0)
        w_ModList.Position = dim2sca(0,1)
        w_ModList.AnchorPoint = vec2(0, 1)
        w_ModList.BackgroundTransparency = 1
        w_ModList.BackgroundColor3 = colors['bg']
        w_ModList.BorderSizePixel = 1
        w_ModList.BorderMode = 'Inset'
        w_ModList.BorderColor3 = colors['outline']
        w_ModList.Parent = w_Screen
        
        w_ModListLayout = inst('UIListLayout')
        w_ModListLayout.FillDirection = 'Vertical'
        w_ModListLayout.HorizontalAlignment = 'Left'
        w_ModListLayout.VerticalAlignment = 'Bottom'
        w_ModListLayout.Parent = w_ModList
        
        w_ModListTitle = inst("TextLabel")
        w_ModListTitle.Size = dim2(1, 0, 0, 30)
        w_ModListTitle.BackgroundTransparency = 1
        w_ModListTitle.Font = 'SourceSans'
        w_ModListTitle.TextColor3 = colors['enabled']
        w_ModListTitle.TextXAlignment = 'Left'
        w_ModListTitle.TextColor3 = colors['text1']
        w_ModListTitle.TextSize = 24
        w_ModListTitle.Text = " Redline"
        w_ModListTitle.LayoutOrder = 939
        w_ModListTitle.TextStrokeTransparency = 0
        w_ModListTitle.TextStrokeColor3 = colors['text3']
        w_ModListTitle.ZIndex = 5
        w_ModListTitle.Parent = w_ModList
        
        w_TooltipHeader = inst("TextLabel")
        w_TooltipHeader.Size = dim2off(175,20)
        w_TooltipHeader.BackgroundTransparency = 0
        w_TooltipHeader.Font = 'SourceSans'
        w_TooltipHeader.TextColor3 = colors['text1']
        w_TooltipHeader.TextXAlignment = 'Center'
        w_TooltipHeader.TextSize = 19
        w_TooltipHeader.Text = "Hi"
        w_TooltipHeader.TextStrokeTransparency = 0
        w_TooltipHeader.TextStrokeColor3 = colors['text3']
        w_TooltipHeader.BackgroundColor3 = colors['bg_header']
        w_TooltipHeader.BorderSizePixel = 1
        w_TooltipHeader.BorderMode = 'Inset'
        w_TooltipHeader.BorderColor3 = colors['outline']
        w_TooltipHeader.ZIndex = 1500
        w_TooltipHeader.Visible = false 
        w_TooltipHeader.Parent = w_Screen
        
        w_Tooltip = inst("TextLabel")
        w_Tooltip.Size = dim2off(175,25)
        w_Tooltip.BackgroundTransparency = 0.2
        w_Tooltip.Font = 'SourceSans'
        w_Tooltip.TextColor3 = colors['text1']
        w_Tooltip.TextXAlignment = 'Left'
        w_Tooltip.TextYAlignment = 'Top'
        w_Tooltip.TextSize = 17
        w_Tooltip.Text = ""
        w_Tooltip.TextWrapped = true
        w_Tooltip.Position = dim2off(-1, 18)
        w_Tooltip.TextStrokeTransparency = 0
        w_Tooltip.TextStrokeColor3 = colors['text3']
        w_Tooltip.BackgroundColor3 = colors['bg']
        w_Tooltip.BorderSizePixel = 1
        w_Tooltip.BorderMode = 'Inset'
        w_Tooltip.BorderColor3 = colors['outline']
        w_Tooltip.ZIndex = 1500
        w_Tooltip.RichText = true
        w_Tooltip.Visible = true 
        w_Tooltip.Parent = w_TooltipHeader
        
        local __ = inst("UIPadding")
        __.PaddingLeft = dim2off(5, 0).X
        --__.PaddingTop = dim2off(0, 5).Y
        __.Parent = w_Tooltip
        
        w_Tooltip:GetPropertyChangedSignal("Text"):Connect(function() 
            w_Tooltip.Size = dim2off(175,25)
            local n = dim2off(0,5)
            for i = 1, 25 do 
                w_Tooltip.Size += n
                if (w_Tooltip.TextFits) then break end
            end
            
        end)
    end
    
    ui_Connections['t'] = serv_rs.RenderStepped:Connect(function() 
        local pos = serv_uis:GetMouseLocation()
        w_TooltipHeader.Position = dim2off(pos.X+15, pos.Y+15)
    end)
    
    
    local ModListEnable,ModListDisable,ModListInit,ModListModify do 
        local mods_instance = {}
        
        
        ModListEnable = function(name) 
            local b = mods_instance[name]
            
            b.Parent = w_ModList
            twn(b.P, {PaddingLeft = dim2off(8, 0).X},true)
            twn(b, {Size = dim2(1, 0, 0, 24), TextTransparency = 0, TextStrokeTransparency = 0},true)
        end
        
        ModListDisable = function(name)
            local b = mods_instance[name]
            
            twn(b.P, {PaddingLeft = dim2off(-100, 0).X},true)
            twn(b, {Size = dim2(0, 0, 0, 0), TextTransparency = 1, TextStrokeTransparency = 1},true)
        end
        
        ModListModify = function(name, new) 
            mods_instance[name].Text = new
        end
        
        ModListInit = function(name) 
            local _ = inst("TextLabel")
            _.Size = dim2(0, 0, 0, 0)
            _.BackgroundTransparency = 1
            _.Font = 'SourceSans'
            _.TextXAlignment = 'Left'
            _.TextColor3 = colors['text1']
            _.TextSize = 22
            _.Text = name
            --_.Name = name
            _.TextTransparency = 1
            _.TextStrokeTransparency = 1
            _.TextStrokeColor3 = colors['text3']
            _.ZIndex = 5
            
            mods_instance[name] = _
            
            ins(rgbinsts, {_,"TextColor3"})
            
            
            local __ = inst("UIPadding")
            __.Name = 'P'
            __.PaddingLeft = dim2off(-100, 0).X
            __.Parent = _
        end
    end
    
    -- Base class for stuff
    local base_class = {} do 
        local s1,s2 = dim2(1,0,1,0), dim2(0,0,1,0)
        
        
        
        -- objtype_action_actiontype
        
        -- Menu funcs
        do
            base_class.menu_toggle = function(self) 
                local t = not self.MToggled
                
                self.MToggled = t
                self.Menu.Visible = t
                
                twn(self.Icon, {Rotation = t and 0 or 180}, true)
            end
                base_class.menu_getstate = function(self) 
                return self.MToggled
            end
        end
        -- Module funcs
        do
            base_class.module_toggle_menu = function(self) 
                local t = not self.MToggled
                
                self.MToggled = t
                self.Menu.Visible = t
                
                twn(self.Icon, {Rotation = t and 360 or 0}, true)
                self.Icon.Text = t and '-' or '+'
            end
            base_class.module_toggle_self = function(self) 
                local t = not self.OToggled
                self.OToggled = t
                
                
                pcall(self.Flags.Toggled, t)
                pcall(self.Flags[t and 'Enabled' or 'Disabled'])
                
                twn(self.Effect, {Size = t and s1 or s2}, true)
                
                if (t) then
                    ModListEnable(self.Name)
                else
                    ModListDisable(self.Name)
                end
                return self 
            end
            base_class.module_toggle_enable = function(self) 
                self.OToggled = true
                
                pcall(self.Flags.Toggled, true)
                pcall(self.Flags.Enabled)
                
                twn(self.Effect, {Size = s1}, true)
                
                ModListEnable(self.Name)
                return self 
            end
            base_class.module_toggle_disable = function(self) 
                self.OToggled = false
                
                pcall(self.Flags.Toggled, false)
                pcall(self.Flags.Disabled)
                
                twn(self.Effect, {Size = s2}, true)
                
                ModListDisable(self.Name)
                return self
            end
            base_class.module_getstate_self = function(self) return self.OToggled end
            base_class.module_getstate_menu = function(self) return self.MToggled end
            
            base_class.module_setvis = function(self, t, t2) 
                self.Root.Visible = t 
                self.Highlight.Visible = t2
            end 
            
            base_class.module_click_self = function(self) 
                pcall(self.Flags.Clicked)
                
                self.Effect.BackgroundTransparency = 0.8
                twn(self.Effect, {BackgroundTransparency = 1}, true)
            end
            base_class.module_gettext = function(self) 
                return self.Text
            end
            
        end
        
        -- Setting funcs
        do
            base_class.setting_toggle_self = function(self) 
                local t = not self.Toggled
                
                pcall(self.Flags.Toggled, t)
                pcall(self.Flags.Enabled)
                pcall(self.Flags.Disabled)
                
                self.Toggled = t
                twn(self.Icon, {BackgroundTransparency = t and 0 or 1})
                return self
            end 
            base_class.setting_toggle_getstate = function(self) 
                return self.Toggled
            end
            
            base_class.setting_modhotkey_sethotkey = function(self) 
                local label = self.Label
                label.Text = "Press any key..."
                
                wait(0.01);
                local c;
                c = serv_uis.InputBegan:Connect(function(io,gpe)
                    
                    local kcv = io.KeyCode.Value
                    if (kcv ~= 0) then
                        
                        self.Hotkey = kcv
                        label.Text = "Hotkey: "..io.KeyCode.Name
                        
                        -- As scuffed as this is, it works
                        -- To prevent the module being bound from immediately toggling, a short delay is made
                        delay(0.01, function()
                            local n = self.Parent.Name
                            for i = 1, #ui_Hotkeys do 
                                if ui_Hotkeys[i][3] == n then
                                    rem(ui_Hotkeys, i)
                                    break
                                end
                            end
                            ins(ui_Hotkeys, {kcv, function() 
                                self.Parent:Toggle()
                            end, n})
                        end)
                    else
                        self.Hotkey = nil    
                        label.Text = "Hotkey: N/A"
                        
                        local n = self.Parent.Name
                        for i = 1, #ui_Hotkeys do 
                            if ui_Hotkeys[i][3] == n then
                                rem(ui_Hotkeys, i)
                                break
                            end
                        end
                    end
                    c:Disconnect()
                end)
                
            end
        
            base_class.setting_modhotkey_gethotkey = function(self) 
                return self.Hotkey
            end
            
            base_class.setting_hotkey_sethotkey = function(self) 
                local label = self.Label
                label.Text = "Press any key..."
                
                wait(0.01);
                local c;
                c = serv_uis.InputBegan:Connect(function(io,gpe)
                    local kc = io.KeyCode
                    local kcv = kc.Value
                    if (kcv ~= 0) then
                        
                        self.Hotkey = kc
                        label.Text = self.Name..": "..kc.Name
                        
                        pcall(self.Flags.HotkeySet, kc, kcv)
                    else
                        self.Hotkey = nil    
                        label.Text = self.Name..": N/A"
                    end
                    c:Disconnect()
                end)
            end
            
            base_class.setting_hotkey_sethotkeyexplicit = function(self, kc) 
                self.Hotkey = kc
                self.Label.Text = self.Name..": "..kc.Name
                return self
            end
            
            base_class.setting_hotkey_gethotkey = function(self)
                return self.Hotkey
            end
            
            
            base_class.setting_dropdown_getselection = function(self) 
                return self.Selection
            end
            
            base_class.setting_ddoption_select_self = function(self) 
                local parent = self.Parent
                
                local objs = parent.Objects
                for i = 1, #objs do objs[i]:Deselect() end
                
                self.Selected = true
                parent.Selection = self.Name
                pcall(parent.Flags.SelectionChanged, self.Name, self)
                
                if (parent.Primary) then
                    
                    local n = parent.Parent.Name 
                    ModListModify(n, n .. " ["..self.Name.."]")
                end
                
                twn(self.Effect, {Size = s1}, true)
                
                return self
            end
            base_class.setting_ddoption_deselect_self = function(self) 
                if (self.Selected) then 
                    self.Selected = false
                    twn(self.Effect, {Size = s2}, true)
                end
                
                return self
            end
            base_class.setting_ddoption_selected_getstate = function(self) 
                return self.Selected
            end
            
            base_class.setting_slider_getval = function(self) return self.CurrentVal end
            base_class.setting_slider_setvalnum = function(self, nval) 
                local min = self.Min
                local cval = self.CurrentVal
                local pval = self.PreviousVal

                
                cval = round(mc(nval, min, self.Max), self.Step)
                
                if (pval ~= cval) then
                    pval = cval
                    
                    self.SliderFill.Position = dim2off(mf((cval - min) * self.Ratio), 0)
                    self.SliderAmnt.Text = self.StepFormat:format(cval)
                    
                    pcall(self.Flags.ValueChanged, cval)
                end
                
                self.CurrentVal = cval
            end
            base_class.setting_slider_setvalpos = function(self, xval) 
                local min = self.Min
                local cval = self.CurrentVal
                local pval = self.PreviousVal
                
                local pos_normalized = mc(xval - self.SliderBg.AbsolutePosition.X, 0, self.SliderSize)
                
                cval = round((pos_normalized * self.RatioInverse)+min, self.Step)
                
                if (pval ~= cval) then
                    pval = cval
                    self.SliderFill.Position = dim2off(mf((cval - min)*self.Ratio), 0)
                    self.SliderAmnt.Text = self.StepFormat:format(cval)
                    
                    self.CurrentVal = cval
                    
                    pcall(self.Flags.ValueChanged, cval)
                end
            end
        end
        
        -- Button funcs
        base_class.button_click = function(self) 
            pcall(self.Flags['Clicked'])
        end
        
        -- Slider funcs
        base_class.slider_setval = function(self, value) 
            value = tonumber(value)
            if not value then uierror('slider_setval','value','number') end
            
            local m1,m2,m3 = self.min, self.max, self.step
            value = mc(round(value, m3),m1,m2)
            
            self.setval_internal(value)
        end
        base_class.slider_getval = function(self) 
            return self.value1
        end
        
        -- Input funcs
        base_class.input_gettxt = function(self) 
            return self.Text
        end
        
        -- Generic funcs
        base_class.generic_tooltip = function(self, tooltip) 
            if (tooltip) then
                self.Tooltip = tostring(tooltip)    
            else
                self.Tooltip = nil
            end
            return self 
        end
        base_class.generic_connect = function(self, flagname, func) 
            if (type(func) ~= 'function' and type(func) ~= 'nil') then
                uierror('generic_connect','func','function or type nil')
            end
            if (type(flagname) ~= 'string') then
                uierror('generic_connect','flagname','string')
            end
            
            self.Flags[flagname] = func
            return self 
        end
        
        -- Creation functions
        base_class.menu_create_module = function(self, text, Type, nohotkey) 
            text = tostring(text):sub(1,30)
            Type = Type or 'Toggle'
            local M_IndexOffset = self.ZIndex+1
            
            if (Type == 'Toggle') then 
                ModListInit(text)
                
                
                
                
                local m_ModuleRoot
                 local m_ModuleBackground
                  local m_ModuleEnableEffect
                   local m_ModuleEnableEffect2
                  local m_Highlight
                  local m_ModuleText
                  local m_ModuleIcon
                 local m_ModuleMenu
                
                do
                    m_ModuleRoot = inst("ImageButton")
                    m_ModuleRoot.Size = dim2(1, 0, 0, 25)
                    m_ModuleRoot.AutomaticSize = "Y"
                    m_ModuleRoot.ClipsDescendants = false
                    m_ModuleRoot.BackgroundTransparency = 1
                    m_ModuleRoot.BorderSizePixel = 0
                    m_ModuleRoot.ZIndex = M_IndexOffset-1
                    m_ModuleRoot.Parent = self.Menu
                    
                     m_ModuleBackground = inst("Frame")
                     m_ModuleBackground.Size = dim2(1,0,0,25)
                     m_ModuleBackground.BorderSizePixel = 0
                     m_ModuleBackground.ZIndex = M_IndexOffset
                     m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                     m_ModuleBackground.Parent = m_ModuleRoot
                     
                      m_Highlight = inst("Frame")
                      m_Highlight.Size = dim2sca(1,1)
                      m_Highlight.BackgroundColor3 = colors['enabled']
                      m_Highlight.BackgroundTransparency = 0.7
                      m_Highlight.Active = false
                      m_Highlight.Visible = false
                      m_Highlight.ZIndex = M_IndexOffset
                      m_Highlight.BorderSizePixel = 0
                      m_Highlight.Parent = m_ModuleBackground
                      
                      m_ModuleEnableEffect = inst("Frame")
                      m_ModuleEnableEffect.BackgroundColor3 = colors['text1']
                      m_ModuleEnableEffect.BackgroundTransparency = 0.92
                      m_ModuleEnableEffect.ClipsDescendants = true
                      m_ModuleEnableEffect.Size = dim2(0,0,1,0)
                      m_ModuleEnableEffect.BorderSizePixel = 0
                      m_ModuleEnableEffect.ZIndex = M_IndexOffset
                      m_ModuleEnableEffect.Parent = m_ModuleBackground
                      
                       m_ModuleEnableEffect2 = inst("Frame")
                       m_ModuleEnableEffect2.BackgroundColor3 = colors['enabled']
                       m_ModuleEnableEffect2.Size = dim2(0,2,1,0)
                       m_ModuleEnableEffect2.BorderSizePixel = 0
                       m_ModuleEnableEffect2.ZIndex = M_IndexOffset
                       m_ModuleEnableEffect2.Parent = m_ModuleEnableEffect
                      
                      m_ModuleText = inst('TextLabel')
                      m_ModuleText.Size = dim2(1, -5, 1, 0)
                      m_ModuleText.Position = dim2off(5, 0)
                      m_ModuleText.BackgroundTransparency = 1
                      m_ModuleText.Font = 'SourceSans'
                      m_ModuleText.TextXAlignment = 'Left'
                      m_ModuleText.TextColor3 = colors['text1']
                      m_ModuleText.TextSize = 20
                      m_ModuleText.Text = text
                      m_ModuleText.TextStrokeTransparency = 0
                      m_ModuleText.TextStrokeColor3 = colors['text3']
                      m_ModuleText.ZIndex = M_IndexOffset
                      m_ModuleText.Parent = m_ModuleBackground
                      
                      m_ModuleIcon = inst('TextLabel')
                      m_ModuleIcon.Size = dim2off(25, 25)
                      m_ModuleIcon.Position = dim2sca(1,0)
                      m_ModuleIcon.AnchorPoint = vec2(1,0)
                      m_ModuleIcon.BackgroundTransparency = 1
                      m_ModuleIcon.Font = 'SourceSans'
                      m_ModuleIcon.TextXAlignment = 'Center'
                      m_ModuleIcon.TextColor3 = colors['text1']
                      m_ModuleIcon.TextSize = 18
                      m_ModuleIcon.Text = '+'
                      m_ModuleIcon.TextStrokeTransparency = 0
                      m_ModuleIcon.TextStrokeColor3 = colors['text3']
                      m_ModuleIcon.Rotation = 0
                      m_ModuleIcon.ZIndex = M_IndexOffset
                      m_ModuleIcon.Parent = m_ModuleBackground
                    
                    m_Menu = inst('Frame')
                    m_Menu.Size = dim2(1,0,0,0)
                    m_Menu.Position = dim2off(0,25)
                    m_Menu.BackgroundColor3 = colors['bg_setting']
                    m_Menu.BorderSizePixel = 0
                    m_Menu.ZIndex = M_IndexOffset-1
                    m_Menu.Visible = false
                    m_Menu.Parent = m_ModuleRoot
                    
                     m_MenuListLayout = inst('UIListLayout')
                     m_MenuListLayout.FillDirection = 'Vertical'
                     m_MenuListLayout.HorizontalAlignment = 'Left'
                     m_MenuListLayout.VerticalAlignment = 'Top'
                     m_MenuListLayout.Parent = m_Menu
                     
                end
                    
                local M_Object = {} do 
                    M_Object.Tooltip = nil
                    
                    M_Object.MToggled = false
                    M_Object.OToggled = false
                    
                    M_Object.Flags = {} do 
                        M_Object.Flags['Enabled'] = true
                        M_Object.Flags['Disabled'] = true
                        M_Object.Flags['Toggled'] = true
                    end
                    
                    M_Object.Name = text
                    M_Object.Menu = m_Menu
                    M_Object.Icon = m_ModuleIcon
                    M_Object.Effect = m_ModuleEnableEffect
                    M_Object.ZIndex = M_IndexOffset
                    
                    M_Object.Highlight = m_Highlight
                    
                    M_Object.Parent = self
                    M_Object.Root = m_ModuleRoot
                    
                    M_Object.AddToggle = base_class.module_create_toggle
                    M_Object.AddDropdown = base_class.module_create_dropdown
                    M_Object.AddModHotkey = base_class.module_create_modhotkey
                    M_Object.AddHotkey = base_class.module_create_hotkey
                    M_Object.AddSlider = base_class.module_create_slider
                    
                    M_Object.setvis = base_class.module_setvis
                    
                    M_Object.Toggle = base_class.module_toggle_self
                    M_Object.Disable = base_class.module_toggle_disable
                    M_Object.Enable = base_class.module_toggle_enable
                    
                    M_Object.ToggleMenu = base_class.module_toggle_menu
                    M_Object.GetState = base_class.module_getstate_self
                    M_Object.IsEnabled = base_class.module_getstate_self
                    M_Object.GetMenuState = base_class.module_getstate_menu
                    
                    M_Object.Connect = base_class.generic_connect
                    M_Object.SetTooltip = base_class.generic_tooltip
                end
                
                do
                    m_ModuleBackground.InputBegan:Connect(function(io) 
                        local uitv = io.UserInputType.Value
                        if (uitv == 0) then
                            M_Object:Toggle()
                            return
                        end
                        
                        if (uitv == 1) then
                            M_Object:ToggleMenu()
                            return
                        end
                    end)
                    
                    m_ModuleBackground.MouseEnter:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object-b']
                        
                        
                        local tt = M_Object.Tooltip
                        if (tt) then
                            w_Tooltip.Text = tt
                            w_TooltipHeader.Text = M_Object.Name
                            w_TooltipHeader.Visible = true
                        end
                    end)
                    
                    m_ModuleBackground.MouseLeave:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                        
                        if (w_Tooltip.Text == M_Object.Tooltip) then
                            w_TooltipHeader.Visible = false
                        end
                    end)
                end
                
                if (not nohotkey) then M_Object:AddModHotkey() end
                
                ins(ui_Modules, M_Object)
                return M_Object
            elseif (Type == 'Textbox') then
                local m_ModuleRoot
                 local m_ModuleBackground
                  local m_ModuleText
                   local m_ModulePadding
                  local m_ModuleIcon

                do
                    m_ModuleRoot = inst("Frame")
                    m_ModuleRoot.Size = dim2(1, 0, 0, 25)
                    m_ModuleRoot.AutomaticSize = "Y"
                    m_ModuleRoot.BackgroundTransparency = 1
                    m_ModuleRoot.BorderSizePixel = 0
                    m_ModuleRoot.ZIndex = M_IndexOffset-1
                    m_ModuleRoot.Parent = self.Menu
                    
                     m_ModuleBackground = inst("Frame")
                     m_ModuleBackground.Size = dim2(1,0,0,25)
                     m_ModuleBackground.BorderSizePixel = 0
                     m_ModuleBackground.ZIndex = M_IndexOffset
                     m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                     m_ModuleBackground.Parent = m_ModuleRoot
                     
                      m_ModuleEnableEffect = inst("Frame")
                      m_ModuleEnableEffect.BackgroundColor3 = colors['text1']
                      m_ModuleEnableEffect.BackgroundTransparency = 1
                      m_ModuleEnableEffect.ClipsDescendants = true
                      m_ModuleEnableEffect.Size = dim2(1,0,1,0)
                      m_ModuleEnableEffect.BorderSizePixel = 0
                      m_ModuleEnableEffect.ZIndex = M_IndexOffset
                      m_ModuleEnableEffect.Parent = m_ModuleBackground
                     
                     m_ModuleText = inst('TextBox')
                     m_ModuleText.Size = dim2(1, 0, 1, 0)
                     m_ModuleText.Position = dim2off(0, 0)
                     m_ModuleText.ClearTextOnFocus = true
                     m_ModuleText.TextWrapped = true
                     m_ModuleText.BackgroundTransparency = 1
                     m_ModuleText.Font = 'SourceSans'
                     m_ModuleText.TextXAlignment = 'Left'
                     m_ModuleText.TextColor3 = colors['text1']
                     m_ModuleText.TextSize = 20
                     m_ModuleText.Text = text
                     m_ModuleText.TextStrokeTransparency = 0
                     m_ModuleText.TextStrokeColor3 = colors['text3']
                     m_ModuleText.ZIndex = M_IndexOffset
                     m_ModuleText.Parent = m_ModuleBackground
                      
                      m_ModulePadding = inst("UIPadding")
                      m_ModulePadding.PaddingLeft = dim2off(5, 0).X
                      m_ModulePadding.Parent = m_ModuleText
                     
                     m_ModuleIcon = inst('TextLabel')
                     m_ModuleIcon.Size = dim2off(25, 25)
                     m_ModuleIcon.Position = dim2sca(1,0)
                     m_ModuleIcon.AnchorPoint = vec2(1,0)
                     m_ModuleIcon.BackgroundTransparency = 1
                     m_ModuleIcon.Font = 'SourceSans'
                     m_ModuleIcon.TextXAlignment = 'Center'
                     m_ModuleIcon.TextColor3 = colors['text1']
                     m_ModuleIcon.TextSize = 18
                     m_ModuleIcon.Text = '🅃'
                     m_ModuleIcon.TextStrokeTransparency = 0
                     m_ModuleIcon.TextStrokeColor3 = colors['text3']
                     m_ModuleIcon.Rotation = 0
                     m_ModuleIcon.ZIndex = M_IndexOffset
                     m_ModuleIcon.Parent = m_ModuleBackground
                end
                    
                local M_Object = {} do 
                    M_Object.Tooltip = nil
                    
                    
                    M_Object.Flags = {} do 
                        M_Object.Flags['Focused'] = true
                        M_Object.Flags['Unfocused'] = true
                        M_Object.Flags['TextChanged'] = true
                    end
                    
                    M_Object.Effect = m_ModuleEnableEffect
                    
                    M_Object.Name = text
                    M_Object.ZIndex = M_IndexOffset
                    
                    M_Object.Click = base_class.module_click_self
                    
                    M_Object.Connect = base_class.generic_connect
                    M_Object.SetTooltip = base_class.generic_tooltip
                end
                
                do
                    m_ModuleBackground.MouseEnter:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object-b']
                        
                        
                        local tt = M_Object.Tooltip
                        if (tt) then
                            w_Tooltip.Text = tt
                            w_TooltipHeader.Text = M_Object.Name
                            w_TooltipHeader.Visible = true
                        end
                    end)
                    
                    m_ModuleBackground.MouseLeave:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                        
                        if (w_Tooltip.Text == M_Object.Tooltip) then
                            w_TooltipHeader.Visible = false
                        end
                    end)
                    
                    m_ModuleText.FocusLost:Connect(function(enter) 
                        pcall(M_Object.Flags.Unfocused, m_ModuleText.Text, enter)
                    end)
                    m_ModuleText.Focused:Connect(function() 
                        pcall(M_Object.Flags.Focused)
                    end)
                    m_ModuleText:GetPropertyChangedSignal("Text"):Connect(function() 
                        pcall(M_Object.Flags.TextChanged, m_ModuleText.Text)
                    end)
                end
                
                ins(ui_Modules, M_Object)
                return M_Object
            elseif (Type == 'Button') then
                local m_ModuleRoot
                 local m_ModuleBackground
                  local m_Highlight
                  local m_ModuleEnableEffect
                  local m_ModuleText
                  local m_ModuleIcon

                do
                    m_ModuleRoot = inst("Frame")
                    m_ModuleRoot.Size = dim2(1, 0, 0, 25)
                    m_ModuleRoot.AutomaticSize = "Y"
                    m_ModuleRoot.BackgroundTransparency = 1
                    m_ModuleRoot.BorderSizePixel = 0
                    m_ModuleRoot.ZIndex = M_IndexOffset-1
                    m_ModuleRoot.Parent = self.Menu
                    
                     m_ModuleBackground = inst("Frame")
                     m_ModuleBackground.Size = dim2(1,0,0,25)
                     m_ModuleBackground.BorderSizePixel = 0
                     m_ModuleBackground.ZIndex = M_IndexOffset
                     m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                     m_ModuleBackground.Parent = m_ModuleRoot
                     
                     
                      m_ModuleEnableEffect = inst("Frame")
                      m_ModuleEnableEffect.BackgroundColor3 = colors['text1']
                      m_ModuleEnableEffect.BackgroundTransparency = 1
                      m_ModuleEnableEffect.ClipsDescendants = true
                      m_ModuleEnableEffect.Size = dim2(1,0,1,0)
                      m_ModuleEnableEffect.BorderSizePixel = 0
                      m_ModuleEnableEffect.ZIndex = M_IndexOffset
                      m_ModuleEnableEffect.Parent = m_ModuleBackground
                      
                      m_Highlight = inst("Frame")
                      m_Highlight.Size = dim2sca(1,1)
                      m_Highlight.BackgroundColor3 = colors['enabled']
                      m_Highlight.BackgroundTransparency = 0.7
                      m_Highlight.Visible = false
                      m_Highlight.ZIndex = M_IndexOffset
                      m_Highlight.BorderSizePixel = 0
                      m_Highlight.Parent = m_ModuleBackground
                     
                     m_ModuleText = inst('TextLabel')
                     m_ModuleText.Size = dim2(1, -5, 1, 0)
                     m_ModuleText.Position = dim2off(5, 0)
                     m_ModuleText.BackgroundTransparency = 1
                     m_ModuleText.Font = 'SourceSans'
                     m_ModuleText.TextXAlignment = 'Left'
                     m_ModuleText.TextColor3 = colors['text1']
                     m_ModuleText.TextSize = 20
                     m_ModuleText.Text = text
                     m_ModuleText.TextStrokeTransparency = 0
                     m_ModuleText.TextStrokeColor3 = colors['text3']
                     m_ModuleText.ZIndex = M_IndexOffset
                     m_ModuleText.Parent = m_ModuleBackground
                     
                     m_ModuleIcon = inst('TextLabel')
                     m_ModuleIcon.Size = dim2off(25, 25)
                     m_ModuleIcon.Position = dim2sca(1,0)
                     m_ModuleIcon.AnchorPoint = vec2(1,0)
                     m_ModuleIcon.BackgroundTransparency = 1
                     m_ModuleIcon.Font = 'SourceSans'
                     m_ModuleIcon.TextXAlignment = 'Center'
                     m_ModuleIcon.TextColor3 = colors['text1']
                     m_ModuleIcon.TextSize = 18
                     m_ModuleIcon.Text = '⦿'
                     m_ModuleIcon.TextStrokeTransparency = 0
                     m_ModuleIcon.TextStrokeColor3 = colors['text3']
                     m_ModuleIcon.Rotation = 0
                     m_ModuleIcon.ZIndex = M_IndexOffset
                     m_ModuleIcon.Parent = m_ModuleBackground
                end
                    
                local M_Object = {} do 
                    M_Object.Tooltip = nil
                    
                    
                    M_Object.Flags = {} do 
                        M_Object.Flags['Clicked'] = true
                    end
                    
                    M_Object.setvis = base_class.module_setvis
                    M_Object.Root = m_ModuleRoot
                    
                    M_Object.Highlight = m_Highlight
                    
                    
                    M_Object.Effect = m_ModuleEnableEffect
                    
                    M_Object.Name = text
                    M_Object.ZIndex = M_IndexOffset
                    
                    M_Object.Click = base_class.module_click_self
                    
                    M_Object.Connect = base_class.generic_connect
                    M_Object.SetTooltip = base_class.generic_tooltip
                end
                
                do
                    m_ModuleBackground.InputBegan:Connect(function(io) 
                        local uitv = io.UserInputType.Value
                        if (uitv == 0) then
                            M_Object:Click()
                            return
                        end
                    end)
                    
                    m_ModuleBackground.MouseEnter:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object-b']
                        
                        
                        local tt = M_Object.Tooltip
                        if (tt) then
                            w_Tooltip.Text = tt
                            w_TooltipHeader.Text = M_Object.Name
                            w_TooltipHeader.Visible = true
                        end
                    end)
                    
                    m_ModuleBackground.MouseLeave:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                        
                        if (w_Tooltip.Text == M_Object.Tooltip) then
                            w_TooltipHeader.Visible = false
                        end
                    end)
                end
                
                ins(ui_Modules, M_Object)
                return M_Object
            end
        end
        base_class.module_create_toggle = function(self, text) 
            text = tostring(text)
            
            local T_IndexOffset = self.ZIndex+1
            
            
            local t_Toggle
             local t_Box1
              local t_Box2
             local t_Text
            
            do
                t_Toggle = inst("Frame")
                t_Toggle.Size = dim2(1, 0, 0, 25)
                t_Toggle.BackgroundColor3 = colors['bg_setting']
                t_Toggle.BorderSizePixel = 0
                t_Toggle.ZIndex = T_IndexOffset
                t_Toggle.Parent = self.Menu
                 
                 t_Text = inst('TextLabel')
                 t_Text.Size = dim2(1, -10, 1, 0)
                 t_Text.Position = dim2off(10, 0)
                 t_Text.BackgroundTransparency = 1
                 t_Text.Font = 'SourceSans'
                 t_Text.TextXAlignment = 'Left'
                 t_Text.TextColor3 = colors['text1']
                 t_Text.TextSize = 18
                 t_Text.Text = text
                 t_Text.TextStrokeTransparency = 0
                 t_Text.TextStrokeColor3 = colors['text3']
                 t_Text.ZIndex = T_IndexOffset
                 t_Text.Parent = t_Toggle
                 
                 t_Box1 = inst('Frame')
                 t_Box1.Size = dim2off(10, 10)
                 t_Box1.Position = dim2(1,-5,0.5,-5)
                 t_Box1.AnchorPoint = vec2(1,0)
                 t_Box1.BackgroundTransparency = 0
                 t_Box1.BackgroundColor3 = colors['slider_bg']
                 t_Box1.BorderSizePixel = 0
                 t_Box1.ZIndex = T_IndexOffset
                 t_Box1.Parent = t_Toggle
                 
                 stroke(t_Box1)
                 
                 t_Box2 = inst('Frame')
                 t_Box2.Size = dim2off(8, 8)
                 t_Box2.Position = dim2off(1,1)
                 t_Box2.BackgroundTransparency = 1
                 t_Box2.BackgroundColor3 = colors['enabled']
                 t_Box2.BorderSizePixel = 0
                 t_Box2.Visible = true
                 t_Box2.ZIndex = T_IndexOffset
                 t_Box2.Parent = t_Box1
            end
                
            local T_Object = {} do 
                T_Object.Tooltip = nil
                T_Object.Toggled = false
                
                T_Object.Flags = {}
                T_Object.Flags['Enabled'] = true
                T_Object.Flags['Disabled'] = true
                T_Object.Flags['Toggled'] = true
                
                T_Object.Icon = t_Box2
                T_Object.Name = text
                
                T_Object.Toggle = base_class.setting_toggle_self
                T_Object.GetState = base_class.setting_toggle_getstate
                
                T_Object.Connect = base_class.generic_connect
                T_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                t_Toggle.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        T_Object:Toggle()
                        return
                    end
                end)
                
                t_Toggle.MouseEnter:Connect(function() 
                    t_Toggle.BackgroundColor3 = colors['bg_setting-b']
                    
                    local tt = T_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = T_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                t_Toggle.MouseLeave:Connect(function() 
                    t_Toggle.BackgroundColor3 = colors['bg_setting']
                    
                    if (w_Tooltip.Text == T_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            return T_Object            
        end
        base_class.module_create_dropdown = function(self, text, primary) 
            text = tostring(text)
            primary = primary or false
            
            local D_IndexOffset = self.ZIndex+1
            
            local d_Root
             local d_Header
              local d_HeaderText
              local d_HeaderIcon
              
              local d_Menu
               local d_MenuListLayout
            
            do
                d_Root = inst("Frame")
                d_Root.Size = dim2(1, 0, 0, 25)
                d_Root.AutomaticSize = "Y"
                d_Root.BackgroundTransparency = 1
                d_Root.BorderSizePixel = 0
                d_Root.ZIndex = D_IndexOffset-1
                d_Root.Parent = self.Menu
            
                 d_Header = inst('Frame')
                 d_Header.BackgroundColor3 = colors['bg_setting']
                 d_Header.Size = dim2(1, 0, 0, 25)
                 d_Header.Active = true
                 d_Header.BorderSizePixel = 0
                 d_Header.ZIndex = D_IndexOffset+1
                 d_Header.Parent = d_Root
                 
                  d_HeaderText = inst('TextLabel')
                  d_HeaderText.Size = dim2(1, -10, 1, 0)
                  d_HeaderText.Position = dim2off(10, 0)
                  d_HeaderText.BackgroundTransparency = 1
                  d_HeaderText.Font = 'SourceSans'
                  d_HeaderText.TextXAlignment = 'Left'
                  d_HeaderText.TextColor3 = colors['text1']
                  d_HeaderText.TextSize = 18
                  d_HeaderText.Text = text
                  d_HeaderText.TextStrokeTransparency = 0
                  d_HeaderText.TextStrokeColor3 = colors['text3']
                  d_HeaderText.ZIndex = D_IndexOffset+1
                  d_HeaderText.Parent = d_Header
                  
                  d_HeaderIcon = inst('ImageLabel')
                  d_HeaderIcon.Size = dim2off(25, 25)
                  d_HeaderIcon.Position = dim2sca(1,0)
                  d_HeaderIcon.AnchorPoint = vec2(1,0)
                  d_HeaderIcon.BackgroundTransparency = 1
                  d_HeaderIcon.ImageColor3 = colors['text1']
                  d_HeaderIcon.Image = 'rbxassetid://7184113125'
                  d_HeaderIcon.Rotation = 180
                  d_HeaderIcon.ZIndex = D_IndexOffset+1
                  d_HeaderIcon.Parent = d_Header
                 
                 d_Menu = inst('Frame')
                 d_Menu.Size = dim2(1,0,0,0)
                 d_Menu.AutomaticSize = "Y"
                 d_Menu.Position = dim2off(0, 25)
                 d_Menu.BackgroundColor3 = colors['bg_dropdown']
                 d_Menu.BorderSizePixel = 0
                 d_Menu.ZIndex = D_IndexOffset
                 d_Menu.Visible = false
                 d_Menu.Parent = d_Header
                 
                  d_MenuListLayout = inst('UIListLayout')
                  d_MenuListLayout.FillDirection = 'Vertical'
                  d_MenuListLayout.HorizontalAlignment = 'Left'
                  d_MenuListLayout.VerticalAlignment = 'Top'
                  d_MenuListLayout.Parent = d_Menu
            end
            
            local D_Object = {} do 
                D_Object.Tooltip = nil
                D_Object.MToggled = false
                
                D_Object.Primary = primary
                
                D_Object.Menu = d_Menu
                D_Object.Name = text
                D_Object.Parent = self
                D_Object.Icon = d_HeaderIcon
                D_Object.ZIndex = D_IndexOffset
                
                D_Object.Selection = nil
                
                D_Object.Objects = {}
                
                
                D_Object.Flags = {}
                D_Object.Flags['SelectionChanged'] = true
                
                D_Object.Toggle = base_class.menu_toggle
                D_Object.GetSelection = base_class.setting_dropdown_getselection
                
                D_Object.Connect = base_class.generic_connect
                D_Object.SetTooltip = base_class.generic_tooltip
                D_Object.AddOption = base_class.dropdown_create_option
            end
            
            do
                d_Header.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0 or uitv == 1) then
                        D_Object:Toggle()
                        return
                    end
                end)
                
                d_Header.MouseEnter:Connect(function() 
                    d_Header.BackgroundColor3 = colors['bg_setting-b']
                    
                    local tt = D_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = D_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                d_Header.MouseLeave:Connect(function() 
                    d_Header.BackgroundColor3 = colors['bg_setting']
                    
                    if (w_Tooltip.Text == D_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            return D_Object
        end
        base_class.module_create_modhotkey = function(self) 
            local H_IndexOffset = self.ZIndex+1
            
            local h_Hotkey
             local h_Text
            
            do
                h_Hotkey = inst("Frame")
                h_Hotkey.Size = dim2(1, 0, 0, 25)
                h_Hotkey.BackgroundColor3 = colors['bg_setting']
                h_Hotkey.BorderSizePixel = 0
                h_Hotkey.ZIndex = H_IndexOffset
                h_Hotkey.Parent = self.Menu
                 
                 h_Text = inst('TextLabel')
                 h_Text.Size = dim2(1, -10, 1, 0)
                 h_Text.Position = dim2off(10, 0)
                 h_Text.BackgroundTransparency = 1
                 h_Text.Font = 'SourceSans'
                 h_Text.TextXAlignment = 'Left'
                 h_Text.TextColor3 = colors['text1']
                 h_Text.TextSize = 18
                 h_Text.Text = 'Hotkey: N/A'
                 h_Text.TextStrokeTransparency = 0
                 h_Text.TextStrokeColor3 = colors['text3']
                 h_Text.ZIndex = H_IndexOffset
                 h_Text.Parent = h_Hotkey
            end
                
            local H_Object = {} do 
                H_Object.Label = h_Text
                H_Object.Hotkey = nil
                
                H_Object.Parent = self
                H_Object.Tooltip = nil
                
                H_Object.Flags = {}
                H_Object.Flags['HotkeySet'] = true
                
                H_Object.SetHotkey = base_class.setting_modhotkey_sethotkey
                H_Object.GetHotkey = base_class.setting_modhotkey_gethotkey
                
                H_Object.Connect = base_class.generic_connect
                H_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                h_Hotkey.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        H_Object:SetHotkey()
                        return
                    end
                end)
                
                h_Hotkey.MouseEnter:Connect(function() 
                    h_Hotkey.BackgroundColor3 = colors['bg_setting-b']
                end)
                
                h_Hotkey.MouseLeave:Connect(function() 
                    h_Hotkey.BackgroundColor3 = colors['bg_setting']
                end)
            end
            
            return H_Object   
        end
        base_class.module_create_hotkey = function(self, text) 
            local H_IndexOffset = self.ZIndex+1
            
            local h_Hotkey
             local h_Text
            
            do
                h_Hotkey = inst("Frame")
                h_Hotkey.Size = dim2(1, 0, 0, 25)
                h_Hotkey.BackgroundColor3 = colors['bg_setting']
                h_Hotkey.BorderSizePixel = 0
                h_Hotkey.ZIndex = H_IndexOffset
                h_Hotkey.Parent = self.Menu
                 
                 h_Text = inst('TextLabel')
                 h_Text.Size = dim2(1, -10, 1, 0)
                 h_Text.Position = dim2off(10, 0)
                 h_Text.BackgroundTransparency = 1
                 h_Text.Font = 'SourceSans'
                 h_Text.TextXAlignment = 'Left'
                 h_Text.TextColor3 = colors['text1']
                 h_Text.TextSize = 18
                 h_Text.Text = tostring(text)..': N/A'
                 h_Text.TextStrokeTransparency = 0
                 h_Text.TextStrokeColor3 = colors['text3']
                 h_Text.ZIndex = H_IndexOffset
                 h_Text.Parent = h_Hotkey
            end
                
            local H_Object = {} do 
                H_Object.Label = h_Text
                H_Object.Hotkey = nil
                
                H_Object.Parent = self
                H_Object.Tooltip = nil
                
                H_Object.Name = tostring(text)
                H_Object.Flags = {}
                H_Object.Flags['HotkeySet'] = true
                
                H_Object.bind = base_class.setting_hotkey_sethotkey
                H_Object.SetHotkey = base_class.setting_hotkey_sethotkeyexplicit
                H_Object.GetHotkey = base_class.setting_hotkey_gethotkey
                
                H_Object.Connect = base_class.generic_connect
                H_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                h_Hotkey.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        H_Object:bind()
                        return
                    end
                end)
                
                h_Hotkey.MouseEnter:Connect(function() 
                    h_Hotkey.BackgroundColor3 = colors['bg_setting-b']
                    
                    local tt = H_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = H_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                h_Hotkey.MouseLeave:Connect(function() 
                    h_Hotkey.BackgroundColor3 = colors['bg_setting']
                    
                    if (w_Tooltip.Text == H_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            return H_Object   
        end
        base_class.module_create_slider = function(self, text, args) 
            text = tostring(text)
            
            args['min'] = args['min'] or 0
            args['max'] = args['max'] or 100
            args['cur'] = args['cur'] or args['min']
            args['step'] = args['step'] or 1
            
            
            if (tostring(args['step']):match("e%-")) then
                error(("%s failed; %s was too %s"):format('module_create_slider', 'args.step', 'small'))
            end
            if (tostring(args['step']):match("e%+")) then 
                error(("%s failed; %s was too %s"):format('module_create_slider', 'args.step', 'large'))
            end
            
            local S_IndexOffset = self.ZIndex+1
            
            local s_Slider
             local s_Text
              local s_TextPad
             local s_Amount
             local s_SliderBarBg
              local s_SliderBar
              
            do
                s_Slider = inst("Frame")
                s_Slider.Size = dim2(1, 0, 0, 25)
                s_Slider.BackgroundColor3 = colors['bg_setting']
                s_Slider.BorderSizePixel = 0
                s_Slider.ZIndex = S_IndexOffset
                s_Slider.Parent = self.Menu
                 
                 s_Text = inst('TextLabel')
                 s_Text.Size = dim2sca(1, 1)
                 s_Text.Position = dim2off(0, 0)
                 s_Text.BackgroundTransparency = 0.6
                 s_Text.BorderSizePixel = 0
                 s_Text.BackgroundColor3 = colors['bg_setting']
                 s_Text.Font = 'SourceSans'
                 s_Text.TextXAlignment = 'Left'
                 s_Text.TextColor3 = colors['text1']
                 s_Text.TextSize = 18
                 s_Text.Text = text
                 s_Text.Visible = true
                 s_Text.TextStrokeTransparency = 0
                 s_Text.TextStrokeColor3 = colors['text3']
                 s_Text.ZIndex = S_IndexOffset + 1
                 s_Text.Parent = s_Slider
                  
                  s_TextPad = inst("UIPadding")
                  s_TextPad.PaddingLeft = dim2off(10, 0).X
                  s_TextPad.Parent = s_Text 
                 
                 s_Amount = inst('TextLabel')
                 s_Amount.Size = dim2(0, 30, 1, 0)
                 s_Amount.Position = dim2(1,-5,0,0)
                 s_Amount.AnchorPoint = vec2(1,0)
                 s_Amount.BackgroundTransparency = 1
                 s_Amount.BorderSizePixel = 0
                 s_Amount.Font = 'SourceSans'
                 s_Amount.TextXAlignment = 'Center'
                 s_Amount.TextColor3 = colors['text1']
                 s_Amount.TextSize = 18
                 s_Amount.Visible = true
                 s_Amount.TextStrokeTransparency = 0
                 s_Amount.TextStrokeColor3 = colors['text3']
                 s_Amount.ZIndex = S_IndexOffset + 1 
                 s_Amount.Parent = s_Slider
                 
                 s_SliderBarBg = inst("Frame")
                 s_SliderBarBg.Size = dim2(1, -16, 0, 6)
                 s_SliderBarBg.Position = dim2(0, 8, 0.5, -3)
                 s_SliderBarBg.BackgroundColor3 = colors['slider_bg']
                 s_SliderBarBg.BorderSizePixel = 0
                 s_SliderBarBg.ZIndex = S_IndexOffset
                 s_SliderBarBg.ClipsDescendants = true
                 s_SliderBarBg.Parent = s_Slider
                 
                  s_SliderBar = inst("Frame")
                  s_SliderBar.Size = dim2sca(1, 1)
                  s_SliderBar.Position = dim2(0,0)
                  s_SliderBar.AnchorPoint = vec2(0, 0)
                  s_SliderBar.BackgroundColor3 = colors['slider_fg']
                  s_SliderBar.BorderSizePixel = 0
                  s_SliderBar.ZIndex = S_IndexOffset
                  s_SliderBar.Parent = s_SliderBarBg
                 
            end
            
            local StepFormat = #(tostring(args['step']):match("%.(%d+)") or '')
            StepFormat = ("%."..StepFormat.."f")
            
            s_Amount.Text = StepFormat:format(args['cur'])
            
            
            local DragConn
                
            local S_Object = {} do 
                S_Object.Tooltip = nil
                S_Object.Name = text
                
                S_Object.SliderFill = s_SliderBar
                S_Object.SliderBg = s_SliderBarBg
                S_Object.SliderAmnt = s_Amount
                
                
                S_Object.SliderSize = s_SliderBarBg.AbsoluteSize.X
                
                S_Object.CurrentVal = args['cur']
                S_Object.PreviousVal = nil
                S_Object.Min = args['min']
                S_Object.Max = args['max']
                S_Object.Step = args['step']
                S_Object.Ratio = S_Object.SliderSize / (S_Object.Max - S_Object.Min)
                S_Object.RatioInverse = 1 / S_Object.Ratio
                S_Object.StepFormat = StepFormat
                
                
                
                
                
                S_Object.Flags = {}
                S_Object.Flags['ValueChanged'] = true
                
                S_Object.GetValue = base_class.setting_slider_getval
                S_Object.SetValue = base_class.setting_slider_setvalnum
                S_Object.SetValuePos = base_class.setting_slider_setvalpos
                
                S_Object.Connect = base_class.generic_connect
                S_Object.SetTooltip = base_class.generic_tooltip
            end
            
            S_Object:SetValue(args['cur'])
            
            do
                s_Slider.MouseEnter:Connect(function() 
                    s_Slider.BackgroundColor3 = colors['bg_setting-b']
                    
                    twn(s_Text, {BackgroundTransparency = 1, TextTransparency = 1, TextStrokeTransparency = 1},true)
                    twn(s_Amount, {Position = dim2(0.5,15,0,0)}, true)
                    
                    local tt = S_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = S_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                s_Slider.MouseLeave:Connect(function() 
                    s_Slider.BackgroundColor3 = colors['bg_setting']
                    twn(s_Text, {BackgroundTransparency = 0.2, TextTransparency = 0, TextStrokeTransparency = 0},true)
                    twn(s_Amount, {Position = dim2(1,-5,0,0)}, true)
                    
                    if (w_Tooltip.Text == S_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
                
                s_SliderBarBg.InputBegan:Connect(function(io) 
                    if (io.UserInputType.Value == 0) then
                        S_Object:SetValuePos(io.Position.X)
                        
                        DragConn = serv_uis.InputChanged:Connect(function(io) 
                            if (io.UserInputType.Value == 4) then
                                S_Object:SetValuePos(io.Position.X)
                            end
                        end)
                    end
                end)
                
                s_SliderBarBg.InputEnded:Connect(function(io) 
                    if (io.UserInputType.Value == 0) then
                        DragConn:Disconnect()
                    end
                end)
            end
            return S_Object            
        end
        
        
        base_class.dropdown_create_option = function(self, text) 
            text = tostring(text)

            local O_IndexOffset = self.ZIndex + 1
            
            local o_Option
             local o_Text
             local o_EnableEffect
             local o_EnableEffect2
            
            do
                o_Option = inst("Frame")
                o_Option.Size = dim2(1, 0, 0, 25)
                o_Option.BackgroundColor3 = colors['bg_dropdown']
                o_Option.BorderSizePixel = 0
                o_Option.ZIndex = O_IndexOffset
                o_Option.Parent = self.Menu
                 
                 o_Text = inst('TextLabel')
                 o_Text.Size = dim2(1, -15, 1, 0)
                 o_Text.Position = dim2off(15, 0)
                 o_Text.BackgroundTransparency = 1
                 o_Text.Font = 'SourceSans'
                 o_Text.TextXAlignment = 'Left'
                 o_Text.TextColor3 = colors['text1']
                 o_Text.TextSize = 18
                 o_Text.Text = text
                 o_Text.TextStrokeTransparency = 0
                 o_Text.TextStrokeColor3 = colors['text3']
                 o_Text.ZIndex = O_IndexOffset
                 o_Text.Parent = o_Option
                 
                 o_EnableEffect = inst("Frame")
                 o_EnableEffect.BackgroundColor3 = colors['text1']
                 o_EnableEffect.BackgroundTransparency = 0.96
                 o_EnableEffect.ClipsDescendants = true
                 o_EnableEffect.Size = dim2(0,0,1,0)
                 o_EnableEffect.BorderSizePixel = 0
                 o_EnableEffect.ZIndex = O_IndexOffset
                 o_EnableEffect.Parent = o_Option
                 
                  o_EnableEffect2 = inst("Frame")
                  o_EnableEffect2.BackgroundColor3 = colors['enabled']
                  o_EnableEffect2.Size = dim2(0,2,1,0)
                  o_EnableEffect2.BorderSizePixel = 0
                  o_EnableEffect2.ZIndex = O_IndexOffset
                  o_EnableEffect2.Parent = o_EnableEffect
            end
                
            local O_Object = {} do 
                O_Object.Tooltip = nil
                O_Object.Selected = false
                
                O_Object.Icon = t_Box2
                O_Object.Name = text
                O_Object.Parent = self
                
                O_Object.Effect = o_EnableEffect
                
                O_Object.Select = base_class.setting_ddoption_select_self
                O_Object.Deselect = base_class.setting_ddoption_deselect_self
                
                O_Object.GetState = base_class.setting_ddoption_selected_getstate
                O_Object.IsSelected = base_class.setting_ddoption_selected_getstate
                
                O_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                o_Option.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        O_Object:Select()
                        return
                    end
                end)
                
                o_Option.MouseEnter:Connect(function() 
                    o_Option.BackgroundColor3 = colors['bg_dropdown-b']
                    
                    local tt = O_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = O_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                o_Option.MouseLeave:Connect(function() 
                    o_Option.BackgroundColor3 = colors['bg_dropdown']
                    
                    if (w_Tooltip.Text == O_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            ins(self.Objects, O_Object)
            return O_Object
        end
    end
    
    -- UI functions
    function ui:CreateMenu(text) 
        local M_Id = #ui_Menus+1
        local M_IndexOffset = M_Id * 15
        
        local m_Header
         local m_HeaderEnableEffect
         local m_HeaderText
         local m_HeaderIcon
         
         local m_Menu
          local m_MenuListLayout
        
        m_Header = inst('ImageButton')
        m_Header.BackgroundColor3 = colors['bg_header']
        m_Header.Size = dim2off(250, 30)
        m_Header.Active = true
        m_Header.ClipsDescendants = false
        m_Header.AutoButtonColor = false
        m_Header.BorderSizePixel = 0
        m_Header.Position = dim2off(
            (0.1*((M_Id-1)%6) * monitor_resolution.X)+(100*((M_Id-1)%6)+100), 
            0
        )
        
        local t_MID = M_Id
        local y = 100 
        for i=0, 100, 6 do 
            if t_MID > i then
                y += 100
            else
                break
            end
        end
        m_Header.Position += dim2off(0,y)
        
        m_Header.ZIndex = M_IndexOffset+2
        m_Header.Parent = w_Backframe
        
         m_HeaderEnableEffect = inst("Frame")
         m_HeaderEnableEffect.BackgroundColor3 = colors['enabled']
         m_HeaderEnableEffect.Size = dim2(0,0,1,0)
         m_HeaderEnableEffect.BorderSizePixel = 0
         m_HeaderEnableEffect.ZIndex = M_IndexOffset+2
         m_HeaderEnableEffect.Parent = m_Header
        
         m_HeaderText = inst('TextLabel')
         m_HeaderText.Size = dim2(1, 0, 1, 0)
         m_HeaderText.Position = dim2off(0, 0)
         m_HeaderText.BackgroundTransparency = 1
         m_HeaderText.Font = 'SourceSans'
         m_HeaderText.TextXAlignment = 'Center'
         m_HeaderText.TextColor3 = colors['text1']
         m_HeaderText.TextSize = 22
         m_HeaderText.Text = text
         m_HeaderText.TextStrokeTransparency = 0
         m_HeaderText.TextStrokeColor3 = colors['text3']
         m_HeaderText.ZIndex = M_IndexOffset+2
         m_HeaderText.Parent = m_Header
         
         m_HeaderIcon = inst('ImageLabel')
         m_HeaderIcon.Size = dim2off(30, 30)
         m_HeaderIcon.Position = dim2sca(1,0)
         m_HeaderIcon.AnchorPoint = vec2(1,0)
         m_HeaderIcon.BackgroundTransparency = 1
         m_HeaderIcon.ImageColor3 = colors['text1']
         m_HeaderIcon.Image = 'rbxassetid://7184113125'
         m_HeaderIcon.Rotation = 180
         m_HeaderIcon.ZIndex = M_IndexOffset+2
         m_HeaderIcon.Parent = m_Header
        
        m_Menu = inst('Frame')
        m_Menu.Size = dim2(1,0,0,0)
        m_Menu.Position = dim2off(0, 30)
        m_Menu.AutomaticSize = "Y"
        m_Menu.BackgroundColor3 = colors['bg_object']
        m_Menu.BorderSizePixel = 0
        m_Menu.ZIndex = M_IndexOffset
        m_Menu.Visible = false
        m_Menu.Parent = m_Header
        
         m_MenuListLayout = inst('UIListLayout')
         m_MenuListLayout.FillDirection = 'Vertical'
         m_MenuListLayout.HorizontalAlignment = 'Left'
         m_MenuListLayout.VerticalAlignment = 'Top'
         m_MenuListLayout.Parent = m_Menu
        
        stroke(m_Header)
        stroke(m_Menu)
        
        
        
        
        local M_Object = {} do 
            M_Object.MToggled = false
            M_Object.Menu = m_Menu
            M_Object.Icon = m_HeaderIcon
            M_Object.ZIndex = M_IndexOffset
            M_Object.Enabled = m_HeaderEnableEffect
            
            M_Object.AddMod = base_class.menu_create_module
            
            
            M_Object.Toggle = base_class.menu_toggle
            M_Object.GetState = base_class.menu_getstate
        end
        
        do
            local prevclicktime = 0
            m_Header.InputBegan:Connect(function(io) 
                local uitv = io.UserInputType.Value
                if (uitv == 0) then
                    local currclicktime = time()
                    if (currclicktime - prevclicktime < 0.3) then
                        M_Object:Toggle()
                    end
                    prevclicktime = currclicktime
                    
                    
                    local root_pos = m_Header.AbsolutePosition
                    local start_pos = io.Position
                    start_pos = vec2(start_pos.X, start_pos.Y)
                    
                    ui_Connections['menu-'..M_Id] = serv_uis.InputChanged:Connect(function(io) 
                        if (io.UserInputType.Value == 4) then
                            local curr_pos = io.Position
                            curr_pos = vec2(curr_pos.X, curr_pos.Y)
                            
                            local destination = root_pos + (curr_pos - start_pos) + monitor_inset
                            
                            twn(m_Header, {Position = dim2off(destination.X, destination.Y)})
                        end
                    end)
                    return
                end
                
                if (uitv == 1) then
                    M_Object:Toggle()
                end
            end)
            m_Header.InputEnded:Connect(function(io) 
                if (io.UserInputType.Value == 0) then
                    local a = ui_Connections['menu-'..M_Id]
                    if (a) then a:Disconnect() end
                end
            end)
            
            m_Header.MouseEnter:Connect(function() 
                m_Header.BackgroundColor3 = colors['bg_header-b']
            end)
            
            m_Header.MouseLeave:Connect(function() 
                m_Header.BackgroundColor3 = colors['bg_header']
            end)
        end
        
        
        
        ins(ui_Menus, M_Object)
        return M_Object
    end
    function ui:Destroy() 
        pcall(ui.Flags.Destroying)
        
        
        -- Destroy
        w_Screen:Destroy()
        
        -- Unbinds
        serv_ctx:UnbindAction('RL-ToggleMenu')
        
        -- Disconnections
        pcall(function() input_connection:Disconnect() end)
        
        for i,v in pairs(ui_Connections) do 
            v:Disconnect() 
        end
        
        -- Variable clearing
        colors = nil
        shadow,getnext,stroke,round,uierror = nil
        ui_Menus = nil
        
        _G.RLLoaded = false
    end
    function ui:GetModules() 
        return ui_Modules
    end
    
    ui.Flags = {}
    ui.Flags.Destroying = true
    ui.Connect = base_class.generic_connect
    
    
    -- Bind gui
    serv_ctx:BindActionAtPriority('RL-ToggleMenu',function(_,uis) 
        
        if (uis.Value == 0) then
            W_WindowOpen = not W_WindowOpen
            
            if (W_WindowOpen) then
                w_Backframe.Visible = true
                twn(w_Backframe, {Position = dim2(0, 0, 0, 0)}, true)
            else
                twn(w_Backframe, {Position = dim2(0, 0, -1, 0)}, true).Completed:Connect(function() w_Backframe.Visible = false end)
            end
        end
    end,false,999999,Enum.KeyCode.RightShift)
    -- Auto collection
    delay(5, function() 
        if (ui_Menus ~= nil and #ui_Menus == 0) then
            ui:Destroy()
            warn'[REDLINE] Failure to clean library resources!\nAutomatically cleared for you; make sure to\ncall ui:Destroy() when finished'
        end
    end)
end

--delay(40, ui.Destroy, ui)
serv_ctx:BindActionAtPriority('RL-Destroy',function(_,uis) 
        
    if (uis.Value == 0) then
        ui:Destroy()
    end
end,false,999999,Enum.KeyCode.End)

-- holy shit
local isexecclosure = is_synapse_function or 
    isourclosure or 
    is_our_closure or 
    isoxygenfunction or 
    isexecclosure or 
    isexecfunction or 
    is_exec_function or 
    is_exec_func or 
    is_executor_closure or 
    is_exec_closure or 
    isexecfunc or 
    is_executor_func or 
    is_executor_function or
    iselectronfunction or 
    isexecutorclosure or
    iskrnlfunction or
    iskrnlclosure or
    isfluxusfunction
    
-- disable non executor connections
local function ratio(signal) 
    local average = getconnections(signal)
    for i = 1, #average do 
        local connection = average[i]
        local confunc = connection.Function
        
        if (islclosure(confunc)) then
            if (not isexecclosure(confunc)) then
                connection:Disable()
            end
        end
    end
end
local function unratio(signal)
    local average = getconnections(signal)
    for i = 1, #average do 
        local connection = average[i]
        local confunc = connection.Function
        
        if (islclosure(confunc)) then
            if (not isexecclosure(confunc)) then
                connection:Enable()
            end
        end
    end
end

local cons = {}

local l_plr = serv_players.LocalPlayer
local l_chr = l_plr.Character
local l_hum = l_chr:FindFirstChild("Humanoid")
local l_humrp = l_chr:FindFirstChild("HumanoidRootPart")

local l_cam = workspace.CurrentCamera or workspace:FindFirstChildOfClass("Camera")

cons['chr'] = l_plr.CharacterAdded:Connect(function(c) 
    l_chr = c
    l_hum = c:WaitForChild("Humanoid",3)
    l_humrp = c:WaitForChild("HumanoidRootPart",3)
end)

-- Every single player 
local p_players = {}
-- Every player minus friends and local player 
local p_players_nolfr = {}

local function addplr(p) 
    local ptable = {}
    ptable['plr'] = p
    ptable['chr'] = nil
    ptable['hum'] = nil
    ptable['rp'] = nil
    
    ptable['cons'] = {}
    
    ptable['cons'][1] = p.CharacterAdded:Connect(function(c) 
        ptable['chr'] = c
        ptable['hum'] = c:WaitForChild("Humanoid", 1)
        ptable['rp'] = c:WaitForChild("HumanoidRootPart", 1)
    end)
    
    ins(p_players_all, ptable)
end 
local function remplr(p) 
    -- Player left, find the player object in each table
    for i = 1, #p_players do 
        local plr = p_players[i]
        -- Check for matching player objects
        if (plr.plr == p) then
            local cons = plr.cons
            -- Disable connections
            for i = 1, #cons do cons[i]:Disconnect() end
            -- Clear table and stuff
            p_players[i] = nil
            -- Remove it from the player list
            rem(p_players, i)
            break
        end
    end
    -- Next check the other table
    for i = 1, #p_players_nolfr do 
        local plr = p_players_nolfr[i]
        -- Check for matching player objects
        if (plr.plr == p) then
            local cons = plr.cons
            -- Disable connections
            for i = 1, #cons do cons[i]:Disconnect() end
            -- Clear table and stuff
            p_players_all[i] = nil
            -- Remove it from the player list
            rem(p_players_all, i)
            break
        end
    end
end

cons['p1'] = serv_players.PlayerAdded:Connect(addplr)
cons['p2'] = serv_players.PlayerRemoving:Connect(remplr)
cons['cam'] = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function() 
    local cc = workspace.CurrentCamera
    if not cc then
        cc = workspace:FindFirstChildOfClass("Camera")
    end
    l_cam = cc
end)
for i,p in ipairs(serv_players:GetChildren()) do 
    addplr(p)
end


ui:Connect("Destroying", function() 
    for i,v in pairs(cons) do v:Disconnect() end
    for i,v in ipairs(ui:GetModules()) do 
        if (v.Toggle and v:IsEnabled()) then
            v:Toggle()
        end
    end
    
    for i = 1, #p_players_all do 
        local _ = p_players_all[i].cons
        for i = 1, #_ do _[i]:Disconnect() end
    end

    for i = 1, #p_players_nolfr do 
        local _ = p_players_nolfr[i].cons
        for i = 1, #_ do _[i]:Disconnect() end
    end
end)

local m_combat = ui:CreateMenu('Combat') do 
    local c_aimbot  = m_combat:AddMod('Aimbot') -- Locks mouse / camera onto target, useful for shooter games
    local c_antiaim = m_combat:AddMod('Anti-aim') -- Spins you around, janks up hitboxes
    local c_hitbox  = m_combat:AddMod('Hitboxes') -- Hitbox expander
    local c_stare   = m_combat:AddMod('Stare') -- Always faces you towards the nearest player, useful for sword fighting games
    local c_tpbot   = m_combat:AddMod('TPbot') -- TPbot, useful for sword fighting games
    local c_trigbot = m_combat:AddMod('Triggerbot') -- Triggerbot, useful for shooter games    
    
    
    -- Aimbot 
    do
        local c_aim_team   = c_aimbot:AddToggle('Team check')
        local c_aim_friend = c_aimbot:AddToggle('Friend check')
        local c_aim_lock   = c_aimbot:AddToggle('Player lock')
        local c_aim_mode   = c_aimbot:AddDropdown('Aimbot mode',true)
        local c_aim_smooth = c_aimbot:AddSlider('Smoothness',{min=0,max=100,cur=15,step=0.25})
        
        
        c_aim_team:SetTooltip('Blacklists players on your team from the aimbot check')
        c_aim_friend:SetTooltip('Blacklists players added to your Redline friends list from the aimbot check')
        c_aim_lock:SetTooltip('Locks onto the first valid player and doesn\'t switch from them')
        c_aim_mode:SetTooltip('The aimbot mode used')
        
        do
            c_aim_mode:AddOption('Mouse')
            :Select()
            :SetTooltip('Uses mousemoverel. May not be as stable as Camera, but it\'s significantly better.');
            
            c_aim_mode:AddOption('Camera')
            :SetTooltip('Makes the Camera face the target. Although it works good, it has compatibility issues with complex games');
        end
        
        
        c_aimbot:SetTooltip('Classic aimbot, use in FPS games like Arsenal')
    end
    -- Antiaim
    do 
        local c_aim_always = c_antiaim:AddToggle('Always spin')
        local c_aim_mode = c_antiaim:AddDropdown('Anti-aim mode', true)
        c_aim_mode:SetTooltip('The mode Anti-aim uses')
        c_aim_always:SetTooltip('Spins while not moving')
        
        do 
            local _ = c_aim_mode:AddOption('Horizontal spin')
            :Select()
            :SetTooltip('Only spins you around horizontally')
            
            c_aim_mode:AddOption('Omnidirectional spin')
            :SetTooltip('Spins you around in every direction')
        end
        
        
        c_antiaim:SetTooltip('Prevents others from headshotting you by spinning you around')
    end
    -- Hitbox
    do 
        local c_hitb_team    = c_hitbox:AddToggle('Team check')
        local c_hitb_friend  = c_hitbox:AddToggle('Friend check')
        local c_hitb_display = c_hitbox:AddToggle('Show hitboxes')
        
        c_hitb_team:SetTooltip('Disables the expander for your teammates')
        c_hitb_friend:SetTooltip('Disables the expander for players on your Redline friends list')
        c_hitb_display:SetTooltip('Displays the expanded hitboxes')
        
        
        c_hitbox:SetTooltip('Hitbox expander, use in FPS or swordfighting games')
    end
    -- Stare
    do
        local c_stare_team   = c_stare:AddToggle('Team check')
        local c_stare_friend = c_stare:AddToggle('Friend check')
        
        c_stare_team:SetTooltip('Disables stare for your teammates')
        c_stare_friend:SetTooltip('Disables stare for your friends')
        
        
        
        c_stare:SetTooltip('Always faces you towards the nearest player, useful for sword fighting games')
    end
    -- Tp bot 
    do
        local c_tpbot_team   = c_tpbot:AddToggle('Team check')
        local c_tpbot_friend = c_tpbot:AddToggle('Friend check')
        local c_tpbot_face   = c_tpbot:AddToggle('Face center')
        
        c_tpbot_team:SetTooltip('Disables TPbot for your teammates')
        c_tpbot_friend:SetTooltip('Disables TPbot for your friends')
        c_tpbot_face:SetTooltip('Faces your character towards the position you\'re teleporting around')
        
        
        c_tpbot:SetTooltip('Teleports you around the nearest player. Can prevent you from being hit, also useful for swordfighting games')
        
        -- Check for closest player every .03s or so
        -- Get distance, check if less than user input 
        -- If so then lock onto them until their character dies or you move away
    end
    -- Trig bot
    do 
        local c_trig_team = c_trigbot:AddToggle('Team check')
        local c_trig_friend = c_trigbot:AddToggle('Friend check')
        
        
        c_trig_team:SetTooltip('Disables Triggerbot for your teammates')
        c_trig_friend:SetTooltip('Disables Triggerbot for your friends')
        
        c_trigbot:SetTooltip('Automatically clicks when you mouse over a player')
        
    end
end
local m_player = ui:CreateMenu('Player') do 
    local p_among       = m_player:AddMod('Amongus') -- turns into amongus
    local p_antiafk     = m_player:AddMod('Anti-AFK') -- Anti AFK w/ walk around modes and generic getconnections:Disable mode
    local p_antifling   = m_player:AddMod('Anti-fling') -- Prevents skids from flinging you
    local p_antiwarp    = m_player:AddMod('Anti-warp') -- Prevents you from being teleported backwards, has a lerp setting
    local p_autoclick   = m_player:AddMod('Auto clicker') -- Auto clicker
    local p_fancy       = m_player:AddMod('Fancy chat') -- Fancy chat
    local p_flashback   = m_player:AddMod('Flashback')
    local p_logs        = m_player:AddMod('Logs') -- Join and chat logs
    local p_pathfind    = m_player:AddMod('Pathfinder') -- Does some funny stuff for pathing
    local p_radar       = m_player:AddMod('Radar') -- Radar for other players
    local p_respawn     = m_player:AddMod('Respawn') -- Better version of resetting, can fix some glitches that come w/ reanimations
    local p_tools       = m_player:AddMod('Funky tools') -- Lets you toggle multiple tools onto your character at once
    local p_tweaks      = m_player:AddMod('Game tweaks') -- Lets you force enable stuff
    
    -- Anti afk
    do 
        local p_afk_mode   = p_antiafk:AddDropdown('Anti-AFK mode', true)
        do 
            local _ = p_afk_mode:AddOption('Standard')
            :Select()
            :SetTooltip('Disables connections related to player idling. Impossible to detect, has no side-effects');
            
            p_afk_mode:AddOption('Move on idle'):SetTooltip('Automatically moves your character when the client idles')
            p_afk_mode:AddOption('Walk around'):SetTooltip('Randomly moves your character around. Useful for games with more afk checks than the default roblox ones')
        end
        
        
        local c
        local p = 'Standard'
        p_antiafk:Connect("Enabled", function() 
            if (p == 'Standard') then
                ratio(l_plr.Idled)
                return 
            end
            if (p == 'Move on idle') then
                c = l_plr.Idled:Connect(function() 
                    l_hum:MoveTo(l_humrp.Position + vec3(0, 0, 2))
                end)
                return 
            end
	    
            if (p == 'Walk around') then
                spawn(function() 
                    local base = l_humrp.Position
                    while (p_antiafk:IsEnabled()) do 
                        print(wait(mr()*8))
                        l_hum:MoveTo(base + vec3(
                            (mr()-.5)*15,
                            0,
                            (mr()-.5)*15)
                        )
                    end
                end)
                return
            end
        end)
        p_antiafk:Connect("Disabled", function()
            unratio(l_plr.Idled)
            
            if (c) then
                c:Disconnect()
                c = nil
            end
        end)
        p_afk_mode:Connect("SelectionChanged", function(v) 
            p = v
            if (p_antiafk:IsEnabled()) then
                p_antiafk:Disable()
                p_antiafk:Enable()
            end
        end)
    end
    -- Antifling
    do 
        local mode = p_antifling:AddDropdown('Method', true)
        do 
            mode:AddOption('Anchor'):Select():SetTooltip('Anchors your character when someone gets close to you, works the best but limits movement')
            mode:AddOption('Anchor (moveable)'):SetTooltip('Same as anchor but lets you move. Your characters position may not update until you unanchor')
            mode:AddOption('Noclip'):SetTooltip('Activates noclip. However, it\'s only good at stopping weak flings, and you will still be slightly pushed around')
            mode:AddOption('Teleport'):SetTooltip('Teleports you away from them. Very funny to use but you\'ll likely be flung')
        end
	
	local pcon
	p_antifling:Connect("Enabled", function() 
            local m = mode:GetSelection()
	    if (m == 'Anchor') then
		pcon = serv_rs.Heartbeat:Connect(function() 
		    for i = 1, #				
		end)
	    end
	end)
	p_antlfling:Connect("Disabled", function() 
	    if (pcon) then pcon:Disconnect() pcon = nil end		
	end)
	
	
	mode:Connect("SelectionChanged", function()
	    if (p_antifling:IsEnabled()) then
	        p_antifling:Disable()
	        p_antifling:Enable()
	    end
	end)
	
	mode:SetTooltip('The method Antifling uses.')
    end
    -- Antiwarp
    do end
    -- Autoclick
    do 
        p_autoclick:AddHotkey()
    
    end 
    -- Flashback
    do 
        local flash_delay = p_flashback:AddSlider("Delay", {min=0,max=2,cur=0,step=0.1})
        flash_delay:SetTooltip('How long to wait before teleporting you back')
        
        local fb_con
        local resp_con
        
        p_flashback:Connect("Enabled", function() 
            
            local function bind(h) 
                h.Died:Connect(function() 
                    local pos = l_humrp.CFrame
                    l_plr.CharacterAdded:Wait()
                    delay(flash_delay:GetValue(), function() l_humrp.CFrame = pos end)
                end)
            end
            
            resp_con = l_plr.CharacterAdded:Connect(function() 
                wait()
                bind(l_hum)
            end)
            
            bind(l_hum)
        end)
        p_flashback:Connect("Disabled", function() 
            fb_con:Disconnect()
            resp_con:Disconnect()
        end)
    end
    -- Respawn
    do 
        p_respawn:Connect("Enabled", function() 
            l_hum:Destroy()
        end)
    end
    
    p_among:SetTooltip('Turns you into an among us character')
    p_antiafk:SetTooltip('Prevents you from being disconnected due to idling for too long')
    p_antifling:SetTooltip('Prevents skids from flinging you, has several modes and a sensitivity option')
    p_antiwarp:SetTooltip('Prevents you from being teleported. Has options for sensitivity and check rates, as well as a lerp')
    p_autoclick:SetTooltip('Standard autoclicker')
    p_fancy:SetTooltip('Converts your chat letters into a fancier version. Has a toggleable mode and a non-toggleable mode')
    p_flashback:SetTooltip('Teleports you back after you die. Has options for delayed teleport')
    p_logs:SetTooltip('Displays logs for player joins, leaves, and messages')
    p_pathfind:SetTooltip('Pathfinder. Kinda like Baritone')
    p_radar:SetTooltip('Radar that displays where other players are')
    p_respawn:SetTooltip('Better version of ressetting, can fix some glitches with reanimations')
    p_tools:SetTooltip('Lets you equip and unequip multiple tools at once')
    p_tweaks:SetTooltip('Lets you configure various misc "forceable" settings like 3rd person, chat, inventories, and more')
end
local m_movement = ui:CreateMenu('Movement') do 
    local m_airjump   = m_movement:AddMod('Air jump') -- Lets you jump in air
    local m_blink     = m_movement:AddMod('Blink') -- Pseudo lagswitch
    local m_clicktp   = m_movement:AddMod('Click TP') -- Click TP
    local m_fastfall  = m_movement:AddMod('Fast fall') -- Quick fall, can use raycasts or bodyvelocities
    local m_flight    = m_movement:AddMod('Flight') -- Flight w/ smooth and hard
    local m_float     = m_movement:AddMod('Float') -- Float
    local m_highjump  = m_movement:AddMod('High jump') -- Jump higher
    local m_jesus     = m_movement:AddMod('Jesus') -- Walk above water
    local m_jetpack   = m_movement:AddMod('Jetpack') -- Sidegrade of flight
    local m_noclip    = m_movement:AddMod('Noclip') -- Standard noclip, comes with a few bypasses
    local m_noslow    = m_movement:AddMod('Noslowdown') -- Prevents you from being slowed down
    local m_parkour   = m_movement:AddMod('Parkour') -- Jumps when you reach the end of a block
    local m_phase     = m_movement:AddMod('Phase') -- Like TPbot, but more for movement rather than killing people
    local m_speed     = m_movement:AddMod('Speed') -- Speedhacks w/ various bypasses and settings
    local m_step      = m_movement:AddMod('Step') -- Automatically teleports you on top of parts in front of you
    local m_velocity  = m_movement:AddMod('Velocity') -- Limits velocity or disables it
    
    -- Airjump
    do 
        local mode = m_airjump:AddDropdown('Airjump mode',true)
        mode:AddOption('Jump'):SetTooltip('Normal mode. If the game has something to prevent jumps, this will not work'):Select()
        mode:AddOption('Velocity'):SetTooltip('Changes your velocity. Bypasses jump prevention, but this is not as realistic as actually jumping')
        local velmount = m_airjump:AddSlider('Velocity amount', {min=-500,max=500,cur=70})
        
        local vel = 35
        velmount:Connect("ValueChanged",function(v)vel=v;end)
        local ajcon
        
        m_airjump:Connect("Enabled", function() 
            if (mode:GetSelection() == 'Jump') then
                if gpe then return end
                ajcon = serv_uis.InputBegan:Connect(function(io, gpe) 
                    if (io.KeyCode.Value == 32) then
                        l_hum:ChangeState(3)
                    end
                end)
            else
                ajcon = serv_uis.InputBegan:Connect(function(io, gpe) 
                    if gpe then return end 
                    if (io.KeyCode.Value == 32) then
                        l_humrp.Velocity = vec3(0, vel, 0)
                    end
                end)
            end
        end)
    
        m_airjump:Connect("Disabled", function() 
            ajcon:Disconnect()
        end)
        
        mode:Connect("SelectionChanged",function() 
            if (m_airjump:IsEnabled()) then
                m_airjump:Disable() 
                m_airjump:Enable()
            end
        end)
        
        mode:SetTooltip('Mode for Airjump to use')
        velmount:SetTooltip('Amount to set your velocity to for the Velocity mode')
    end
    
    -- Speed
    do 
        local mode = m_speed:AddDropdown('Mode',true)
        mode:AddOption('Standard'):SetTooltip('Standard CFrame speed. <b>Mostly</b> undetectable, unlike other scripts such as Inf Yield. Also known as TPWalk'):Select()
        mode:AddOption('Velocity'):SetTooltip('Changes your velocity, doesn\'t use any bodymovers. Because of friction, Velocity typically won\'t increase your speed unless it\'s set high or you jump.')
        mode:AddOption('Bhop'):SetTooltip('The exact same as Velocity, but it spam jumps. Useful for looking legit in games with bhop mechanics, like Arsenal')
        mode:AddOption('Part'):SetTooltip('Pushes you physically with a clientside part. Can also affect vehicles in certain games, such as Jailbreak')
        mode:AddOption('WalkSpeed'):SetTooltip('<font color="rgb(255,64,64)"><b>Insanely easy to detect. There\'s no good reason to use this mode. Doesn\'t come with any protection. Use Standard instead.</b></font>')
        
        local speedslider = m_speed:AddSlider('Speed',{min=0,max=100,cur=50,step=0.1})
        local speed = 50
        speedslider:Connect("ValueChanged",function(v)speed=v;end)
        local part
        local scon
        
        local ev = serv_rs.Heartbeat
        
        m_speed:Connect("Enabled",function() 
            local mode = mode:GetSelection()
            
            ratio(l_hum.Changed)
            ratio(l_hum:GetPropertyChangedSignal("Jump"))
            ratio(l_humrp.Changed)
            ratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            ratio(l_humrp:GetPropertyChangedSignal("Velocity"))
            
            
            if (scon) then scon:Disconnect() scon = nil end
            
            if (mode == 'Standard') then
                scon = ev:Connect(function(dt) 
                    l_humrp.CFrame += l_hum.MoveDirection * (5 * dt * speed)
                end)
            elseif (mode == 'Velocity') then
                scon = ev:Connect(function(dt) 
                    l_humrp.Velocity += l_hum.MoveDirection * (5 * dt * speed)
                end)
            elseif (mode == 'Bhop') then
                scon = serv_rs.RenderStepped:Connect(function(dt) 
                    local md = l_hum.MoveDirection
                    
                    l_humrp.Velocity += md * (5 * dt * speed)
                    l_hum.Jump = not (md.Magnitude < 0.01 and true or false)
                end)
            elseif (mode == 'Part') then
                part = inst("Part")
                part.Transparency = 0.8
                part.Size = vec3(4,4,1)
                part.CanTouch = false
                part.CanCollide = true
                part.Anchored = false
                part.Name = getnext()
                part.Parent = workspace
                scon = ev:Connect(function(dt) 
                    local md = l_hum.MoveDirection
                    local p = l_humrp.Position
                    
                    part.CFrame = cfn(p-(md), p)
                    part.Velocity = md * (dt * speed * 1200)
                    
                    l_hum:ChangeState(8)
                end)
            elseif (mode == 'WalkSpeed') then
                scon = ev:Connect(function() 
                    l_hum.WalkSpeed = speed
                end)
            end
        end)
        
        m_speed:Connect("Disabled",function() 
            if (scon) then scon:Disconnect() scon = nil end
            if (part) then part:Destroy() end
            
            unratio(l_hum.Changed)
            unratio(l_hum:GetPropertyChangedSignal("Jump"))
            unratio(l_humrp.Changed)
            unratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            unratio(l_humrp:GetPropertyChangedSignal("Velocity"))
        end)
        
        mode:Connect("SelectionChanged",function() 
            if (m_speed:IsEnabled()) then
                m_speed:Disable()
                m_speed:Enable()
            end
        end)
        
        mode:SetTooltip('Method used for the speedhack')
        speedslider:SetTooltip('Amount of speed')
    end
    -- Noclip
    do 
        
    end
    -- Flight
    do 
        local ascend_h = m_flight:AddHotkey('Ascend key')
        local descend_h = m_flight:AddHotkey('Descend key')
        local mode = m_flight:AddDropdown('Flight Mode', true)
        local speedslider = m_flight:AddSlider('Speed',{min=0,max=300,step=0.1,cur=30})
        local camera = m_flight:AddToggle('Camera-based')
        local turndir = m_flight:AddDropdown('Turn direction')
        
        mode:AddOption('Standard'):SetTooltip('Standard CFlight. Undetectable (within reason), unlike other scripts such as Inf Yield'):Select()
        mode:AddOption('Smooth'):SetTooltip('Just like Standard, but smooth')
        mode:AddOption('Noclip'):SetTooltip('Like CFlight but you have noclip')
        mode:AddOption('Vehicle'):SetTooltip('BodyPosition CFlight, may let you fly with vehicles in some games like Jailbreak. Has more protection than other scripts, but is still more detectable than Standard')
        
        
        turndir:AddOption('XYZ'):SetTooltip('Follows the camera\'s direction exactly'):Select()
        turndir:AddOption('XZ'):SetTooltip('Follows the camera\'s direction on all axes but Y')
        turndir:AddOption('Up'):SetTooltip('Faces straight up, useful for carrying players')
        turndir:AddOption('None'):SetTooltip('Doesn\'t follow the camera\'s direction')
        
        ascend:SetTooltip('When pressed you vertically ascend (move up)'):SetHotkey(Enum.KeyCode.E)
        descend:SetTooltip('When pressed you vertically descend (move down)'):SetHotkey(Enum.KeyCode.Q)
        mode:SetTooltip('The method Flight uses')
        speed:SetTooltip('The speed of your flight')
        camera:SetTooltip('When enabled the direction your camera faces affects your Y movement. Disabling allows you to look down / up without moving downwards / upwards')
        turndir:SetTooltip('The direction your character faces')
        
        local fpart
        local fcon
        
        local clvcon
        local clv
        
        local ask
        local dsk
        
        ascend_h:Connect("HotkeySet",function(j)ask=j;end)
        descend_h:Connect("HotkeySet",function(k)dsk=k;end)
        local speed = 30
        speedslider:Connect("ValueChanged",function(v)speed=v;end)
        
        m_flight:Connect("Enabled", function()
            clv = l_cam.CFrame.LookVector 
            clvcon = l_cam:GetPropertyChangedSignal("CFrame"):Connect(function() 
                clv = l_cam.CFrame.LookVector 
            end)
            
            local curmod = mode:GetSelection()
            local curturn = turndir:GetSelection()
            
            
            if (mode == 'Standard') then
                
                if (curturn == 'XYZ') then
                    
                    fcon = serv_rs.HeartBeat:Connect(function(dt) 
                        local cf = l_humrp.Position
                        
                        local up = serv_uis:IsKeyDown()
                        
                        l_humrp.CFrame = cfn(cf, cf + clv) * cfn()
                    end)
                    
                elseif (curturn == 'XZ') then
                    
                elseif (curturn == 'Up') then
                    
                elseif (curturn == 'None') then
                    
                end
            end
        end)
        
    end
    
    
    m_airjump:SetTooltip('Lets you jump in air, may bypass jump restrictions')
    m_blink:SetTooltip('Pseudo lagswitch. Doesn\'t actually choke packets. Raknet libraries (like Celery\'s) will be supported eventually')
    m_clicktp:SetTooltip('Standard clickteleport')
    m_fastfall:SetTooltip('Makes you instantly / near instantly fall down. Useful for bypassing fall damage in games like Natural Disaster Survival')
    m_flight:SetTooltip('Standard flight, comes with a few bypasses')
    m_float:SetTooltip('Makes you float')
    m_highjump:SetTooltip('Increases how high you jump')
    m_jesus:SetTooltip('Lets you walk on non-collidable parts')
    m_jetpack:SetTooltip('Like flight but more velocity based')
    m_noclip:SetTooltip('Standard noclip, comes with a few bypasses')
    m_noslow:SetTooltip('Prevents you from being slowed down')
    m_parkour:SetTooltip('Jumps when you reach the end of a part')
    m_phase:SetTooltip('Like TPbot, but for movement rather than combat')
    m_speed:SetTooltip('Speedhacks with various bypasses and settings')
    m_step:SetTooltip('Automatically teleports you on top of parts in front of you when walked into')
    m_velocity:SetTooltip('Limits velocity or disables it')
end
local m_render = ui:CreateMenu('Render') do 
    
    local r_betterui    = m_render:AddMod('Better UI') -- Improves existing roblox uis, like the chat and inventory
    local r_bread       = m_render:AddMod('Breadcrumbs') -- Leave a trail behind 
    local r_camtweaks   = m_render:AddMod('Camera tweaks') -- Lets the camera look through blocks
    local r_crosshair   = m_render:AddMod('Crosshair') -- Crosshair configuration
    local r_esp         = m_render:AddMod('ESP') -- Player esp, part esp
    local r_freecam     = m_render:AddMod('Freecam') -- Freecam w/ smooth flight and hard flight
    local r_fullbright  = m_render:AddMod('Fullbright') -- Fullbright w/ different modes
    local r_nametag     = m_render:AddMod('Nametags') -- Better nametags
    
    
    r_betterui:SetTooltip("Improves existing Roblox UIs, like the chat and inventory")
    r_bread:SetTooltip('Leaves a trail behind')
    r_camtweaks:SetTooltip('Options for configuring the camera, like noclip-cam, maxzoom, smooth camera, etc. For 3rd person, use Game tweaks under Misc')
    r_crosshair:SetTooltip('Crosshair configuration')
    r_esp:SetTooltip('Configurable ESP')
    r_freecam:SetTooltip('Standard freecam')
	r_fullbright:SetTooltip('Fullbright with different presets for different games')
    r_nametag:SetTooltip('Better nametags')
end
local m_ui = ui:CreateMenu('UI') do 
    local u_cmd = m_ui:AddMod('Command bar')
    local u_hud = m_ui:AddMod('HUD')
    local u_jeff = m_ui:AddMod('Jeff') -- Jeff
    
    do 
        local a = u_jeff:AddToggle('Gamer mode')
        a:SetTooltip('Does something epic i think')
        
        u_jeff:Connect("Enabled", function() 
            if (mr() > 0.95) then
                l_hum.Sit = a:IsEnabled()
            end
        end)
    end
    
    
    u_cmd:SetTooltip('Redline command bar. Quickly toggle modules, do quick actions like chatting and leaving, and more')
    u_hud:SetTooltip('Redline UI configuration')
    u_jeff:SetTooltip('I forgot what this does')
end
local m_server = ui:CreateMenu('Server') do 
    local s_rejoin = m_server:AddMod('Rejoin', 'Button')
    local s_shop = m_server:AddMod('Serverhop', 'Button')
    
    s_rejoin:Connect("Clicked",function() 
        if #serv_players:GetPlayers() <= 1 then
        	l_plr:Kick("\nRejoining, one second...")
        	wait(0.3)
        	serv_tp:Teleport(game.PlaceId, l_plr)
        else
        	serv_tp:TeleportToPlaceInstance(game.PlaceId, game.JobId, l_plr)
        end
    end)
    
    s_rejoin:SetTooltip('Rejoins you into the current server. <b>Don\'t swap too many times, or you\'ll get error 268</b>')
    s_shop:SetTooltip('Server hops. <b>Don\'t hop too many times, or you\'ll get error 268</b>')
end
local m_integrations = ui:CreateMenu('Integrations') do 
    local m_alt = m_integrations:AddMod('Alt manager') -- Roblox Alt Manager stuff, requires Roblox Alt Manager (3rd party program)
    local m_rpc = m_integrations:AddMod('Discord RPC') -- Discord RPC stuff
	
    m_alt:SetTooltip('Roblox Alt Manager integration. Requires the 3rd party Roblox Alt Manager program.')
    m_rpc:SetTooltip('Discord Rich Presence integration')
end
local m_search = ui:CreateMenu('Search') do 
    local _ = m_search:AddMod('Enter module name', 'Textbox')
    _:SetTooltip('Search for a module')
    _:Connect("Unfocused", function(t, t2)
        if (not t2) then return end 
        
        local mods = ui:GetModules()
        for i = 1, #mods do 
            local mod = mods[i]
            if (mod.setvis) then mod:setvis(true, false) end
        end
    end)
    
    _:Connect("TextChanged", function(t) 
        local mods = ui:GetModules()
        for i = 1, #mods do 
            local mod = mods[i]
            if (mod.Name:lower():match(t)) then
                if (mod.setvis) then 
                    mod:setvis(true, true) 
                end
            else
                if (mod.setvis) then 
                    mod:setvis(true, false) 
                end
            end
        end
    end)
end

_G.RLLoaded = true
