--[[
⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀      ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⡿⠀⢿⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⢸⠇⠀⠸⡇⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀  ⠀  ⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⢀⡿⠀⠀⠀⢿⡀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⣶⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦
  ⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⣸⠃⠀⠀⠀⠘⣇⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⣿⠀⠴⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣶⣤⣤⡀⠀⢀⣤⣤⣤⡀⠀⢠⣤⣦⣼⡏⢀⣤⣞⠁⠀⠀⠀⠀⠀⢀⡟⠀⠀⠀⠀⠀⢻⡀⠀⠀⠀⠀⠀⠈⣳⣤⡀⠀⠀⢸⡟⠀⣦⠀⣶⣦⣦⣄⠀⠀⣠⣤⣤⡀⠀⠀⠀⠀⠀⠀⠀✦
⠀⠀⠀⠀⠀⠀⠀⢸⡏⠀⠈⠛⠀⣼⡇⠀⢹⡇⠀⣿⠁⠀⣿⡇⠈⠛⢯⡙⠛⠶⠦⣤⣄⣼⡃⠀⠀⠀⠀⠀⢘⣧⣠⣤⠴⠶⠛⢋⡽⠛⠁⠀⠀⢸⡇⢸⡏⢀⣿⠁⠀⣿⠆⢸⡏⠀⢈⣿⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⣿⠟⠛⠛⠁⢸⣏⠀⠀⣿⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⢹⡏⠛⠓⠶⠚⠛⢹⡏⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⣿⠃⢸⡇⢸⡟⠀⠀⣿⠀⢾⡟⠛⠛⠁⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠾⠃⠀⠀⠀⠀⠘⠻⠾⠿⠂⠀⠙⠿⠿⠿⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⣷⠀⠀⠀⠀⠀⣾⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠿⠀⠿⠃⠸⠇⠀⠀⠟⠀⠈⠻⠷⠿⠆⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⢸⡆⠀⠀⠀⢰⡇⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀✦⠀⠀⠀  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢶⣷⠀⠀⠀⣾⡶⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢧⣀⡼⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
]]--


--[[
★☆
]]--


---@diagnostic disable:undefined-global
---@diagnostic disable:undefined-field

if (_G.RLLoaded) then
    if (printconsole) then 
        printconsole("Already loaded Redline", 255, 64, 64)
        printconsole("Destroy the current script by pressing [End]", 192, 192, 255)
        return
    else
        warn("Already loaded Redline\nDestroy the current script by pressing [End]")
        return
    end
end

-- { The funny } --
pcall(function()
    -- Some shitter exploits error on this
    -- so im wrapping it in a pcall
    
    
    local inf = getinfo or debug.getinfo(2)
    if (inf) then
        if (inf.source ~= "redline is pretty epic") then
            warn("Looks like you're using an older version of Redline")
            warn("Check the github to get the newest script")
            return
        end
    end
end)


-- { Handle file system } --
if (not isfile('REDLINE')) then
    makefolder('REDLINE')
end

if (not isfile('REDLINE/config.json')) then
    --writefile('REDLINE/config.json', '')
end



-- { Wait for load } --
if not game:IsLoaded() then game.Loaded:Wait() end

-- { Microops } --

-- Services
local serv_ctx     = game:GetService('ContextActionService')
local serv_gui     = game:GetService('GuiService')
local serv_http    = game:GetService('HttpService')
local serv_players = game:GetService('Players')
local serv_rs      = game:GetService('RunService')
local serv_tp      = game:GetService('TeleportService')
local serv_ts      = game:GetService('TweenService')
local serv_uis     = game:GetService('UserInputService')
local serv_vim     = game:GetService("VirtualInputManager")

-- Colors
local rgb,hsv,c3n = Color3.fromRGB, Color3.fromHSV, Color3.new
-- UDim2
local dim2off, dim2sca, dim2 = UDim2.fromOffset, UDim2.fromScale, UDim2.new
-- Instances
local inst = Instance.new
-- Vectors
local vec3, vec2 = Vector3.new, Vector2.new
-- CFrames
local cfn = CFrame.new
-- Task
local wait, delay, spawn = task.wait, task.delay, task.spawn
-- Math
local mr = math.random
local mf = math.floor
local mc = math.clamp
-- Utf8
local uc = utf8.char
-- Table
local ins,rem,cle = table.insert, table.remove, table.clear
-- Os
local date = os.date
local time = tick


-- { UI Colors } --
local colors = _G.RLTHEME or {} do 
    -- generic
    colors['outline']       = rgb(075, 075, 080); -- outline color
    colors['shadow']        = rgb(005, 005, 010); -- go figure
    colors['bg']            = rgb(023, 022, 027); -- window background
    colors['enabled']       = rgb(225, 035, 035); -- enabled
    -- backgrounds
    colors['bg_header']     = rgb(035, 035, 040); -- header background
    colors['bg_object']     = rgb(030, 030, 035); -- object background
    colors['bg_setting']    = rgb(025, 025, 030); -- setting background
    colors['bg_dropdown']   = rgb(020, 020, 025); -- dropdown background
    -- backgrounds selected
    colors['bg_header-b']   = rgb(038, 038, 043); -- header hovering
    colors['bg_object-b']   = rgb(033, 033, 038); -- object hovering
    colors['bg_setting-b']  = rgb(028, 028, 033); -- setting hovering
    colors['bg_dropdown-b'] = rgb(023, 023, 028); -- dropdown hovering
    -- slider
    colors['slider_fg']     = rgb(160, 160, 165); -- slider foreground
    colors['slider_bg']     = rgb(055, 055, 060); -- slider background
    colors['slider_head']   = rgb(130, 130, 135); -- slider head
    -- text
    colors['text1']         = rgb(255, 255, 255); -- main text
    colors['text2']         = rgb(170, 170, 255); -- sub text
    colors['text3']         = rgb(020, 020, 025); -- sub text
end

-- { UI functions / variables } --
local shadow,twn,ctwn,getnext,stroke,round,uierror
do
    shadow = function(parent)
        local _ = inst('ImageLabel')
        _.BackgroundTransparency  = 1
        _.ImageTransparency       = 0.5
        _.SliceScale              = 1.3
        _.Image                   = 'rbxassetid://7603818383'
        _.AnchorPoint             = vec2(0.5,0.5)
        _.ImageColor3             = colors['shadow']
        _.Position                = dim2sca(0.5, 0.5)
        _.Size                    = dim2(1, 20, 1, 20)
        _.SliceCenter             = Rect.new(15, 15, 175, 175)
        _.ScaleType               = 'Slice'
        _.ZIndex                  = parent.ZIndex - 1 
        _.Parent                  = parent
    
        return _
    end
    stroke = function(parent,inset) 
        local _ = inst('UIStroke')
        _.ApplyStrokeMode = 'Contextual'
        _.Thickness = 1
        _.Color = colors['outline']
        _.Transparency = 0
        if (inset) then
            parent.Size -= dim2off(1,1)
        end
        
        _.Parent = parent
        return _
    end
    
    local info1, info2 = TweenInfo.new(0.1,10,1), TweenInfo.new(0.2,10,1)
    function twn(twn_target, twn_settings, twn_long) 
        local tween = serv_ts:Create(
            twn_target,
            twn_long and info2 or info1,
            twn_settings
        )
        tween:Play()
        return tween
    end
    function ctwn(twn_target, twn_settings, twn_dur) 
        local tween = serv_ts:Create(
            twn_target,
            TweenInfo.new(twn_dur,10,1),
            twn_settings
        )
        tween:Play()
        return tween
    end
    function getnext() 
        local a = ''
        for i = 1, 5 do a = a .. uc(mr(50,2000)) end 
        return a 
    end
    function round(num, place) 
        return mf(((num+(place*.5)) / place)) * place
    end
    function uierror(func, prop, type) 
        error(('%s failed; %s is not of type %s'):format(func,prop,type), 3)
    end
end




-- { UI } --
local ui = {} do 
    local W_WindowOpen = false
    
    local ui_Hotkeys = {}
    local ui_Connections = {}
    local ui_Menus = {}
    local ui_Modules = {}
    
    local rgbinsts = {}
    
    local monitor_resolution = serv_gui:GetScreenResolution()
    local monitor_inset = serv_gui:GetGuiInset()
    
    -- connections
    ui_Connections['i'] = serv_uis.InputBegan:Connect(function(io, gpe) 
        if (gpe) then return end
        if (io.UserInputType.Value == 8) then
            local kcv = io.KeyCode.Value
            for i = 1, #ui_Hotkeys do 
                local hk = ui_Hotkeys[i]
                if (hk[1] == kcv) then
                    hk[2]()
                end
            end
        end
    end)
    do
        local _ = 0
        local __ = hsv
        
        ui_Connections['r'] = serv_rs.RenderStepped:Connect(function(___) 
            _ = (_ > 1 and 0 or _)+(___*.05)
            ___ = __(_,.9,1)
            for i = 1, #rgbinsts do 
                local v = rgbinsts[i]
                v[1][v[2]] = ___
            end
        end)
    end
    
    -- Gui creation
    local w_Screen
     local w_TooltipHeader
      local w_Tooltip
    local w_Backframe
    local w_ModList
     local w_ModListLayout
     local w_ModListTitle
    
    
    do 
        w_Screen = inst('ScreenGui')
        w_Screen.IgnoreGuiInset = true
        w_Screen.ZIndexBehavior = Enum.ZIndexBehavior.Global
        w_Screen.Name = getnext()
        pcall(function() 
            --syn.protect_gui(w_Screen)
        end)
        w_Screen.DisplayOrder = 939393
        w_Screen.Parent = gethui and gethui() or get_hidden_gui and get_hidden_gui() or game.CoreGui
        
        
        w_Backframe = inst('Frame')
        w_Backframe.Size = dim2sca(1,1)
        w_Backframe.BackgroundColor3 = colors['bg']
        w_Backframe.BackgroundTransparency = 0.3
        w_Backframe.BorderSizePixel = 0
        w_Backframe.Visible = false
        w_Backframe.Parent = w_Screen
        
        local w_Icon = inst("ImageLabel")
        w_Icon.Image = "rbxassetid://8677436980"
        w_Icon.Size = dim2off(256, 256)
        w_Icon.Position = dim2off(0, -64)
        w_Icon.BackgroundTransparency = 1
        w_Icon.Parent = w_Backframe
        
        w_ModList = inst('Frame')
        w_ModList.Size = dim2(0,200,0.3,0)
        w_ModList.Position = dim2sca(0,1)
        w_ModList.AnchorPoint = vec2(0, 1)
        w_ModList.BackgroundTransparency = 1
        w_ModList.BackgroundColor3 = colors['bg']
        w_ModList.BorderSizePixel = 1
        w_ModList.BorderMode = 'Inset'
        w_ModList.BorderColor3 = colors['outline']
        w_ModList.Parent = w_Screen
        
        w_ModListLayout = inst('UIListLayout')
        w_ModListLayout.FillDirection = 'Vertical'
        w_ModListLayout.HorizontalAlignment = 'Left'
        w_ModListLayout.VerticalAlignment = 'Bottom'
        w_ModListLayout.Parent = w_ModList
        
        w_ModListTitle = inst("TextLabel")
        w_ModListTitle.Size = dim2(1, 0, 0, 30)
        w_ModListTitle.BackgroundTransparency = 1
        w_ModListTitle.Font = 'SourceSans'
        w_ModListTitle.TextColor3 = colors['enabled']
        w_ModListTitle.TextXAlignment = 'Left'
        w_ModListTitle.TextColor3 = colors['text1']
        w_ModListTitle.TextSize = 24
        w_ModListTitle.Text = " Redline"
        w_ModListTitle.LayoutOrder = 939
        w_ModListTitle.TextStrokeTransparency = 0
        w_ModListTitle.TextStrokeColor3 = colors['text3']
        w_ModListTitle.ZIndex = 5
        w_ModListTitle.Parent = w_ModList
        
        w_TooltipHeader = inst("TextLabel")
        w_TooltipHeader.BackgroundColor3 = colors['bg_header']
        w_TooltipHeader.BackgroundTransparency = 0
        w_TooltipHeader.BorderColor3 = colors['outline']
        w_TooltipHeader.BorderMode = 'Inset'
        w_TooltipHeader.BorderSizePixel = 1
        w_TooltipHeader.Font = 'SourceSans'
        w_TooltipHeader.RichText = true
        w_TooltipHeader.Size = dim2off(175,20)
        w_TooltipHeader.Text = "Hi"
        w_TooltipHeader.TextColor3 = colors['text1']
        w_TooltipHeader.TextSize = 19
        w_TooltipHeader.TextStrokeColor3 = colors['text3']
        w_TooltipHeader.TextStrokeTransparency = 0
        w_TooltipHeader.TextXAlignment = 'Center'
        w_TooltipHeader.Visible = false 
        w_TooltipHeader.ZIndex = 1500
        w_TooltipHeader.Parent = w_Screen
        
        w_Tooltip = inst("TextLabel")
        w_Tooltip.BackgroundColor3 = colors['bg']
        w_Tooltip.BackgroundTransparency = 0.2
        w_Tooltip.BorderColor3 = colors['outline']
        w_Tooltip.BorderMode = 'Inset'
        w_Tooltip.BorderSizePixel = 1
        w_Tooltip.Font = 'SourceSans'
        w_Tooltip.Position = dim2off(-1, 18)
        w_Tooltip.RichText = true
        w_Tooltip.Size = dim2off(175,25)
        w_Tooltip.Text = ""
        w_Tooltip.TextColor3 = colors['text1']
        w_Tooltip.TextSize = 17
        w_Tooltip.TextStrokeColor3 = colors['text3']
        w_Tooltip.TextStrokeTransparency = 0
        w_Tooltip.TextWrapped = true
        w_Tooltip.TextXAlignment = 'Left'
        w_Tooltip.TextYAlignment = 'Top'
        w_Tooltip.Visible = true 
        w_Tooltip.ZIndex = 1500
        w_Tooltip.Parent = w_TooltipHeader
        
        local __ = inst("UIPadding")
        __.PaddingLeft = dim2off(5, 0).X
        --__.PaddingTop = dim2off(0, 5).Y
        __.Parent = w_Tooltip
        
        w_Tooltip:GetPropertyChangedSignal("Text"):Connect(function() 
            w_Tooltip.Size = dim2off(175,25)
            local n = dim2off(0,5)
            for i = 1, 25 do 
                w_Tooltip.Size += n
                if (w_Tooltip.TextFits) then break end
            end
            
        end)
    end
    
    ui_Connections['t'] = serv_rs.RenderStepped:Connect(function() 
        local pos = serv_uis:GetMouseLocation()
        w_TooltipHeader.Position = dim2off(pos.X+15, pos.Y+15)
    end)
    
    
    local ModListEnable,ModListDisable,ModListInit,ModListModify do 
        local mods_instance = {}
        
        
        ModListEnable = function(name) 
            local b = mods_instance[name]
            
            b.Parent = w_ModList
            twn(b.P, {PaddingLeft = dim2off(8, 0).X},true)
            twn(b, {Size = dim2(1, 0, 0, 24), TextTransparency = 0, TextStrokeTransparency = 0},true)
        end
        
        ModListDisable = function(name)
            local b = mods_instance[name]
            
            twn(b.P, {PaddingLeft = dim2off(-100, 0).X},true)
            twn(b, {Size = dim2(0, 0, 0, 0), TextTransparency = 1, TextStrokeTransparency = 1},true)
        end
        
        ModListModify = function(name, new) 
            mods_instance[name].Text = new
        end
        
        ModListInit = function(name) 
            local _ = inst("TextLabel")
            _.Size = dim2(0, 0, 0, 0)
            _.BackgroundTransparency = 1
            _.Font = 'SourceSans'
            _.TextXAlignment = 'Left'
            _.TextColor3 = colors['text1']
            _.TextSize = 22
            _.Text = name
            --_.Name = name
            _.RichText = true
            _.TextTransparency = 1
            _.TextStrokeTransparency = 1
            _.TextStrokeColor3 = colors['text3']
            _.ZIndex = 5
            
            mods_instance[name] = _
            
            ins(rgbinsts, {_,"TextColor3"})
            
            
            local __ = inst("UIPadding")
            __.Name = 'P'
            __.PaddingLeft = dim2off(-100, 0).X
            __.Parent = _
        end
    end
    
    -- Base class for stuff
    local base_class = {} do 
        local s1,s2 = dim2(1,0,1,0), dim2(0,0,1,0)
        
        
        
        -- objtype_action_actiontype
        
        -- Menu funcs
        do
            base_class.menu_toggle = function(self) 
                local t = not self.MToggled
                
                self.MToggled = t
                self.Menu.Visible = t
                
                twn(self.Icon, {Rotation = t and 0 or 180}, true)
            end
                base_class.menu_getstate = function(self) 
                return self.MToggled
            end
        end
        -- Module funcs
        do
            base_class.module_toggle_menu = function(self) 
                local t = not self.MToggled
                
                self.MToggled = t
                self.Menu.Visible = t
                
                twn(self.Icon, {Rotation = t and 360 or 0}, true)
                self.Icon.Text = t and '-' or '+'
            end
            base_class.module_toggle_self = function(self) 
                local t = not self.OToggled
                self.OToggled = t
                
                
                pcall(self.Flags.Toggled, t)
                pcall(self.Flags[t and 'Enabled' or 'Disabled'])
                
                twn(self.Effect, {Size = t and s1 or s2}, true)
                
                if (t) then
                    ModListEnable(self.Name)
                else
                    ModListDisable(self.Name)
                end
                return self 
            end
            base_class.module_toggle_enable = function(self) 
                self.OToggled = true
                
                pcall(self.Flags.Toggled, true)
                pcall(self.Flags.Enabled)
                
                twn(self.Effect, {Size = s1}, true)
                
                ModListEnable(self.Name)
                return self 
            end
            base_class.module_toggle_disable = function(self) 
                self.OToggled = false
                
                pcall(self.Flags.Toggled, false)
                pcall(self.Flags.Disabled)
                
                twn(self.Effect, {Size = s2}, true)
                
                ModListDisable(self.Name)
                return self
            end
            base_class.module_getstate_self = function(self) return self.OToggled end
            base_class.module_getstate_menu = function(self) return self.MToggled end
            
            base_class.module_setvis = function(self, t, t2) 
                self.Root.Visible = t 
                self.Highlight.Visible = t2
            end 
            
            base_class.module_click_self = function(self) 
                pcall(self.Flags.Clicked)
                
                self.Effect.BackgroundTransparency = 0.8
                twn(self.Effect, {BackgroundTransparency = 1}, true)
            end
            base_class.module_gettext = function(self) 
                return self.Text
            end
            
        end
        
        -- Setting funcs
        do
            base_class.setting_toggle_self = function(self) 
                local t = not self.Toggled
                
                pcall(self.Flags.Toggled, t)
                pcall(self.Flags.Enabled)
                pcall(self.Flags.Disabled)
                
                self.Toggled = t
                twn(self.Icon, {BackgroundTransparency = t and 0 or 1})
                return self
            end 
            base_class.setting_toggle_enable = function(self) 
                self.Toggled = true
                
                pcall(self.Flags.Toggled, true)
                pcall(self.Flags.Enabled)
                
                twn(self.Icon, {BackgroundTransparency = 0})
                return self
            end 
            base_class.setting_toggle_disable = function(self) 
                self.Toggled = false
                
                pcall(self.Flags.Toggled, false)
                pcall(self.Flags.Disabled)
                
                twn(self.Icon, {BackgroundTransparency = 1})
                return self
            end 
            base_class.setting_toggle_getstate = function(self) 
                return self.Toggled
            end
            
            base_class.setting_modhotkey_sethotkey = function(self) 
                local label = self.Label
                label.Text = "Press any key..."
                
                wait(0.01);
                local c;
                c = serv_uis.InputBegan:Connect(function(io,gpe)
                    
                    local kcv = io.KeyCode.Value
                    if (kcv ~= 0) then
                        
                        self.Hotkey = kcv
                        label.Text = "Hotkey: "..io.KeyCode.Name
                        
                        -- As scuffed as this is, it works
                        -- To prevent the module being bound from immediately toggling, a short delay is made
                        delay(0.01, function()
                            local n = self.Parent.Name
                            for i = 1, #ui_Hotkeys do 
                                if ui_Hotkeys[i][3] == n then
                                    rem(ui_Hotkeys, i)
                                    break
                                end
                            end
                            ins(ui_Hotkeys, {kcv, function() 
                                self.Parent:Toggle()
                            end, n})
                        end)
                    else
                        self.Hotkey = nil    
                        label.Text = "Hotkey: N/A"
                        
                        local n = self.Parent.Name
                        for i = 1, #ui_Hotkeys do 
                            if ui_Hotkeys[i][3] == n then
                                rem(ui_Hotkeys, i)
                                break
                            end
                        end
                    end
                    c:Disconnect()
                end)
                
            end
        
            base_class.setting_modhotkey_gethotkey = function(self) 
                return self.Hotkey
            end
            
            base_class.setting_hotkey_sethotkey = function(self) 
                local label = self.Label
                label.Text = "Press any key..."
                
                wait(0.01);
                local c;
                c = serv_uis.InputBegan:Connect(function(io,gpe)
                    local kc = io.KeyCode
                    local kcv = kc.Value
                    if (kcv ~= 0) then
                        
                        self.Hotkey = kc
                        label.Text = self.Name..": "..kc.Name
                        
                        pcall(self.Flags.HotkeySet, kc, kcv)
                    else
                        self.Hotkey = nil    
                        label.Text = self.Name..": N/A"
                        
                        pcall(self.Flags.HotkeySet, nil, 0)
                    end
                    c:Disconnect()
                end)
            end
            
            base_class.setting_hotkey_sethotkeyexplicit = function(self, kc) 
                self.Hotkey = kc
                self.Label.Text = self.Name..": "..kc.Name
                return self
            end
            
            base_class.setting_hotkey_gethotkey = function(self)
                return self.Hotkey
            end
            
            
            base_class.setting_dropdown_getselection = function(self) 
                return self.Selection
            end
            
            base_class.setting_ddoption_select_self = function(self) 
                local parent = self.Parent
                
                local objs = parent.Objects
                for i = 1, #objs do objs[i]:Deselect() end
                
                self.Selected = true
                parent.Selection = self.Name
                pcall(parent.Flags.SelectionChanged, self.Name, self)
                
                if (parent.Primary) then
                    
                    local n = parent.Parent.Name 
                    ModListModify(n, n .. " <font color='#DFDFDF'>["..self.Name.."]</font>")
                end
                
                twn(self.Effect, {Size = s1}, true)
                
                return self
            end
            base_class.setting_ddoption_deselect_self = function(self) 
                if (self.Selected) then 
                    self.Selected = false
                    twn(self.Effect, {Size = s2}, true)
                end
                
                return self
            end
            base_class.setting_ddoption_selected_getstate = function(self) 
                return self.Selected
            end
            
            base_class.setting_slider_getval = function(self) return self.CurrentVal end
            base_class.setting_slider_setvalnum = function(self, nval) 
                local min = self.Min
                local cval = self.CurrentVal
                local pval = self.PreviousVal

                
                cval = round(mc(nval, min, self.Max), self.Step)
                
                if (pval ~= cval) then
                    pval = cval
                    
                    self.SliderFill.Position = dim2off(mf((cval - min) * self.Ratio), 0)
                    self.SliderAmnt.Text = self.StepFormat:format(cval)
                    
                    pcall(self.Flags.ValueChanged, cval)
                end
                
                self.CurrentVal = cval
            end
            base_class.setting_slider_setvalpos = function(self, xval) 
                local min = self.Min
                local cval = self.CurrentVal
                local pval = self.PreviousVal
                
                local pos_normalized = mc(xval - self.SliderBg.AbsolutePosition.X, 0, self.SliderSize)
                
                cval = round((pos_normalized * self.RatioInverse)+min, self.Step)
                
                if (pval ~= cval) then
                    pval = cval
                    self.SliderFill.Position = dim2off(mf((cval - min)*self.Ratio), 0)
                    self.SliderAmnt.Text = self.StepFormat:format(cval)
                    
                    self.CurrentVal = cval
                    
                    pcall(self.Flags.ValueChanged, cval)
                end
            end
        end
        
        -- Button funcs
        base_class.button_click = function(self) 
            pcall(self.Flags['Clicked'])
        end
        
        -- Slider funcs
        base_class.slider_setval = function(self, value) 
            value = tonumber(value)
            if not value then uierror('slider_setval','value','number') end
            
            local m1,m2,m3 = self.min, self.max, self.step
            value = mc(round(value, m3),m1,m2)
            
            self.setval_internal(value)
        end
        base_class.slider_getval = function(self) 
            return self.value1
        end
        
        -- Input funcs
        base_class.input_gettxt = function(self) 
            return self.Text
        end
        
        -- Generic funcs
        
        ---@param self table
        ---@param tooltip string
        ---@return table
        base_class.generic_tooltip = function(self, tooltip) 
            if (tooltip) then
                self.Tooltip = tostring(tooltip)    
            else
                self.Tooltip = nil
            end
            return self 
        end
        base_class.generic_connect = function(self, flagname, func) 
            if (type(func) ~= 'function' and type(func) ~= 'nil') then
                uierror('generic_connect','func','function or type nil')
            end
            if (type(flagname) ~= 'string') then
                uierror('generic_connect','flagname','string')
            end
            
            self.Flags[flagname] = func
            return self 
        end
        
        -- Creation functions
        base_class.menu_create_module = function(self, text, Type, nohotkey) 
            Type = Type or 'Toggle'
            local M_IndexOffset = self.ZIndex+1
            
            if (Type == 'Toggle') then 
                ModListInit(text)
                
                
                
                
                local m_ModuleRoot
                 local m_ModuleBackground
                  local m_ModuleEnableEffect
                   local m_ModuleEnableEffect2
                  local m_Highlight
                  local m_ModuleText
                  local m_ModuleIcon
                 local m_Menu
                  local m_MenuListLayout
                
                do
                    m_ModuleRoot = inst("ImageButton")
                    m_ModuleRoot.Size = dim2(1, 0, 0, 25)
                    m_ModuleRoot.AutomaticSize = "Y"
                    m_ModuleRoot.ClipsDescendants = false
                    m_ModuleRoot.BackgroundTransparency = 1
                    m_ModuleRoot.BorderSizePixel = 0
                    m_ModuleRoot.ZIndex = M_IndexOffset-1
                    m_ModuleRoot.Parent = self.Menu
                    
                     m_ModuleBackground = inst("Frame")
                     m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                     m_ModuleBackground.BorderSizePixel = 0
                     m_ModuleBackground.Size = dim2(1,0,0,25)
                     m_ModuleBackground.ZIndex = M_IndexOffset
                     m_ModuleBackground.Parent = m_ModuleRoot
                     
                      m_Highlight = inst("Frame")
                      m_Highlight.Active = false
                      m_Highlight.BackgroundColor3 = colors['enabled']
                      m_Highlight.BackgroundTransparency = 0.7
                      m_Highlight.BorderSizePixel = 0
                      m_Highlight.Size = dim2sca(1,1)
                      m_Highlight.Visible = false
                      m_Highlight.ZIndex = M_IndexOffset
                      m_Highlight.Parent = m_ModuleBackground
                      
                      m_ModuleEnableEffect = inst("Frame")
                      m_ModuleEnableEffect.BackgroundColor3 = colors['text1']
                      m_ModuleEnableEffect.BackgroundTransparency = 0.92
                      m_ModuleEnableEffect.BorderSizePixel = 0
                      m_ModuleEnableEffect.ClipsDescendants = true
                      m_ModuleEnableEffect.Size = dim2(0,0,1,0)
                      m_ModuleEnableEffect.ZIndex = M_IndexOffset
                      m_ModuleEnableEffect.Parent = m_ModuleBackground
                      
                       m_ModuleEnableEffect2 = inst("Frame")
                       m_ModuleEnableEffect2.BackgroundColor3 = colors['enabled']
                       m_ModuleEnableEffect2.BorderSizePixel = 0
                       m_ModuleEnableEffect2.Size = dim2(0,2,1,0)
                       m_ModuleEnableEffect2.ZIndex = M_IndexOffset
                       m_ModuleEnableEffect2.Parent = m_ModuleEnableEffect
                      
                      m_ModuleText = inst('TextLabel')
                      m_ModuleText.BackgroundTransparency = 1
                      m_ModuleText.Font = 'SourceSans'
                      m_ModuleText.Position = dim2off(5, 0)
                      m_ModuleText.RichText = true
                      m_ModuleText.Size = dim2(1, -5, 1, 0)
                      m_ModuleText.Text = text
                      m_ModuleText.TextColor3 = colors['text1']
                      m_ModuleText.TextSize = 20
                      m_ModuleText.TextStrokeColor3 = colors['text3']
                      m_ModuleText.TextStrokeTransparency = 0
                      m_ModuleText.TextXAlignment = 'Left'
                      m_ModuleText.ZIndex = M_IndexOffset
                      m_ModuleText.Parent = m_ModuleBackground
                      
                      m_ModuleIcon = inst('TextLabel')
                      m_ModuleIcon.AnchorPoint = vec2(1,0)
                      m_ModuleIcon.BackgroundTransparency = 1
                      m_ModuleIcon.Font = 'SourceSans'
                      m_ModuleIcon.Position = dim2sca(1,0)
                      m_ModuleIcon.Rotation = 0
                      m_ModuleIcon.Size = dim2off(25, 25)
                      m_ModuleIcon.Text = '+'
                      m_ModuleIcon.TextColor3 = colors['text1']
                      m_ModuleIcon.TextSize = 18
                      m_ModuleIcon.TextStrokeColor3 = colors['text3']
                      m_ModuleIcon.TextStrokeTransparency = 0
                      m_ModuleIcon.TextXAlignment = 'Center'
                      m_ModuleIcon.ZIndex = M_IndexOffset
                      m_ModuleIcon.Parent = m_ModuleBackground
                    
                    m_Menu = inst('Frame')
                    m_Menu.Size = dim2(1,0,0,0)
                    m_Menu.Position = dim2off(0,25)
                    m_Menu.BackgroundColor3 = colors['bg_setting']
                    m_Menu.BorderSizePixel = 0
                    m_Menu.ZIndex = M_IndexOffset-1
                    m_Menu.Visible = false
                    m_Menu.Parent = m_ModuleRoot
                    
                     m_MenuListLayout = inst('UIListLayout')
                     m_MenuListLayout.FillDirection = 'Vertical'
                     m_MenuListLayout.SortOrder = 2
                     m_MenuListLayout.HorizontalAlignment = 'Left'
                     m_MenuListLayout.VerticalAlignment = 'Top'
                     m_MenuListLayout.Parent = m_Menu
                     
                end
                    
                local M_Object = {} do 
                    M_Object.Tooltip = nil
                    
                    M_Object.MToggled = false
                    M_Object.OToggled = false
                    
                    M_Object.Flags = {} do 
                        M_Object.Flags['Enabled'] = true
                        M_Object.Flags['Disabled'] = true
                        M_Object.Flags['Toggled'] = true
                    end
                    
                    M_Object.Name = text
                    M_Object.Menu = m_Menu
                    M_Object.Icon = m_ModuleIcon
                    M_Object.Effect = m_ModuleEnableEffect
                    M_Object.ZIndex = M_IndexOffset
                    
                    M_Object.Highlight = m_Highlight
                    
                    M_Object.Parent = self
                    M_Object.Root = m_ModuleRoot
                    
                    M_Object.AddToggle = base_class.module_create_toggle
                    M_Object.AddDropdown = base_class.module_create_dropdown
                    M_Object.AddModHotkey = base_class.module_create_modhotkey
                    M_Object.AddHotkey = base_class.module_create_hotkey
                    M_Object.AddSlider = base_class.module_create_slider
                    M_Object.AddInput = base_class.module_create_input
                    M_Object.AddButton = base_class.module_create_button
                    
                    M_Object.setvis = base_class.module_setvis
                    
                    M_Object.Toggle = base_class.module_toggle_self
                    M_Object.Disable = base_class.module_toggle_disable
                    M_Object.Enable = base_class.module_toggle_enable
                    
                    M_Object.ToggleMenu = base_class.module_toggle_menu
                    M_Object.GetState = base_class.module_getstate_self
                    M_Object.IsEnabled = base_class.module_getstate_self
                    M_Object.GetMenuState = base_class.module_getstate_menu
                    
                    M_Object.Connect = base_class.generic_connect
                    M_Object.SetTooltip = base_class.generic_tooltip
                end
                
                do
                    m_ModuleBackground.InputBegan:Connect(function(io) 
                        local uitv = io.UserInputType.Value
                        if (uitv == 0) then
                            M_Object:Toggle()
                            return
                        end
                        
                        if (uitv == 1) then
                            M_Object:ToggleMenu()
                            return
                        end
                    end)
                    
                    m_ModuleBackground.MouseEnter:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object-b']
                        
                        
                        local tt = M_Object.Tooltip
                        if (tt) then
                            w_Tooltip.Text = tt
                            w_TooltipHeader.Text = M_Object.Name
                            w_TooltipHeader.Visible = true
                        end
                    end)
                    
                    m_ModuleBackground.MouseLeave:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                        
                        if (w_Tooltip.Text == M_Object.Tooltip) then
                            w_TooltipHeader.Visible = false
                        end
                    end)
                end
                
                if (not nohotkey) then M_Object:AddModHotkey() end
                
                ins(ui_Modules, M_Object)
                return M_Object
            elseif (Type == 'Textbox') then
                local m_ModuleRoot
                 local m_ModuleBackground
                 local m_ModuleEnableEffect
                  local m_ModuleText
                   local m_ModulePadding
                  local m_ModuleIcon

                do
                    m_ModuleRoot = inst("Frame")
                    m_ModuleRoot.Size = dim2(1, 0, 0, 25)
                    m_ModuleRoot.AutomaticSize = "Y"
                    m_ModuleRoot.BackgroundTransparency = 1
                    m_ModuleRoot.BorderSizePixel = 0
                    m_ModuleRoot.ZIndex = M_IndexOffset-1
                    m_ModuleRoot.Parent = self.Menu
                    
                     m_ModuleBackground = inst("Frame")
                     m_ModuleBackground.Size = dim2(1,0,0,25)
                     m_ModuleBackground.BorderSizePixel = 0
                     m_ModuleBackground.ZIndex = M_IndexOffset
                     m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                     m_ModuleBackground.Parent = m_ModuleRoot
                     
                      m_ModuleEnableEffect = inst("Frame")
                      m_ModuleEnableEffect.BackgroundColor3 = colors['text1']
                      m_ModuleEnableEffect.BackgroundTransparency = 1
                      m_ModuleEnableEffect.ClipsDescendants = true
                      m_ModuleEnableEffect.Size = dim2(1,0,1,0)
                      m_ModuleEnableEffect.BorderSizePixel = 0
                      m_ModuleEnableEffect.ZIndex = M_IndexOffset
                      m_ModuleEnableEffect.Parent = m_ModuleBackground
                     
                     m_ModuleText = inst('TextBox')
                     m_ModuleText.Size = dim2(1, 0, 1, 0)
                     m_ModuleText.Position = dim2off(0, 0)
                     m_ModuleText.ClearTextOnFocus = true
                     m_ModuleText.TextWrapped = true
                     m_ModuleText.BackgroundTransparency = 1
                     m_ModuleText.Font = 'SourceSans'
                     m_ModuleText.TextXAlignment = 'Left'
                     m_ModuleText.TextColor3 = colors['text1']
                     m_ModuleText.TextSize = 20
                     m_ModuleText.Text = text
                     m_ModuleText.TextStrokeTransparency = 0
                     m_ModuleText.TextStrokeColor3 = colors['text3']
                     m_ModuleText.ZIndex = M_IndexOffset
                     m_ModuleText.Parent = m_ModuleBackground
                      
                      m_ModulePadding = inst("UIPadding")
                      m_ModulePadding.PaddingLeft = dim2off(5, 0).X
                      m_ModulePadding.Parent = m_ModuleText
                     
                     m_ModuleIcon = inst('TextLabel')
                     m_ModuleIcon.Size = dim2off(25, 25)
                     m_ModuleIcon.Position = dim2sca(1,0)
                     m_ModuleIcon.AnchorPoint = vec2(1,0)
                     m_ModuleIcon.BackgroundTransparency = 1
                     m_ModuleIcon.Font = 'SourceSans'
                     m_ModuleIcon.TextXAlignment = 'Center'
                     m_ModuleIcon.TextColor3 = colors['text1']
                     m_ModuleIcon.TextSize = 18
                     m_ModuleIcon.Text = '🅃'
                     m_ModuleIcon.TextStrokeTransparency = 0
                     m_ModuleIcon.TextStrokeColor3 = colors['text3']
                     m_ModuleIcon.Rotation = 0
                     m_ModuleIcon.ZIndex = M_IndexOffset
                     m_ModuleIcon.Parent = m_ModuleBackground
                end
                    
                local M_Object = {} do 
                    M_Object.Tooltip = nil
                    
                    
                    M_Object.Flags = {} do 
                        M_Object.Flags['Focused'] = true
                        M_Object.Flags['Unfocused'] = true
                        M_Object.Flags['TextChanged'] = true
                    end
                    
                    M_Object.Effect = m_ModuleEnableEffect
                    
                    M_Object.Name = text
                    M_Object.ZIndex = M_IndexOffset
                                        
                    M_Object.Connect = base_class.generic_connect
                    M_Object.SetTooltip = base_class.generic_tooltip
                end
                
                do
                    m_ModuleBackground.MouseEnter:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object-b']
                        
                        
                        local tt = M_Object.Tooltip
                        if (tt) then
                            w_Tooltip.Text = tt
                            w_TooltipHeader.Text = M_Object.Name
                            w_TooltipHeader.Visible = true
                        end
                    end)
                    
                    m_ModuleBackground.MouseLeave:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                        
                        if (w_Tooltip.Text == M_Object.Tooltip) then
                            w_TooltipHeader.Visible = false
                        end
                    end)
                    
                    m_ModuleText.FocusLost:Connect(function(enter) 
                        pcall(M_Object.Flags.Unfocused, m_ModuleText.Text, enter)
                        m_ModuleText.Text = M_Object.Name
                    end)
                    m_ModuleText.Focused:Connect(function() 
                        pcall(M_Object.Flags.Focused)
                    end)
                    m_ModuleText:GetPropertyChangedSignal("Text"):Connect(function() 
                        pcall(M_Object.Flags.TextChanged, m_ModuleText.Text)
                    end)
                end
                
                ins(ui_Modules, M_Object)
                return M_Object
            elseif (Type == 'Button') then
                local m_ModuleRoot
                 local m_ModuleBackground
                  local m_Highlight
                  local m_ModuleEnableEffect
                  local m_ModuleText
                  local m_ModuleIcon

                do
                    m_ModuleRoot = inst("Frame")
                    m_ModuleRoot.Size = dim2(1, 0, 0, 25)
                    m_ModuleRoot.AutomaticSize = "Y"
                    m_ModuleRoot.BackgroundTransparency = 1
                    m_ModuleRoot.BorderSizePixel = 0
                    m_ModuleRoot.ZIndex = M_IndexOffset-1
                    m_ModuleRoot.Parent = self.Menu
                    
                     m_ModuleBackground = inst("Frame")
                     m_ModuleBackground.Size = dim2(1,0,0,25)
                     m_ModuleBackground.BorderSizePixel = 0
                     m_ModuleBackground.ZIndex = M_IndexOffset
                     m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                     m_ModuleBackground.Parent = m_ModuleRoot
                     
                     
                      m_ModuleEnableEffect = inst("Frame")
                      m_ModuleEnableEffect.BackgroundColor3 = colors['text1']
                      m_ModuleEnableEffect.BackgroundTransparency = 1
                      m_ModuleEnableEffect.ClipsDescendants = true
                      m_ModuleEnableEffect.Size = dim2(1,0,1,0)
                      m_ModuleEnableEffect.BorderSizePixel = 0
                      m_ModuleEnableEffect.ZIndex = M_IndexOffset
                      m_ModuleEnableEffect.Parent = m_ModuleBackground
                      
                      m_Highlight = inst("Frame")
                      m_Highlight.Size = dim2sca(1,1)
                      m_Highlight.BackgroundColor3 = colors['enabled']
                      m_Highlight.BackgroundTransparency = 0.7
                      m_Highlight.Visible = false
                      m_Highlight.ZIndex = M_IndexOffset
                      m_Highlight.BorderSizePixel = 0
                      m_Highlight.Parent = m_ModuleBackground
                     
                     m_ModuleText = inst('TextLabel')
                     m_ModuleText.BackgroundTransparency = 1
                     m_ModuleText.Font = 'SourceSans'
                     m_ModuleText.Position = dim2off(5, 0)
                     m_ModuleText.RichText = true
                     m_ModuleText.Size = dim2(1, -5, 1, 0)
                     m_ModuleText.Text = text
                     m_ModuleText.TextColor3 = colors['text1']
                     m_ModuleText.TextSize = 20
                     m_ModuleText.TextStrokeColor3 = colors['text3']
                     m_ModuleText.TextStrokeTransparency = 0
                     m_ModuleText.TextXAlignment = 'Left'
                     m_ModuleText.ZIndex = M_IndexOffset
                     m_ModuleText.Parent = m_ModuleBackground
                     
                     m_ModuleIcon = inst('TextLabel')
                     m_ModuleIcon.Size = dim2off(25, 25)
                     m_ModuleIcon.Position = dim2sca(1,0)
                     m_ModuleIcon.AnchorPoint = vec2(1,0)
                     m_ModuleIcon.BackgroundTransparency = 1
                     m_ModuleIcon.Font = 'SourceSans'
                     m_ModuleIcon.TextXAlignment = 'Center'
                     m_ModuleIcon.TextColor3 = colors['text1']
                     m_ModuleIcon.TextSize = 18
                     m_ModuleIcon.Text = '⦿'
                     m_ModuleIcon.TextStrokeTransparency = 0
                     m_ModuleIcon.TextStrokeColor3 = colors['text3']
                     m_ModuleIcon.Rotation = 0
                     m_ModuleIcon.ZIndex = M_IndexOffset
                     m_ModuleIcon.Parent = m_ModuleBackground
                end
                    
                local M_Object = {} do 
                    M_Object.Tooltip = nil
                    
                    
                    M_Object.Flags = {} do 
                        M_Object.Flags['Clicked'] = true
                    end
                    
                    M_Object.setvis = base_class.module_setvis
                    M_Object.Root = m_ModuleRoot
                    
                    M_Object.Highlight = m_Highlight
                    
                    
                    M_Object.Effect = m_ModuleEnableEffect
                    
                    M_Object.Name = text
                    M_Object.ZIndex = M_IndexOffset
                    
                    M_Object.Click = base_class.module_click_self
                    
                    M_Object.Connect = base_class.generic_connect
                    M_Object.SetTooltip = base_class.generic_tooltip
                end
                
                do
                    m_ModuleBackground.InputBegan:Connect(function(io) 
                        local uitv = io.UserInputType.Value
                        if (uitv == 0) then
                            M_Object:Click()
                            return
                        end
                    end)
                    
                    m_ModuleBackground.MouseEnter:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object-b']
                        
                        
                        local tt = M_Object.Tooltip
                        if (tt) then
                            w_Tooltip.Text = tt
                            w_TooltipHeader.Text = M_Object.Name
                            w_TooltipHeader.Visible = true
                        end
                    end)
                    
                    m_ModuleBackground.MouseLeave:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                        
                        if (w_Tooltip.Text == M_Object.Tooltip) then
                            w_TooltipHeader.Visible = false
                        end
                    end)
                end
                
                ins(ui_Modules, M_Object)
                return M_Object
            end
        end
        base_class.module_create_toggle = function(self, text) 
            text = tostring(text)
            
            local T_IndexOffset = self.ZIndex+1
            
            
            local t_Toggle
             local t_Box1
              local t_Box2
             local t_Text
            
            do
                t_Toggle = inst("Frame")
                t_Toggle.Size = dim2(1, 0, 0, 25)
                t_Toggle.BackgroundColor3 = colors['bg_setting']
                t_Toggle.BorderSizePixel = 0
                t_Toggle.ZIndex = T_IndexOffset
                t_Toggle.Parent = self.Menu
                 
                 t_Text = inst('TextLabel')
                 t_Text.Size = dim2(1, -10, 1, 0)
                 t_Text.Position = dim2off(10, 0)
                 t_Text.BackgroundTransparency = 1
                 t_Text.Font = 'SourceSans'
                 t_Text.TextXAlignment = 'Left'
                 t_Text.TextColor3 = colors['text1']
                 t_Text.TextSize = 18
                 t_Text.Text = text
                 t_Text.TextStrokeTransparency = 0
                 t_Text.TextStrokeColor3 = colors['text3']
                 t_Text.ZIndex = T_IndexOffset
                 t_Text.Parent = t_Toggle
                 
                 t_Box1 = inst('Frame')
                 t_Box1.Size = dim2off(10, 10)
                 t_Box1.Position = dim2(1,-5,0.5,-5)
                 t_Box1.AnchorPoint = vec2(1,0)
                 t_Box1.BackgroundTransparency = 0
                 t_Box1.BackgroundColor3 = colors['slider_bg']
                 t_Box1.BorderSizePixel = 0
                 t_Box1.ZIndex = T_IndexOffset
                 t_Box1.Parent = t_Toggle
                 
                 stroke(t_Box1)
                 
                 t_Box2 = inst('Frame')
                 t_Box2.Size = dim2off(8, 8)
                 t_Box2.Position = dim2off(1,1)
                 t_Box2.BackgroundTransparency = 1
                 t_Box2.BackgroundColor3 = colors['enabled']
                 t_Box2.BorderSizePixel = 0
                 t_Box2.Visible = true
                 t_Box2.ZIndex = T_IndexOffset
                 t_Box2.Parent = t_Box1
            end
                
            local T_Object = {} do 
                T_Object.Tooltip = nil
                T_Object.Toggled = false
                
                T_Object.Flags = {}
                T_Object.Flags['Enabled'] = true
                T_Object.Flags['Disabled'] = true
                T_Object.Flags['Toggled'] = true
                
                T_Object.Icon = t_Box2
                T_Object.Name = text
                
                T_Object.Toggle = base_class.setting_toggle_self
                T_Object.Disable = base_class.setting_toggle_disable
                T_Object.Enable = base_class.setting_toggle_enable
                T_Object.GetState = base_class.setting_toggle_getstate
                T_Object.IsEnabled = base_class.setting_toggle_getstate
                
                T_Object.Connect = base_class.generic_connect
                T_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                t_Toggle.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        T_Object:Toggle()
                        return
                    end
                end)
                
                t_Toggle.MouseEnter:Connect(function() 
                    t_Toggle.BackgroundColor3 = colors['bg_setting-b']
                    
                    local tt = T_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = T_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                t_Toggle.MouseLeave:Connect(function() 
                    t_Toggle.BackgroundColor3 = colors['bg_setting']
                    
                    if (w_Tooltip.Text == T_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            return T_Object            
        end
        base_class.module_create_dropdown = function(self, text, primary) 
            text = tostring(text)
            primary = primary or false
            
            local D_IndexOffset = self.ZIndex+1
            
            local d_Root
             local d_Header
              local d_HeaderText
              local d_HeaderIcon
              
              local d_Menu
               local d_MenuListLayout
            
            do
                d_Root = inst("Frame")
                d_Root.Size = dim2(1, 0, 0, 25)
                d_Root.AutomaticSize = "Y"
                d_Root.BackgroundTransparency = 1
                d_Root.BorderSizePixel = 0
                d_Root.ZIndex = D_IndexOffset-1
                d_Root.Parent = self.Menu
            
                 d_Header = inst('Frame')
                 d_Header.BackgroundColor3 = colors['bg_setting']
                 d_Header.Size = dim2(1, 0, 0, 25)
                 d_Header.Active = true
                 d_Header.BorderSizePixel = 0
                 d_Header.ZIndex = D_IndexOffset+1
                 d_Header.Parent = d_Root
                 
                  d_HeaderText = inst('TextLabel')
                  d_HeaderText.Size = dim2(1, -10, 1, 0)
                  d_HeaderText.Position = dim2off(10, 0)
                  d_HeaderText.BackgroundTransparency = 1
                  d_HeaderText.Font = 'SourceSans'
                  d_HeaderText.TextXAlignment = 'Left'
                  d_HeaderText.TextColor3 = colors['text1']
                  d_HeaderText.TextSize = 18
                  d_HeaderText.Text = text
                  d_HeaderText.TextStrokeTransparency = 0
                  d_HeaderText.TextStrokeColor3 = colors['text3']
                  d_HeaderText.ZIndex = D_IndexOffset+1
                  d_HeaderText.Parent = d_Header
                  
                  d_HeaderIcon = inst('ImageLabel')
                  d_HeaderIcon.Size = dim2off(25, 25)
                  d_HeaderIcon.Position = dim2sca(1,0)
                  d_HeaderIcon.AnchorPoint = vec2(1,0)
                  d_HeaderIcon.BackgroundTransparency = 1
                  d_HeaderIcon.ImageColor3 = colors['text1']
                  d_HeaderIcon.Image = 'rbxassetid://7184113125'
                  d_HeaderIcon.Rotation = 180
                  d_HeaderIcon.ZIndex = D_IndexOffset+1
                  d_HeaderIcon.Parent = d_Header
                 
                 d_Menu = inst('Frame')
                 d_Menu.Size = dim2(1,0,0,0)
                 d_Menu.AutomaticSize = "Y"
                 d_Menu.Position = dim2off(0, 25)
                 d_Menu.BackgroundColor3 = colors['bg_dropdown']
                 d_Menu.BorderSizePixel = 0
                 d_Menu.ZIndex = D_IndexOffset
                 d_Menu.Visible = false
                 d_Menu.Parent = d_Header
                 
                  d_MenuListLayout = inst('UIListLayout')
                  d_MenuListLayout.FillDirection = 'Vertical'
                  d_MenuListLayout.HorizontalAlignment = 'Left'
                  d_MenuListLayout.VerticalAlignment = 'Top'
                  d_MenuListLayout.Parent = d_Menu
            end
            
            local D_Object = {} do 
                D_Object.Tooltip = nil
                D_Object.MToggled = false
                
                D_Object.Primary = primary
                
                D_Object.Menu = d_Menu
                D_Object.Name = text
                D_Object.Parent = self
                D_Object.Icon = d_HeaderIcon
                D_Object.ZIndex = D_IndexOffset
                
                D_Object.Selection = nil
                
                D_Object.Objects = {}
                
                
                D_Object.Flags = {}
                D_Object.Flags['SelectionChanged'] = true
                
                D_Object.Toggle = base_class.menu_toggle
                D_Object.GetSelection = base_class.setting_dropdown_getselection
                
                D_Object.Connect = base_class.generic_connect
                D_Object.SetTooltip = base_class.generic_tooltip
                D_Object.AddOption = base_class.dropdown_create_option
            end
            
            do
                d_Header.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0 or uitv == 1) then
                        D_Object:Toggle()
                        return
                    end
                end)
                
                d_Header.MouseEnter:Connect(function() 
                    d_Header.BackgroundColor3 = colors['bg_setting-b']
                    
                    local tt = D_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = D_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                d_Header.MouseLeave:Connect(function() 
                    d_Header.BackgroundColor3 = colors['bg_setting']
                    
                    if (w_Tooltip.Text == D_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            return D_Object
        end
        base_class.module_create_modhotkey = function(self) 
            local H_IndexOffset = self.ZIndex+1
            
            local h_Hotkey
             local h_Text
            
            do
                h_Hotkey = inst("Frame")
                h_Hotkey.Size = dim2(1, 0, 0, 25)
                h_Hotkey.BackgroundColor3 = colors['bg_setting']
                h_Hotkey.BorderSizePixel = 0
                h_Hotkey.ZIndex = H_IndexOffset
                h_Hotkey.Parent = self.Menu
                 
                 h_Text = inst('TextLabel')
                 h_Text.Size = dim2(1, -10, 1, 0)
                 h_Text.Position = dim2off(10, 0)
                 h_Text.BackgroundTransparency = 1
                 h_Text.Font = 'SourceSans'
                 h_Text.TextXAlignment = 'Left'
                 h_Text.TextColor3 = colors['text1']
                 h_Text.TextSize = 18
                 h_Text.Text = 'Hotkey: N/A'
                 h_Text.TextStrokeTransparency = 0
                 h_Text.TextStrokeColor3 = colors['text3']
                 h_Text.ZIndex = H_IndexOffset
                 h_Text.Parent = h_Hotkey
            end
                
            local H_Object = {} do 
                H_Object.Label = h_Text
                H_Object.Hotkey = nil
                
                H_Object.Parent = self
                H_Object.Tooltip = nil
                
                H_Object.Flags = {}
                H_Object.Flags['HotkeySet'] = true
                
                H_Object.SetHotkey = base_class.setting_modhotkey_sethotkey
                H_Object.GetHotkey = base_class.setting_modhotkey_gethotkey
                
                H_Object.Connect = base_class.generic_connect
                H_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                h_Hotkey.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        H_Object:SetHotkey()
                        return
                    end
                end)
                
                h_Hotkey.MouseEnter:Connect(function() 
                    h_Hotkey.BackgroundColor3 = colors['bg_setting-b']
                end)
                
                h_Hotkey.MouseLeave:Connect(function() 
                    h_Hotkey.BackgroundColor3 = colors['bg_setting']
                end)
            end
            
            return H_Object   
        end
        base_class.module_create_hotkey = function(self, text) 
            local H_IndexOffset = self.ZIndex+1
            
            local h_Hotkey
             local h_Text
            
            do
                h_Hotkey = inst("Frame")
                h_Hotkey.Size = dim2(1, 0, 0, 25)
                h_Hotkey.BackgroundColor3 = colors['bg_setting']
                h_Hotkey.BorderSizePixel = 0
                h_Hotkey.ZIndex = H_IndexOffset
                h_Hotkey.Parent = self.Menu
                 
                 h_Text = inst('TextLabel')
                 h_Text.Size = dim2(1, -10, 1, 0)
                 h_Text.Position = dim2off(10, 0)
                 h_Text.BackgroundTransparency = 1
                 h_Text.Font = 'SourceSans'
                 h_Text.TextXAlignment = 'Left'
                 h_Text.TextColor3 = colors['text1']
                 h_Text.TextSize = 18
                 h_Text.Text = tostring(text)..': N/A'
                 h_Text.TextStrokeTransparency = 0
                 h_Text.TextStrokeColor3 = colors['text3']
                 h_Text.ZIndex = H_IndexOffset
                 h_Text.Parent = h_Hotkey
            end
                
            local H_Object = {} do 
                H_Object.Label = h_Text
                H_Object.Hotkey = nil
                
                H_Object.Parent = self
                H_Object.Tooltip = nil
                
                H_Object.Name = tostring(text)
                H_Object.Flags = {}
                H_Object.Flags['HotkeySet'] = true
                
                H_Object.bind = base_class.setting_hotkey_sethotkey
                H_Object.SetHotkey = base_class.setting_hotkey_sethotkeyexplicit
                H_Object.GetHotkey = base_class.setting_hotkey_gethotkey
                
                H_Object.Connect = base_class.generic_connect
                H_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                h_Hotkey.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        H_Object:bind()
                        return
                    end
                end)
                
                h_Hotkey.MouseEnter:Connect(function() 
                    h_Hotkey.BackgroundColor3 = colors['bg_setting-b']
                    
                    local tt = H_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = H_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                h_Hotkey.MouseLeave:Connect(function() 
                    h_Hotkey.BackgroundColor3 = colors['bg_setting']
                    
                    if (w_Tooltip.Text == H_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            return H_Object   
        end
        base_class.module_create_slider = function(self, text, args) 
            text = tostring(text)
            
            args['min'] = args['min'] or 0
            args['max'] = args['max'] or 100
            args['cur'] = args['cur'] or args['min']
            args['step'] = args['step'] or 1
            
            
            if (tostring(args['step']):match("e%-")) then
                error(("%s failed; %s was too %s"):format('module_create_slider', 'args.step', 'small'))
            end
            if (tostring(args['step']):match("e%+")) then 
                error(("%s failed; %s was too %s"):format('module_create_slider', 'args.step', 'large'))
            end
            
            local S_IndexOffset = self.ZIndex+1
            
            local s_Slider
             local s_Text
              local s_TextPad
             local s_Amount
             local s_SliderBarBg
              local s_SliderBar
              
            do
                s_Slider = inst("Frame")
                s_Slider.Size = dim2(1, 0, 0, 25)
                s_Slider.BackgroundColor3 = colors['bg_setting']
                s_Slider.BorderSizePixel = 0
                s_Slider.ZIndex = S_IndexOffset
                s_Slider.Parent = self.Menu
                 
                 s_Text = inst('TextLabel')
                 s_Text.Size = dim2sca(1, 1)
                 s_Text.Position = dim2off(0, 0)
                 s_Text.BackgroundTransparency = 0.6
                 s_Text.BorderSizePixel = 0
                 s_Text.BackgroundColor3 = colors['bg_setting']
                 s_Text.Font = 'SourceSans'
                 s_Text.TextXAlignment = 'Left'
                 s_Text.TextColor3 = colors['text1']
                 s_Text.TextSize = 18
                 s_Text.Text = text
                 s_Text.Visible = true
                 s_Text.TextStrokeTransparency = 0
                 s_Text.TextStrokeColor3 = colors['text3']
                 s_Text.ZIndex = S_IndexOffset + 1
                 s_Text.Parent = s_Slider
                  
                  s_TextPad = inst("UIPadding")
                  s_TextPad.PaddingLeft = dim2off(10, 0).X
                  s_TextPad.Parent = s_Text 
                 
                 s_Amount = inst('TextLabel')
                 s_Amount.Size = dim2(0, 30, 1, 0)
                 s_Amount.Position = dim2(1,-5,0,0)
                 s_Amount.AnchorPoint = vec2(1,0)
                 s_Amount.BackgroundTransparency = 1
                 s_Amount.BorderSizePixel = 0
                 s_Amount.Font = 'SourceSans'
                 s_Amount.TextXAlignment = 'Center'
                 s_Amount.TextColor3 = colors['text1']
                 s_Amount.TextSize = 18
                 s_Amount.Visible = true
                 s_Amount.TextStrokeTransparency = 0
                 s_Amount.TextStrokeColor3 = colors['text3']
                 s_Amount.ZIndex = S_IndexOffset + 1 
                 s_Amount.Parent = s_Slider
                 
                 s_SliderBarBg = inst("Frame")
                 s_SliderBarBg.Size = dim2(1, -16, 0, 6)
                 s_SliderBarBg.Position = dim2(0, 8, 0.5, -3)
                 s_SliderBarBg.BackgroundColor3 = colors['slider_bg']
                 s_SliderBarBg.BorderSizePixel = 0
                 s_SliderBarBg.ZIndex = S_IndexOffset
                 s_SliderBarBg.ClipsDescendants = true
                 s_SliderBarBg.Parent = s_Slider
                 
                  s_SliderBar = inst("Frame")
                  s_SliderBar.Size = dim2sca(1, 1)
                  s_SliderBar.Position = dim2(0,0)
                  s_SliderBar.AnchorPoint = vec2(0, 0)
                  s_SliderBar.BackgroundColor3 = colors['slider_fg']
                  s_SliderBar.BorderSizePixel = 0
                  s_SliderBar.ZIndex = S_IndexOffset
                  s_SliderBar.Parent = s_SliderBarBg
                 
            end
            
            local StepFormat = #(tostring(args['step']):match("%.(%d+)") or '')
            StepFormat = ("%."..StepFormat.."f")
            
            s_Amount.Text = StepFormat:format(args['cur'])
            
            
            local DragConn
                
            local S_Object = {} do 
                S_Object.Tooltip = nil
                S_Object.Name = text
                
                S_Object.SliderFill = s_SliderBar
                S_Object.SliderBg = s_SliderBarBg
                S_Object.SliderAmnt = s_Amount
                
                
                S_Object.SliderSize = s_SliderBarBg.AbsoluteSize.X
                
                S_Object.CurrentVal = args['cur']
                S_Object.PreviousVal = nil
                S_Object.Min = args['min']
                S_Object.Max = args['max']
                S_Object.Step = args['step']
                S_Object.Ratio = S_Object.SliderSize / (S_Object.Max - S_Object.Min)
                S_Object.RatioInverse = 1 / S_Object.Ratio
                S_Object.StepFormat = StepFormat
                
                
                
                
                
                S_Object.Flags = {}
                S_Object.Flags['ValueChanged'] = true
                
                S_Object.GetValue = base_class.setting_slider_getval
                S_Object.SetValue = base_class.setting_slider_setvalnum
                S_Object.SetValuePos = base_class.setting_slider_setvalpos
                
                S_Object.Connect = base_class.generic_connect
                S_Object.SetTooltip = base_class.generic_tooltip
            end
            
            S_Object:SetValue(args['cur'])
            
            do
                s_Slider.MouseEnter:Connect(function() 
                    s_Slider.BackgroundColor3 = colors['bg_setting-b']
                    
                    twn(s_Text, {BackgroundTransparency = 1, TextTransparency = 1, TextStrokeTransparency = 1},true)
                    twn(s_Amount, {Position = dim2(0.5,15,0,0)}, true)
                    
                    local tt = S_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = S_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                s_Slider.MouseLeave:Connect(function() 
                    s_Slider.BackgroundColor3 = colors['bg_setting']
                    twn(s_Text, {BackgroundTransparency = 0.2, TextTransparency = 0, TextStrokeTransparency = 0},true)
                    twn(s_Amount, {Position = dim2(1,-5,0,0)}, true)
                    
                    if (w_Tooltip.Text == S_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
                
                s_SliderBarBg.InputBegan:Connect(function(io) 
                    if (io.UserInputType.Value == 0) then
                        S_Object:SetValuePos(io.Position.X)
                        
                        DragConn = serv_uis.InputChanged:Connect(function(io) 
                            if (io.UserInputType.Value == 4) then
                                S_Object:SetValuePos(io.Position.X)
                            end
                        end)
                    end
                end)
                
                s_SliderBarBg.InputEnded:Connect(function(io) 
                    if (io.UserInputType.Value == 0) then
                        DragConn:Disconnect()
                    end
                end)
            end
            return S_Object            
        end
        base_class.module_create_input = function(self, text) 
            text = tostring(text)
            local I_IndexOffset = self.ZIndex + 1 
            
            local i_Input
             local i_Padding
             local i_Icon

            do

                
                i_Input = inst('TextBox')
                i_Input.BackgroundColor3 = colors['bg_setting']
                i_Input.BackgroundTransparency = 0
                i_Input.BorderSizePixel = 0 
                i_Input.ClearTextOnFocus = true
                i_Input.Font = 'SourceSans'
                i_Input.Position = dim2off(0, 0)
                i_Input.Size = dim2(1, 0, 0, 25)
                i_Input.Text = text
                i_Input.TextColor3 = colors['text1']
                i_Input.TextSize = 18
                i_Input.TextStrokeColor3 = colors['text3']
                i_Input.TextStrokeTransparency = 0
                i_Input.TextWrapped = true
                i_Input.TextXAlignment = 'Left'
                i_Input.ZIndex = I_IndexOffset
                i_Input.Parent = self.Menu
                 
                 i_Padding = inst("UIPadding")
                 i_Padding.PaddingLeft = dim2off(10, 0).X
                 i_Padding.Parent = i_Input
                
                i_Icon = inst('TextLabel')
                i_Icon.AnchorPoint = vec2(1,0)
                i_Icon.BackgroundTransparency = 1
                i_Icon.Font = 'SourceSans'
                i_Icon.Position = dim2sca(1,0)
                i_Icon.Rotation = 0
                i_Icon.Size = dim2off(25, 25)
                i_Icon.Text = '🅃'
                i_Icon.TextColor3 = colors['text1']
                i_Icon.TextSize = 18
                i_Icon.TextStrokeColor3 = colors['text3']
                i_Icon.TextStrokeTransparency = 0
                i_Icon.TextXAlignment = 'Center'
                i_Icon.ZIndex = I_IndexOffset
                i_Icon.Parent = i_Input
            end
                
            local I_Object = {} do 
                I_Object.Tooltip = nil
                
                
                I_Object.Flags = {} do 
                    I_Object.Flags['Focused'] = true
                    I_Object.Flags['Unfocused'] = true
                    I_Object.Flags['TextChanged'] = true
                end
                
                I_Object.Name = text
                I_Object.ZIndex = I_IndexOffset
                                
                I_Object.Connect = base_class.generic_connect
                I_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                i_Input.MouseEnter:Connect(function() 
                    i_Input.BackgroundColor3 = colors['bg_setting-b']
                    
                    
                    local tt = I_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = I_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                i_Input.MouseLeave:Connect(function() 
                    i_Input.BackgroundColor3 = colors['bg_setting']
                    
                    if (w_Tooltip.Text == I_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
                
                i_Input.FocusLost:Connect(function(enter) 
                    pcall(I_Object.Flags.Unfocused, i_Input.Text, enter)
                    i_Input.Text = I_Object.Name
                end)
                i_Input.Focused:Connect(function() 
                    pcall(I_Object.Flags.Focused)
                end)
                i_Input:GetPropertyChangedSignal("Text"):Connect(function() 
                    pcall(I_Object.Flags.TextChanged, i_Input.Text)
                end)
            end
            
            return I_Object
        end
        base_class.module_create_button = function(self, text) 
            text = tostring(text)
            
            local B_IndexOffset = self.ZIndex + 1
            
            local b_Background
             local b_EnableEffect
             local b_Text
             local b_Icon
            
            do
                b_Background = inst("Frame")
                b_Background.BackgroundColor3 = colors['bg_setting'] 
                b_Background.BorderSizePixel = 0
                b_Background.Size = dim2(1,0,0,25)
                b_Background.ZIndex = B_IndexOffset
                b_Background.Parent = self.Menu
                
                 b_EnableEffect = inst("Frame")
                 b_EnableEffect.BackgroundColor3 = colors['text1']
                 b_EnableEffect.BackgroundTransparency = 1
                 b_EnableEffect.BorderSizePixel = 0
                 b_EnableEffect.ClipsDescendants = true
                 b_EnableEffect.Size = dim2(1,0,1,0)
                 b_EnableEffect.ZIndex = B_IndexOffset
                 b_EnableEffect.Parent = b_Background
                
                 b_Text = inst('TextLabel')
                 b_Text.BackgroundTransparency = 1
                 b_Text.Font = 'SourceSans'
                 b_Text.Position = dim2off(10, 0)
                 b_Text.Size = dim2(1, -10, 1, 0)
                 b_Text.Text = text
                 b_Text.TextColor3 = colors['text1']
                 b_Text.TextSize = 18
                 b_Text.TextStrokeColor3 = colors['text3']
                 b_Text.TextStrokeTransparency = 0
                 b_Text.TextXAlignment = 'Left'
                 b_Text.ZIndex = B_IndexOffset
                 b_Text.Parent = b_Background
                 
                 b_Icon = inst('TextLabel')
                 b_Icon.AnchorPoint = vec2(1,0)
                 b_Icon.BackgroundTransparency = 1
                 b_Icon.Font = 'SourceSans'
                 b_Icon.Position = dim2sca(1,0)
                 b_Icon.Rotation = 0
                 b_Icon.Size = dim2off(25, 25)
                 b_Icon.Text = '⦿'
                 b_Icon.TextColor3 = colors['text1']
                 b_Icon.TextSize = 18
                 b_Icon.TextStrokeColor3 = colors['text3']
                 b_Icon.TextStrokeTransparency = 0
                 b_Icon.TextXAlignment = 'Center'
                 b_Icon.ZIndex = B_IndexOffset
                 b_Icon.Parent = b_Background
            end
                
            local B_Object = {} do 
                B_Object.Tooltip = nil
                
                
                B_Object.Flags = {} do 
                    B_Object.Flags['Clicked'] = true
                end
                
                B_Object.Effect = b_EnableEffect
                
                B_Object.Name = text
                B_Object.ZIndex = B_IndexOffset
                
                B_Object.Click = base_class.module_click_self
                
                B_Object.Connect = base_class.generic_connect
                B_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                b_Background.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        B_Object:Click()
                        return
                    end
                end)
                
                b_Background.MouseEnter:Connect(function() 
                    b_Background.BackgroundColor3 = colors['bg_setting-b']
                    
                    
                    local tt = B_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = B_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                b_Background.MouseLeave:Connect(function() 
                    b_Background.BackgroundColor3 = colors['bg_setting'] 
                    
                    if (w_Tooltip.Text == B_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            return B_Object
        end
        
        
        
        base_class.dropdown_create_option = function(self, text) 
            text = tostring(text)

            local O_IndexOffset = self.ZIndex + 1
            
            local o_Option
             local o_Text
             local o_EnableEffect
             local o_EnableEffect2
            
            do
                o_Option = inst("Frame")
                o_Option.Size = dim2(1, 0, 0, 25)
                o_Option.BackgroundColor3 = colors['bg_dropdown']
                o_Option.BorderSizePixel = 0
                o_Option.ZIndex = O_IndexOffset
                o_Option.Parent = self.Menu
                 
                 o_Text = inst('TextLabel')
                 o_Text.Size = dim2(1, -15, 1, 0)
                 o_Text.Position = dim2off(15, 0)
                 o_Text.BackgroundTransparency = 1
                 o_Text.Font = 'SourceSans'
                 o_Text.TextXAlignment = 'Left'
                 o_Text.TextColor3 = colors['text1']
                 o_Text.TextSize = 18
                 o_Text.Text = text
                 o_Text.TextStrokeTransparency = 0
                 o_Text.TextStrokeColor3 = colors['text3']
                 o_Text.ZIndex = O_IndexOffset
                 o_Text.Parent = o_Option
                 
                 o_EnableEffect = inst("Frame")
                 o_EnableEffect.BackgroundColor3 = colors['text1']
                 o_EnableEffect.BackgroundTransparency = 0.96
                 o_EnableEffect.ClipsDescendants = true
                 o_EnableEffect.Size = dim2(0,0,1,0)
                 o_EnableEffect.BorderSizePixel = 0
                 o_EnableEffect.ZIndex = O_IndexOffset
                 o_EnableEffect.Parent = o_Option
                 
                  o_EnableEffect2 = inst("Frame")
                  o_EnableEffect2.BackgroundColor3 = colors['enabled']
                  o_EnableEffect2.Size = dim2(0,2,1,0)
                  o_EnableEffect2.BorderSizePixel = 0
                  o_EnableEffect2.ZIndex = O_IndexOffset
                  o_EnableEffect2.Parent = o_EnableEffect
            end
                
            local O_Object = {} do 
                O_Object.Tooltip = nil
                O_Object.Selected = false
                
                O_Object.Name = text
                O_Object.Parent = self
                
                O_Object.Effect = o_EnableEffect
                
                O_Object.Select = base_class.setting_ddoption_select_self
                O_Object.Deselect = base_class.setting_ddoption_deselect_self
                
                O_Object.GetState = base_class.setting_ddoption_selected_getstate
                O_Object.IsSelected = base_class.setting_ddoption_selected_getstate
                
                O_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                o_Option.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        O_Object:Select()
                        return
                    end
                end)
                
                o_Option.MouseEnter:Connect(function() 
                    o_Option.BackgroundColor3 = colors['bg_dropdown-b']
                    
                    local tt = O_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = O_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                o_Option.MouseLeave:Connect(function() 
                    o_Option.BackgroundColor3 = colors['bg_dropdown']
                    
                    if (w_Tooltip.Text == O_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            ins(self.Objects, O_Object)
            return O_Object
        end
    end
    
    -- UI functions
    function ui:CreateMenu(text) 
        local M_Id = #ui_Menus+1
        local M_IndexOffset = M_Id * 15
        
        local m_Header
         local m_HeaderEnableEffect
         local m_HeaderText
         local m_HeaderIcon
         
         local m_Menu
          local m_MenuListLayout
        
        m_Header = inst('ImageButton')
        m_Header.BackgroundColor3 = colors['bg_header']
        m_Header.Size = dim2off(250, 30)
        m_Header.Active = true
        m_Header.ClipsDescendants = false
        m_Header.AutoButtonColor = false
        m_Header.BorderSizePixel = 0
        m_Header.Position = dim2off(
            (0.1*((M_Id-1)%6) * monitor_resolution.X)+(100*((M_Id-1)%6)+100), 
            0
        )
        
        local t_MID = M_Id
        local y = 100 
        for i=0, 100, 6 do 
            if t_MID > i then
                y += 100
            else
                break
            end
        end
        m_Header.Position += dim2off(0,y)
        
        m_Header.ZIndex = M_IndexOffset+2
        m_Header.Parent = w_Backframe
        
         m_HeaderEnableEffect = inst("Frame")
         m_HeaderEnableEffect.BackgroundColor3 = colors['enabled']
         m_HeaderEnableEffect.Size = dim2(0,0,1,0)
         m_HeaderEnableEffect.BorderSizePixel = 0
         m_HeaderEnableEffect.ZIndex = M_IndexOffset+2
         m_HeaderEnableEffect.Parent = m_Header
        
         m_HeaderText = inst('TextLabel')
         m_HeaderText.Size = dim2(1, 0, 1, 0)
         m_HeaderText.Position = dim2off(0, 0)
         m_HeaderText.BackgroundTransparency = 1
         m_HeaderText.Font = 'SourceSans'
         m_HeaderText.TextXAlignment = 'Center'
         m_HeaderText.TextColor3 = colors['text1']
         m_HeaderText.TextSize = 22
         m_HeaderText.Text = text
         m_HeaderText.TextStrokeTransparency = 0
         m_HeaderText.TextStrokeColor3 = colors['text3']
         m_HeaderText.ZIndex = M_IndexOffset+2
         m_HeaderText.Parent = m_Header
         
         m_HeaderIcon = inst('ImageLabel')
         m_HeaderIcon.Size = dim2off(30, 30)
         m_HeaderIcon.Position = dim2sca(1,0)
         m_HeaderIcon.AnchorPoint = vec2(1,0)
         m_HeaderIcon.BackgroundTransparency = 1
         m_HeaderIcon.ImageColor3 = colors['text1']
         m_HeaderIcon.Image = 'rbxassetid://7184113125'
         m_HeaderIcon.Rotation = 180
         m_HeaderIcon.ZIndex = M_IndexOffset+2
         m_HeaderIcon.Parent = m_Header
        
        m_Menu = inst('Frame')
        m_Menu.Size = dim2(1,0,0,0)
        m_Menu.Position = dim2off(0, 30)
        m_Menu.AutomaticSize = "Y"
        m_Menu.BackgroundColor3 = colors['bg_object']
        m_Menu.BorderSizePixel = 0
        m_Menu.ZIndex = M_IndexOffset
        m_Menu.Visible = false
        m_Menu.Parent = m_Header
        
         m_MenuListLayout = inst('UIListLayout')
         m_MenuListLayout.FillDirection = 'Vertical'
         m_MenuListLayout.HorizontalAlignment = 'Left'
         m_MenuListLayout.VerticalAlignment = 'Top'
         m_MenuListLayout.Parent = m_Menu
        
        stroke(m_Header)
        stroke(m_Menu)
        
        
        
        
        local M_Object = {} do 
            M_Object.MToggled = false
            M_Object.Menu = m_Menu
            M_Object.Icon = m_HeaderIcon
            M_Object.ZIndex = M_IndexOffset
            M_Object.Enabled = m_HeaderEnableEffect
            
            M_Object.AddMod = base_class.menu_create_module
            
            
            M_Object.Toggle = base_class.menu_toggle
            M_Object.GetState = base_class.menu_getstate
        end
        
        do
            local prevclicktime = 0
            m_Header.InputBegan:Connect(function(io) 
                local uitv = io.UserInputType.Value
                if (uitv == 0) then
                    local currclicktime = time()
                    if (currclicktime - prevclicktime < 0.3) then
                        M_Object:Toggle()
                    end
                    prevclicktime = currclicktime
                    
                    
                    local root_pos = m_Header.AbsolutePosition
                    local start_pos = io.Position
                    start_pos = vec2(start_pos.X, start_pos.Y)
                    
                    ui_Connections['menu-'..M_Id] = serv_uis.InputChanged:Connect(function(io) 
                        if (io.UserInputType.Value == 4) then
                            local curr_pos = io.Position
                            curr_pos = vec2(curr_pos.X, curr_pos.Y)
                            
                            local destination = root_pos + (curr_pos - start_pos) + monitor_inset
                            
                            twn(m_Header, {Position = dim2off(destination.X, destination.Y)})
                        end
                    end)
                    return
                end
                
                if (uitv == 1) then
                    M_Object:Toggle()
                end
            end)
            m_Header.InputEnded:Connect(function(io) 
                if (io.UserInputType.Value == 0) then
                    local a = ui_Connections['menu-'..M_Id]
                    if (a) then a:Disconnect() end
                end
            end)
            
            m_Header.MouseEnter:Connect(function() 
                m_Header.BackgroundColor3 = colors['bg_header-b']
            end)
            
            m_Header.MouseLeave:Connect(function() 
                m_Header.BackgroundColor3 = colors['bg_header']
            end)
        end
        
        
        
        ins(ui_Menus, M_Object)
        return M_Object
    end
    function ui:Destroy() 
        pcall(ui.Flags.Destroying)
        
        
        -- Destroy
        w_Screen:Destroy()
        
        -- Unbinds
        serv_ctx:UnbindAction('RL-ToggleMenu')
        
        -- Disconnections
        pcall(function() input_connection:Disconnect() end)
        
        for i,v in pairs(ui_Connections) do 
            v:Disconnect() 
        end
        
        -- Variable clearing
        colors = nil
        shadow,getnext,stroke,round,uierror = nil,nil,nil,nil,nil
        ui_Menus = nil
        
        _G.RLLoaded = false
    end
    function ui:GetModules() 
        return ui_Modules
    end
    function ui:GetScreen() 
        return w_Screen 
    end
    
    local notifs = {}
    function ui:Notify(title, text, duration) 
        duration = mc(duration or 2, 0.1, 30)
        
        local m_Notif
         local m_Description
         local m_Header
          local m_Title
          local m_Icon
          local m_Text
        
        local sound
        do 
            sound = inst("Sound")
            sound.Playing = true
            sound.SoundId = "rbxassetid://8745692251"
            sound.Volume = 1
            sound.Parent = w_Screen 
            
            m_Notif = inst('Frame')
            m_Notif.AnchorPoint = vec2(1,1)
            m_Notif.BackgroundColor3 = colors['bg_object']
            m_Notif.BorderColor3 = colors['outline']
            m_Notif.BorderSizePixel = 1
            m_Notif.Position = dim2(1, 275, 1, -((#notifs*125)+((#notifs+1)*50)))
            m_Notif.Size = dim2off(225, 125)
            m_Notif.ZIndex = 162
            m_Notif.Parent = w_Screen
            
             m_Progress = inst("Frame")
             m_Progress.BackgroundColor3 = colors['enabled']
             m_Progress.BorderSizePixel = 0
             m_Progress.Position = dim2off(0, 30)
             m_Progress.Size = dim2off(225, 1)
             m_Progress.ZIndex = 163
             m_Progress.Parent = m_Notif
            
             m_Header = inst('Frame')
             m_Header.BackgroundColor3 = colors['bg_header']
             m_Header.BorderColor3 = colors['outline']
             m_Header.BorderSizePixel = 1
             m_Header.Size = dim2off(225, 30)
             m_Header.ZIndex = 162
             m_Header.Parent = m_Notif
             
              m_Text = inst('TextLabel')
              m_Text.BackgroundTransparency = 1
              m_Text.Font = 'SourceSans'
              m_Text.Position = dim2off(32, 0)
              m_Text.RichText = true
              m_Text.Size = dim2(1, -32, 1, 0)
              m_Text.Text = tostring(title)
              m_Text.TextColor3 = colors['text1']
              m_Text.TextSize = 22
              m_Text.TextStrokeColor3 = colors['text3']
              m_Text.TextStrokeTransparency = 0
              m_Text.TextXAlignment = 'Left'
              m_Text.ZIndex = 162
              m_Text.Parent = m_Header
              
              m_Description = inst('TextLabel')
              m_Description.BackgroundTransparency = 1
              m_Description.Font = 'SourceSans'
              m_Description.Position = dim2off(4, 32)
              m_Description.RichText = true
              m_Description.Size = dim2(1, -4, 1, -32)
              m_Description.Text = tostring(text)
              m_Description.TextColor3 = colors['text1']
              m_Description.TextSize = 20
              m_Description.TextStrokeColor3 = colors['text3']
              m_Description.TextStrokeTransparency = 0
              m_Description.TextWrapped = true
              m_Description.TextXAlignment = 'Left'
              m_Description.TextYAlignment = 'Top'
              m_Description.ZIndex = 162
              m_Description.Parent = m_Notif
              
              m_Icon = inst('ImageLabel')
              m_Icon.Size = dim2off(30, 30)
              m_Icon.Position = dim2sca(0,0)
              m_Icon.BackgroundTransparency = 1
              m_Icon.ImageColor3 = colors['text1']
              m_Icon.Image = 'rbxassetid://8745673635'
              m_Icon.Rotation = 0
              m_Icon.ZIndex = 162
              m_Icon.Parent = m_Header
        end
        
        ins(notifs, m_Notif)
        
        twn(m_Notif, {Position = m_Notif.Position - dim2off(325)},true)
        ctwn(m_Progress, {Size = dim2off(0, 1)}, duration)
        delay(duration, function() 
            for i = 1, #notifs do 
                if (notifs[i] == m_Notif) then 
                    rem(notifs, i) 
                end 
            end
            for i = 1, #notifs do 
                twn(notifs[i], {Position = dim2(1, -50, 1, -(((i-1)*125)+(i*50)))}, true)
            end
            twn(m_Notif, {Position = dim2(1, -50, 1, 200)}, true).Completed:Wait()
            m_Notif:Destroy()
        end)
    end
    
    
    ui.Flags = {}
    ui.Flags.Destroying = true
    ui.Connect = base_class.generic_connect
    
    
    -- Bind gui
    serv_ctx:BindActionAtPriority('RL-ToggleMenu',function(_,uis) 
        
        if (uis.Value == 0) then
            W_WindowOpen = not W_WindowOpen
            
            if (W_WindowOpen) then
                w_Backframe.Visible = true
                twn(w_Backframe, {Position = dim2(0, 0, 0, 0)}, true)
            else
                twn(w_Backframe, {Position = dim2(0, 0, -1, 0)}, true).Completed:Connect(function() w_Backframe.Visible = false end)
            end
        end
    end,false,999999,Enum.KeyCode.RightShift)
    -- Auto collection
    delay(5, function() 
        if (ui_Menus ~= nil and #ui_Menus == 0) then
            ui:Destroy()
            warn'[REDLINE] Failure to clean library resources!\nAutomatically cleared for you; make sure to\ncall ui:Destroy() when finished'
        end
    end)
end

--delay(40, ui.Destroy, ui)
serv_ctx:BindActionAtPriority('RL-Destroy',function(_,uis) 
        
    if (uis.Value == 0) then
        ui:Destroy()
    end
end,false,999999,Enum.KeyCode.End)

-- holy shit
local isexecclosure = is_synapse_function or 


    is_exec_closure or 
    is_exec_func or 
    is_exec_function or 
    is_executor_closure or 
    is_executor_func or 
    is_executor_function or
    is_our_closure or 
    is_our_func or
    is_our_function or 
    is_synapse_closure or 
    is_synapse_func or 
    is_synapse_function or 
    iselectronfunction or 
    isexecclosure or 
    isexecfunc or 
    isexecfunction or 
    isexecutorclosure or
    isexecutorfunc or 
    isexecutorfunction or
    isfluxusfunction or 
    iskrnlclosure or
    iskrnlfunction or
    isourclosure or 
    isourfunc or
    isourfunction or
    isoxygenfunction
    
-- disable non executor connections
local function ratio(signal) 
    local average = getconnections(signal)
    for i = 1, #average do 
        local connection = average[i]
        local confunc = connection.Function
        
        if (type(confunc) == "function" and islclosure(confunc)) then
            if (not isexecclosure(confunc)) then
                connection:Disable()
            end
        end
    end
end
local function unratio(signal)
    local average = getconnections(signal)
    for i = 1, #average do 
        local connection = average[i]
        local confunc = connection.Function
        
        if (type(confunc) == "function" and islclosure(confunc)) then
            if (not isexecclosure(confunc)) then
                connection:Enable()
            end
        end
    end
end

local cons = {}

local l_plr = serv_players.LocalPlayer
local l_mouse = l_plr:GetMouse()
local l_chr = l_plr.Character
local l_hum = l_chr:FindFirstChild("Humanoid")
local l_humrp = l_chr:FindFirstChild("HumanoidRootPart")

local l_cam = workspace.CurrentCamera or workspace:FindFirstChildOfClass("Camera")

cons['chr'] = l_plr.CharacterAdded:Connect(function(c) 
    l_chr = c
    l_hum = c:WaitForChild("Humanoid",3)
    l_humrp = c:WaitForChild("HumanoidRootPart",3)
end)

local rlfriends = {}

-- Every single player 
local p_players_all = {}
-- Every player minus friends and local player 
local p_players = {}

local function addplr(p) 
    --printconsole('Adding player '..p.Name, 0, 255, 255)
    local ptable = {}
    ptable['plr'] = p
    ptable['chr'] = nil
    ptable['hum'] = nil
    ptable['rp'] = nil
    
    ptable['cons'] = {}
    
    --printconsole('Set up the table', 128, 128, 128)
    ptable['cons'][1] = p.CharacterAdded:Connect(function(c) 
        ptable['chr'] = c
        ptable['hum'] = c:WaitForChild("Humanoid", 1)
        ptable['rp'] = c:WaitForChild("HumanoidRootPart", 1)
        --printconsole(p.Name..' respawned; Updated some vars n shit', 0, 255, 0)
    end)
    
    if (p.Character) then
        ptable['chr'] = p.Character
        ptable['hum'] = p.Character:FindFirstChild("Humanoid")
        ptable['rp'] = p.Character:FindFirstChild("HumanoidRootPart")
        --printconsole('Got character stuff', 128, 128, 128)
    end
    
    
    ins(p_players_all, ptable)
    if not (p == l_plr or rlfriends[p.Name]) then
        --printconsole('Not blacklisted / local plr, added to player table', 0, 255, 0)
        ins(p_players, ptable)
    end
    --printconsole('Inserted into proper tables', 128, 128, 128)
end 
local function remplr(p) 
    --printconsole(p.Name..' left cleaning shit', 255, 255, 0)
    -- Player left, find the player object in each table
    --printconsole('Clearing their player table [1]', 0, 255, 0)
    for i = 1, #p_players do 
        local plr = p_players[i]
        -- Check for matching player objects
        if (plr.plr == p) then
            local cons = plr.cons
            -- Disable connections
            for i = 1, #cons do cons[i]:Disconnect() end
            -- Clear table and stuff
            p_players[i] = nil
            -- Remove it from the player list
            --printconsole('Removed their player table [1]', 0, 255, 0)
            rem(p_players, i)
            break
        end
    end
    -- Next check the other table
    --printconsole('Clearing their player table [2]', 0, 255, 0)
    for i = 1, #p_players_all do 
        local plr = p_players_all[i]
        -- Check for matching player objects
        if (plr.plr == p) then
            local cons = plr.cons
            -- Disable connections
            for i = 1, #cons do cons[i]:Disconnect() end
            -- Clear table and stuff
            p_players_all[i] = nil
            -- Remove it from the player list
            --printconsole('Removed their player table [2]', 0, 255, 0)
            rem(p_players_all, i)
            break
        end
    end
end

cons['p1'] = serv_players.PlayerAdded:Connect(addplr)
cons['p2'] = serv_players.PlayerRemoving:Connect(remplr)
cons['cam'] = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function() 
    local cc = workspace.CurrentCamera
    if not cc then
        cc = workspace:FindFirstChildOfClass("Camera")
    end
    l_cam = cc
end)
for i,p in ipairs(serv_players:GetChildren()) do 
    addplr(p)
end


ui:Connect("Destroying", function() 
    for i,v in pairs(cons) do v:Disconnect() end
    for i,v in ipairs(ui:GetModules()) do 
        if (v.Toggle and v:IsEnabled()) then
            v:Toggle()
        end
    end
    
    for i = 1, #p_players_all do 
        local _ = p_players_all[i].cons
        for i = 1, #_ do _[i]:Disconnect() end
    end

    for i = 1, #p_players_nolfr do 
        local _ = p_players_nolfr[i].cons
        for i = 1, #_ do _[i]:Disconnect() end
    end
end)

local donetxt = ' <font color="rgb(255,87,68)">[Done]</font>'


local m_combat = ui:CreateMenu('Combat') do 
    local c_aimbot  = m_combat:AddMod('Aimbot')
    local c_antiaim = m_combat:AddMod('Anti-aim')
    local c_hitbox  = m_combat:AddMod('Hitboxes')
    local c_stare   = m_combat:AddMod('Stare')
    local c_tpbot   = m_combat:AddMod('TPbot')
    local c_trigbot = m_combat:AddMod('Triggerbot')
    
    
    -- Aimbot 
    do
        local c_aim_team   = c_aimbot:AddToggle('Team check')
        local c_aim_friend = c_aimbot:AddToggle('Friend check')
        local c_aim_lock   = c_aimbot:AddToggle('Player lock')
        local c_aim_mode   = c_aimbot:AddDropdown('Mode',true)
        local c_aim_smooth = c_aimbot:AddSlider('Smoothness',{min=0,max=100,cur=15,step=0.25})
        
        
        c_aim_team:SetTooltip('Blacklists players on your team from the aimbot check')
        c_aim_friend:SetTooltip('Blacklists players added to your Redline friends list from the aimbot check')
        c_aim_lock:SetTooltip('Locks onto the first valid player and doesn\'t switch from them')
        c_aim_mode:SetTooltip('The aimbot mode used')
        
        do
            c_aim_mode:AddOption('Mouse')
            :Select()
            :SetTooltip('Uses mousemoverel. May not be as stable as Camera, but it\'s significantly better.');
            
            c_aim_mode:AddOption('Camera')
            :SetTooltip('Makes the Camera face the target. Although it works good, it has compatibility issues with complex games');
        end
        
        
        c_aimbot:SetTooltip('Classic aimbot, use in FPS games like Arsenal')
    end
    -- Antiaim
    do 
        local c_aim_always = c_antiaim:AddToggle('Always spin')
        local c_aim_mode = c_antiaim:AddDropdown('Mode', true)
        c_aim_mode:SetTooltip('The mode Anti-aim uses')
        c_aim_always:SetTooltip('Spins while not moving')
        
        do 
            local _ = c_aim_mode:AddOption('Horizontal spin')
            :Select()
            :SetTooltip('Only spins you around horizontally')
            
            c_aim_mode:AddOption('Omnidirectional spin')
            :SetTooltip('Spins you around in every direction')
        end
        
        
        c_antiaim:SetTooltip('Prevents others from headshotting you by spinning you around')
    end
    -- Hitbox
    do 
        local c_hitb_team    = c_hitbox:AddToggle('Team check')
        local c_hitb_friend  = c_hitbox:AddToggle('Friend check')
        local c_hitb_display = c_hitbox:AddToggle('Show hitboxes')
        
        c_hitb_team:SetTooltip('Disables the expander for your teammates')
        c_hitb_friend:SetTooltip('Disables the expander for players on your Redline friends list')
        c_hitb_display:SetTooltip('Displays the expanded hitboxes')
        
        
        c_hitbox:SetTooltip('Hitbox expander, use in FPS or swordfighting games')
    end
    -- Stare
    do
        local c_stare_team   = c_stare:AddToggle('Team check')
        local c_stare_friend = c_stare:AddToggle('Friend check')
        
        c_stare_team:SetTooltip('Disables stare for your teammates')
        c_stare_friend:SetTooltip('Disables stare for your friends')
        
        
        
        c_stare:SetTooltip('Always faces you towards the nearest player, useful for sword fighting games')
    end
    -- Tp bot 
    do
        local c_tpbot_team   = c_tpbot:AddToggle('Team check')
        local c_tpbot_friend = c_tpbot:AddToggle('Friend check')
        local c_tpbot_face   = c_tpbot:AddToggle('Face center')
        
        c_tpbot_team:SetTooltip('Disables TPbot for your teammates')
        c_tpbot_friend:SetTooltip('Disables TPbot for your friends')
        c_tpbot_face:SetTooltip('Faces your character towards the position you\'re teleporting around')
        
        
        c_tpbot:SetTooltip('Teleports you around the nearest player. Can prevent you from being hit, also useful for swordfighting games')
        
        -- Check for closest player every .03s or so
        -- Get distance, check if less than user input 
        -- If so then lock onto them until their character dies or you move away
    end
    -- Trig bot
    do 
        local c_trig_team = c_trigbot:AddToggle('Team check')
        local c_trig_friend = c_trigbot:AddToggle('Friend check')
        
        
        c_trig_team:SetTooltip('Disables Triggerbot for your teammates')
        c_trig_friend:SetTooltip('Disables Triggerbot for your friends')
        
        c_trigbot:SetTooltip('Automatically clicks when you mouse over a player')
        
    end
end
local m_player = ui:CreateMenu('Player') do 
    local p_antiafk     = m_player:AddMod('Anti-AFK'..donetxt)
    local p_anticrash   = m_player:AddMod('Anti-crash'..donetxt)
    local p_antifling   = m_player:AddMod('Anti-fling'..donetxt)
    local p_antiwarp    = m_player:AddMod('Anti-warp'..donetxt)
    local p_autoclick   = m_player:AddMod('Auto clicker')
    local p_fancy       = m_player:AddMod('Fancy chat')
    local p_flashback   = m_player:AddMod('Flashback'..donetxt)
    local p_ftools      = m_player:AddMod('Funky tools')
    local p_gtweaks     = m_player:AddMod('Game tweaks')
    local p_logs        = m_player:AddMod('Logs')
    local p_pathfind    = m_player:AddMod('Pathfinder')
    local p_radar       = m_player:AddMod('Radar')
    local p_respawn     = m_player:AddMod('Respawn'..donetxt, 'Toggle')
    local p_waypoints   = m_player:AddMod('Waypoints'..donetxt)
    
    -- Anti afk
    do 
        local p_afk_mode   = p_antiafk:AddDropdown('Mode', true)
        do 
            local _ = p_afk_mode:AddOption('Standard')
            :Select()
            :SetTooltip('Disables connections related to player idling. Impossible to detect, has no side-effects');
            
            p_afk_mode:AddOption('Move on idle'):SetTooltip('Automatically moves your character when the client idles')
            p_afk_mode:AddOption('Walk around'):SetTooltip('Randomly moves your character around. Useful for games with more afk checks than the default roblox ones')
        end
        
        
        local c
        local p = 'Standard'
        p_antiafk:Connect("Enabled", function() 
            if (p == 'Standard') then
                ratio(l_plr.Idled)
                return 
            end
            if (p == 'Move on idle') then
                c = l_plr.Idled:Connect(function() 
                    l_hum:MoveTo(l_humrp.Position + vec3(0, 0, 2))
                end)
                return 
            end
	    
            if (p == 'Walk around') then
                spawn(function() 
                    local base = l_humrp.Position
                    while (p_antiafk:IsEnabled()) do 
                        wait(mr()*8)
                        l_hum:MoveTo(base + vec3(
                            (mr()-.5)*15,
                            0,
                            (mr()-.5)*15)
                        )
                    end
                end)
                return
            end
        end)
        p_antiafk:Connect("Disabled", function()
            unratio(l_plr.Idled)
            
            if (c) then
                c:Disconnect()
                c = nil
            end
        end)
        p_afk_mode:Connect("SelectionChanged", function(v) 
            p = v
            if (p_antiafk:IsEnabled()) then
                p_antiafk:Disable()
                p_antiafk:Enable()
            end
        end)
    end
    -- Anticrash
    do 
        local sc = game:GetService("ScriptContext")
        
        local amnt = p_anticrash:AddSlider('Delay',{min=0.1,max=5,cur=2,step=0.1},true):SetTooltip('Anti-crash sensitivity. <b>Setting this too low may mess with your game. Leave it at the default if you don\'t know what this does.</b>')
        
        amnt:Connect("ValueChanged",function(v) 
            if (p_anticrash:IsEnabled()) then
                sc:SetTimeout(v)
            end
        end)
        
        p_anticrash:Connect("Toggled",function(t) 
            if t then
                sc:SetTimeout(amnt:GetValue())
            else
                sc:SetTimeout(99)
            end
        end)
    end
    -- Antifling
    do 
        local mode = p_antifling:AddDropdown('Method', true)
        do 
            mode:AddOption('Anchor'):Select():SetTooltip('Anchors your character when someone gets close to you, works the best but limits movement')
            mode:AddOption('Noclip'):SetTooltip('Activates noclip. However, it\'s only good at stopping weak flings, and you will still be slightly pushed around')
            mode:AddOption('Teleport'):SetTooltip('Teleports you away from them. Very funny to use but you\'ll likely be flung')
        end
        local distance = 25
	    local pcon
        
        p_antifling:AddSlider('Distance',{min=1,max=50,cur=25,step=0.1}):SetTooltip('How close a player has to be to you to trigger the antifling'):Connect("ValueChanged",function(v)distance=v;end)
        
        
	    p_antifling:Connect("Enabled", function() 
            local m = mode:GetSelection()
            if (m == 'Anchor') then
                pcon = serv_rs.Heartbeat:Connect(function() 
                    local self_pos = l_humrp.Position
                    l_humrp.Anchored = false
                    for i = 1, #p_players do 
                        local plr = p_players[i]
                        local rp = plr.rp
                        if (rp and ((rp.Position - self_pos).Magnitude) < distance) then
                            l_humrp.Anchored = true
                            break
                        end
                    end		
                end)                
            elseif (m == 'Noclip') then
                pcon = serv_rs.Heartbeat:Connect(function() 
                    local self_pos = l_humrp.Position
                    for i = 1, #p_players do 
                        local plr = p_players[i]
                        local rp = plr.rp
                        if (rp and ((rp.Position - self_pos).Magnitude) < distance) then
                            local c = l_chr:GetChildren()
                            for i = 1, #c do 
                                local v = c[i]
                                if (v:IsA("BasePart")) then
                                    v.CanCollide = false    
                                end
                            end
                            break
                        end
                    end		
                end)
            elseif (m == 'Teleport') then
                pcon = serv_rs.Heartbeat:Connect(function() 
                    local self_pos = l_humrp.Position
                    for i = 1, #p_players do 
                        local plr = p_players[i]
                        local rp = plr.rp
                        if (rp and ((rp.Position - self_pos).Magnitude) < distance) then
                            l_humrp.CFrame += vec3(mr(-100,100)*.1,mr(0,20)*.1,mr(-100,100)*.1)
                            break
                        end
                    end		
                end)
            end
	    end)
	    p_antifling:Connect("Disabled", function() 
	        if (pcon) then pcon:Disconnect() pcon = nil end		
	    end)
    
    
	    mode:Connect("SelectionChanged", function()
	        if (p_antifling:IsEnabled()) then
	            p_antifling:Disable()
	            p_antifling:Enable()
	        end
	    end)
    
	    mode:SetTooltip('The method Antifling uses')
    end
    -- Antiwarp
    do 
        local lerpslider = p_antiwarp:AddSlider('Lerp',{min=0,max=1,cur=1,step=0.01}):SetTooltip('How much you will be teleported back when antiwarp gets triggered')
        local distslider = p_antiwarp:AddSlider('Distance',{min=1,max=150,cur=20,step=0.1}):SetTooltip('How far you\'d have to be teleported before it gets set off')
        local lerp = 1
        local dist = 20
        
        lerpslider:Connect("ValueChanged",function(v)lerp=v;end)
        distslider:Connect("ValueChanged",function(v)dist=v;end)
        local con
        local cf1 = l_humrp.CFrame
        local cf2 = l_humrp.CFrame
        p_antiwarp:Connect("Enabled",function() 
            ratio(l_humrp.Changed)
            ratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            cf2 = l_humrp.CFrame
            con = serv_rs.Heartbeat:Connect(function() 
                cf1 = l_humrp.CFrame 
                if ((cf1.Position - cf2.Position).Magnitude > dist) then
                    local _ = cf1:lerp(cf2, lerp)
                    cf2 = _
                    l_humrp.CFrame = _
                else
                    cf2 = cf1
                end
            end)
        end)
        p_antiwarp:Connect("Disabled",function() 
            if (con) then con:Disconnect() con=nil end
            
            unratio(l_humrp.Changed)
            unratio(l_humrp:GetPropertyChangedSignal("CFrame"))
        end)
    end
    -- Autoclick
    do 
        local buttontype = p_autoclick:AddDropdown('Button',true)
        buttontype:AddOption('Left click')
        buttontype:AddOption('Right click')
        buttontype:AddOption('Custom')
        
        local customkey = p_autoclick:AddHotkey()
        
    end 
    -- Flashback
    do 
        local flash_delay = p_flashback:AddSlider("Delay", {min=0,max=2,cur=0,step=0.1})
        flash_delay:SetTooltip('How long to wait before teleporting you back')
        
        local fb_con
        local resp_con
        
        p_flashback:Connect("Enabled", function() 
            
            local function bind(h) 
                h.Died:Connect(function() 
                    local pos = l_humrp.CFrame
                    l_plr.CharacterAdded:Wait()
                    delay(flash_delay:GetValue(), function() l_humrp.CFrame = pos end)
                end)
            end
            
            resp_con = l_plr.CharacterAdded:Connect(function() 
                wait()
                bind(l_hum)
            end)
            
            bind(l_hum)
        end)
        p_flashback:Connect("Disabled", function() 
            fb_con:Disconnect()
            resp_con:Disconnect()
        end)
    end
    -- Respawn
    do 
        p_respawn:Connect("Enabled", function() 
            l_hum:Destroy()
        end)
    end
    -- Waypoints
    do
        local waypoints
        local makewp = p_waypoints:AddInput('Make waypoint')
        local gotowp = p_waypoints:AddInput('Goto waypoint')
        local delewp = p_waypoints:AddInput('Delete waypoint')
        local deleall = p_waypoints:AddButton('Delete all waypoints')
        
        local folder
        
        local cg = game.CoreGui
        
        local function makewaypoint(text) 
            local new = {}
            new[1] = text
            new[2] = l_humrp.CFrame
            
            local a = inst("BillboardGui")
            local b = inst("BoxHandleAdornment")
            local c = inst("Part")
            local d = inst("TextLabel")
            
            
            c.Anchored = true
            c.CanCollide = false
            c.CanTouch = false
            c.Color = c3n(0,0,0)
            c.Name = getnext()
            c.Size = vec3(1, 1, 1)
            c.Position = new[2].Position
            c.Transparency = 1
            
            a.Adornee = c
            a.AlwaysOnTop = true
            a.LightInfluence = 0.8
            a.Size = dim2(1.5, 30, 0.75, 15)
            
            b.Adornee = c
            b.AlwaysOnTop = false
            b.ZIndex = 10
            b.Color3 = c3n(0,0,0)
            b.Size = vec3(2, 100, 2)
            b.SizeRelativeOffset = vec3(0, 100, 0)
            b.Transparency = 0.5
            
            d.BackgroundColor3 = colors['bg_header']
            d.BackgroundTransparency = 0.6
            d.BorderColor3 = colors['outline']
            d.BorderSizePixel = 1
            d.Font = 'SourceSans'
            d.Size = dim2sca(1,1)
            d.Text = text
            d.TextColor3 = colors['text1']
            d.TextScaled = true
            d.TextStrokeColor3 = colors['shadow']
            d.TextStrokeTransparency = 0
            
            
            
            c.Parent = folder
            a.Parent = folder
            b.Parent = folder
            d.Parent = a
            
            
            
            new[3] = a
            new[4] = b
            new[5] = c
            new[6] = d
            
            ins(waypoints, new)
        end
        
        
        makewp:Connect("Unfocused",function(text) 
            if (not p_waypoints:IsEnabled()) then p_waypoints:Enable() end
            
            for i = 1, #waypoints do
                local wp = waypoints[i]
                if (wp[1] == text) then
                    for i = 3, 5 do wp[i]:Destroy() end
                    rem(waypoints, i)
                    break
                end
            end 
            
            makewaypoint(text)
        end)
        
        delewp:Connect("Unfocused",function(text) 
            for i = 1, #waypoints do
                local wp = waypoints[i]
                if (wp[1] == text) then
                    for i = 3, 5 do wp[i]:Destroy() end
                    rem(waypoints, i)
                    break
                end
            end 
        end)
        
        gotowp:Connect("Unfocused",function(text) 
            for i = 1, #waypoints do
                local wp = waypoints[i]
                if (wp[1] == text) then
                    ratio(l_humrp.Changed)
                    ratio(l_humrp:GetPropertyChangedSignal("CFrame"))
                    l_humrp.CFrame = wp[2]
                    unratio(l_humrp.Changed)
                    unratio(l_humrp:GetPropertyChangedSignal("CFrame"))
                end
            end 
        end)
        
        deleall:Connect("Clicked",function() 
            for i = 1, #waypoints do
                local wp = waypoints[i]
                for i = 3, 5 do wp[i]:Destroy() end
                waypoints[i] = nil
            end
            cle(waypoints)
        end)
        
        p_waypoints:Connect("Enabled",function() 
            waypoints = {}
            
            folder = inst("Folder")
            folder.Name = getnext()
            folder.Parent = game.CoreGui
        end)
        
        p_waypoints:Connect("Disabled",function() 
            folder:Destroy()
            
            
            for i = 1, #waypoints do
                local wp = waypoints[i]
                for i = 3, 5 do wp[i]:Destroy() end
                waypoints[i] = nil
            end
            waypoints = nil
            
        end)
        
        deleall:SetTooltip('Deletes all waypoints. Preferable over untoggling and retoggling')
        makewp:SetTooltip('Makes a waypoint at your position with the name you type in')
        delewp:SetTooltip('Deletes all waypoints matching the name you type in')
    end
    
    p_antiafk:SetTooltip('Prevents you from being disconnected due to idling for too long')
    p_anticrash:SetTooltip('Prevents game scripts from while true do end\'ing you')
    p_antifling:SetTooltip('Prevents skids from flinging you, has several modes and a sensitivity option')
    p_antiwarp:SetTooltip('Prevents you from being teleported. Has options for sensitivity and lerp')
    p_autoclick:SetTooltip('Standard autoclicker')
    p_fancy:SetTooltip('Converts your chat letters into a fancier version. Has a toggleable mode and a non-toggleable mode')
    p_flashback:SetTooltip('Teleports you back after you die. Has options for delayed teleport')
    p_ftools:SetTooltip('Lets you equip and unequip multiple tools at once')
    p_gtweaks:SetTooltip('Lets you configure various misc "forceable" settings like 3rd person, chat, inventories, and more')
    p_logs:SetTooltip('Displays logs for player joins, leaves, and messages')
    p_pathfind:SetTooltip('Pathfinder. Kinda like Baritone')
    p_radar:SetTooltip('Radar that displays where other players are')
    p_respawn:SetTooltip('Better version of resetting, can fix some glitches with reanimations')
    p_waypoints:SetTooltip('Lets you save positions and teleport to them later')
end
local m_movement = ui:CreateMenu('Movement') do 
    local m_airjump   = m_movement:AddMod('Air jump'..donetxt)
    local m_blink     = m_movement:AddMod('Blink')
    local m_clicktp   = m_movement:AddMod('Click TP'..donetxt)
    local m_fastfall  = m_movement:AddMod('Fastfall')
    local m_flight    = m_movement:AddMod('Flight'..donetxt)
    local m_float     = m_movement:AddMod('Float'..donetxt)
    local m_highjump  = m_movement:AddMod('High jump')
    local m_jesus     = m_movement:AddMod('Jesus')
    local m_jetpack   = m_movement:AddMod('Jetpack')
    local m_noclip    = m_movement:AddMod('Noclip')
    local m_noslow    = m_movement:AddMod('Noslowdown')
    local m_parkour   = m_movement:AddMod('Parkour')
    local m_phase     = m_movement:AddMod('Phase')
    local m_safewalk  = m_movement:AddMod('Safewalk')
    local m_speed     = m_movement:AddMod('Speed'..donetxt)
    local m_spider    = m_movement:AddMod('Spider')
    local m_step      = m_movement:AddMod('Step')
    local m_velocity  = m_movement:AddMod('Velocity')
    -- Airjump
    do 
        local mode = m_airjump:AddDropdown('Mode',true)
        mode:AddOption('Jump'):SetTooltip('Simply just jumps. If the game has something to prevent jumps, this will not work'):Select()
        mode:AddOption('Velocity'):SetTooltip('Changes your velocity. Bypasses jump prevention, but this is not as realistic as actually jumping')
        local velmount = m_airjump:AddSlider('Velocity amount', {min=-500,max=500,cur=70})
        
        local vel = 70
        local ajcon
        
        velmount:Connect("ValueChanged",function(v)vel=v;end)
        
        m_airjump:Connect("Enabled", function() 
            if (mode:GetSelection() == 'Jump') then
                if gpe then return end
                ajcon = serv_uis.InputBegan:Connect(function(io, gpe) 
                    if (io.KeyCode.Value == 32) then
                        l_hum:ChangeState(3)
                    end
                end)
            else
                ajcon = serv_uis.InputBegan:Connect(function(io, gpe) 
                    if gpe then return end 
                    if (io.KeyCode.Value == 32) then
                        l_humrp.Velocity = vec3(0, vel, 0)
                    end
                end)
            end
        end)
    
        m_airjump:Connect("Disabled", function() 
            ajcon:Disconnect()
        end)
        
        mode:Connect("SelectionChanged",function() 
            if (m_airjump:IsEnabled()) then
                m_airjump:Disable() 
                m_airjump:Enable()
            end
        end)
        
        mode:SetTooltip('Mode for Airjump to use')
        velmount:SetTooltip('Amount to set your velocity to for the Velocity mode')
    end
    -- Click tp
    do 
        local k = m_clicktp:AddHotkey('Teleport key'):SetTooltip('The key you have to be pressing in order to TP')
        local key = Enum.KeyCode.LeftControl
        k:Connect("HotkeySet",function(kc)key=kc;end)
        k:SetHotkey(Enum.KeyCode.LeftControl)
        
        local mc
        
        m_clicktp:Connect("Toggled",function(t) 
            if (t) then
                local offset = vec3(0, 3, 0)
                mc = l_mouse.Button1Down:Connect(function() 
                    if (key) then
                        if (serv_uis:IsKeyDown(key)) then
                            local lv = l_humrp.CFrame.LookVector
                            local p = l_mouse.Hit.Position + offset
                            l_humrp.CFrame = cfn(p, p+lv)
                        end
                    else
                        local lv = l_humrp.CFrame.LookVector
                        local p = l_mouse.Hit.Position + offset
                        l_humrp.CFrame = cfn(p, p+lv)
                    end
                end)
            else
                mc:Disconnect()
            end
        end)
        
    end
    -- Fast fall
    do 
        local modedd = m_fastfall:AddDropdown('Mode'):SetTooltip('The method Fastfall uses')
        modedd:AddOption('Raycast'):SetTooltip('Raycasts downwards, instantly teleporting you down')
    end
    -- Float
    do 
        local mode = m_float:AddDropdown('Mode'):SetTooltip('What method Float will use')
        mode:AddOption('Undetectable'):SetTooltip('Directly changes your velocity. Isn\'t perfect, but it\'s undetectable'):Select()
        mode:AddOption('Velocity'):SetTooltip('Uses a bodymover. Has better results, but is easier to detect')
        
        local vel = m_float:AddSlider('Velocity',{min=-10,cur=0,max=10,step=0.1}):SetTooltip('The amount of velocity you\'ll have when floating')
        local amnt = 0
        
        vel:Connect("ValueChanged",a)
        
        mode:Connect("SelectionChanged",function() 
            if (m_float:IsEnabled()) then
                m_float:Disable()
                m_float:Enable()
            end
        end)
        
        local fcon
        local finst
        
        local a = function(v) amnt = v; end
        local b = function(v) finst.Velocity = vec3(0, v, 0) end
        
        
        
        m_float:Connect("Enabled",function() 
            local mode = mode:GetSelection()
            if (mode == 'Undetectable') then
                fcon = serv_rs.Heartbeat:Connect(function() 
                    local vel = l_humrp.Velocity
                    
                    l_humrp.Velocity = vec3(vel.X, amnt+1.15, vel.Z)
                end)
            elseif (mode == 'Velocity') then
                ratio(l_humrp.ChildAdded)
                ratio(l_humrp.DescendantAdded)
                
                finst = inst("BodyVelocity")
                finst.MaxForce = vec3(0, 9e9, 0)
                finst.Velocity = vec3(0, vel:GetValue(), 0)
                finst.Parent = l_humrp
                
                vel:Connect("ValueChanged",b)
            end
        end)
        m_float:Connect("Disabled",function() 
            if (finst) then finst:Destroy(); finst = nil end
            if (fcon) then fcon:Disconnect() fcon = nil end
            
            vel:Connect("ValueChanged",a)
            
            unratio(l_humrp.ChildAdded)
            unratio(l_humrp.DescendantAdded)
        end)
        
        
        
        
    end
    -- Speed
    do 
        local mode = m_speed:AddDropdown('Mode',true)
        mode:AddOption('Standard'):SetTooltip('Standard CFrame speed. <b>Mostly</b> undetectable, unlike other scripts such as Inf Yield. Also known as TPWalk'):Select()
        mode:AddOption('Velocity'):SetTooltip('Changes your velocity, doesn\'t use any bodymovers. Because of friction, Velocity typically won\'t increase your speed unless it\'s set high or you jump.')
        mode:AddOption('Bhop'):SetTooltip('The exact same as Velocity, but it spam jumps. Useful for looking legit in games with bhop mechanics, like Arsenal')
        mode:AddOption('Part'):SetTooltip('Pushes you physically with a clientside part. Can also affect vehicles in certain games, such as Jailbreak')
        mode:AddOption('WalkSpeed'):SetTooltip('<font color="rgb(255,64,64)"><b>Insanely easy to detect. There\'s no good reason to use this mode. Doesn\'t come with any protection. Use Standard instead.</b></font>')
        
        local speedslider = m_speed:AddSlider('Speed',{min=0,max=200,cur=50,step=0.1})
        local speed = 50
        speedslider:Connect("ValueChanged",function(v)speed=v;end)
        local part
        local scon
        
        local ev = serv_rs.Heartbeat
        
        m_speed:Connect("Enabled",function() 
            local mode = mode:GetSelection()
            
            ratio(l_hum.Changed)
            ratio(l_hum:GetPropertyChangedSignal("Jump"))
            ratio(l_humrp.Changed)
            ratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            ratio(l_humrp:GetPropertyChangedSignal("Velocity"))
            
            if (scon) then scon:Disconnect() scon = nil end
            
            if (mode == 'Standard') then
                scon = ev:Connect(function(dt) 
                    l_humrp.CFrame += l_hum.MoveDirection * (5 * dt * speed)
                end)
            elseif (mode == 'Velocity') then
                scon = ev:Connect(function(dt) 
                    l_humrp.Velocity += l_hum.MoveDirection * (5 * dt * speed)
                end)
            elseif (mode == 'Bhop') then
                scon = serv_rs.RenderStepped:Connect(function(dt) 
                    local md = l_hum.MoveDirection
                    
                    l_humrp.Velocity += md * (5 * dt * speed)
                    l_hum.Jump = not (md.Magnitude < 0.01 and true or false)
                end)
            elseif (mode == 'Part') then
                part = inst("Part")
                part.Transparency = 0.8
                part.Size = vec3(4,4,1)
                part.CanTouch = false
                part.CanCollide = true
                part.Anchored = false
                part.Name = getnext()
                part.Parent = workspace
                scon = ev:Connect(function(dt) 
                    local md = l_hum.MoveDirection
                    local p = l_humrp.Position
                    
                    part.CFrame = cfn(p-(md), p)
                    part.Velocity = md * (dt * speed * 1200)
                    
                    l_hum:ChangeState(8)
                end)
            elseif (mode == 'WalkSpeed') then
                scon = ev:Connect(function() 
                    l_hum.WalkSpeed = speed
                end)
            end
        end)
        
        m_speed:Connect("Disabled",function() 
            if (scon) then scon:Disconnect() scon = nil end
            if (part) then part:Destroy() end
            
            unratio(l_hum.Changed)
            unratio(l_hum:GetPropertyChangedSignal("Jump"))
            unratio(l_humrp.Changed)
            unratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            unratio(l_humrp:GetPropertyChangedSignal("Velocity"))
        end)
        
        mode:Connect("SelectionChanged",function() 
            if (m_speed:IsEnabled()) then
                m_speed:Disable()
                m_speed:Enable()
            end
        end)
        
        mode:SetTooltip('Method used for the speedhack')
        speedslider:SetTooltip('Amount of speed')
    end
    -- Noclip
    do 
        
    end
    -- Flight
    do 
        local ascend_h = m_flight:AddHotkey('Ascend key')
        local descend_h = m_flight:AddHotkey('Descend key')
        local mode = m_flight:AddDropdown('Method', true)
        local turndir = m_flight:AddDropdown('Turn direction')
        local speedslider = m_flight:AddSlider('Speed',{min=0,max=300,step=0.1,cur=30})
        local camera = m_flight:AddToggle('Camera-based')
        
        
        mode:AddOption('Standard'):SetTooltip('Standard CFlight. Undetectable (within reason), unlike other scripts such as Inf Yield'):Select()
        mode:AddOption('Smooth'):SetTooltip('Just like Standard, but smooth')
        mode:AddOption('Vehicle'):SetTooltip('BodyPosition CFlight, may let you fly with vehicles in some games like Jailbreak. Has more protection than other scripts, but is still more detectable than Standard')
        
        
        turndir:AddOption('XYZ'):SetTooltip('Follows the camera\'s direction exactly. <b>This is the typical option in every other flight script</b>'):Select()
        turndir:AddOption('XZ'):SetTooltip('Follows the camera\'s direction on all axes but Y')
        turndir:AddOption('Up'):SetTooltip('Faces straight up, useful for carrying players')
        turndir:AddOption('Down'):SetTooltip('I really hope you can figure this one out')
        
        local fi1 -- flight inst 1 
        local fi2 -- flight inst 2  
        local fcon -- flight connection
        
        
        local cscon -- camera subject connection (vehicle fly)
        local clvcon -- connection to update camera look vector
        local clv -- camera look vector
        local normclv -- normal unmodified one
        
        local ask = Enum.KeyCode.E-- keycode for ascension
        local dsk = Enum.KeyCode.Q-- keycode for descension
        
        local speed = 30 -- speed 
        
        local cambased = true 
        camera:Enable()
        
        ascend_h:Connect("HotkeySet",function(j)ask=j or 0;end)
        descend_h:Connect("HotkeySet",function(k)dsk=k or 0;end)
        camera:Connect("Toggled",function(t)
            cambased=t;
            if (m_flight:IsEnabled()) then 
                m_flight:Disable()
                m_flight:Enable() 
            end
        end)
        turndir:Connect("SelectionChanged",function() 
            if (m_flight:IsEnabled()) then 
                m_flight:Disable()
                m_flight:Enable() 
            end
        end)
        mode:Connect("SelectionChanged",function() 
            if (m_flight:IsEnabled()) then 
                m_flight:Disable()
                m_flight:Enable() 
            end
        end)
        speedslider:Connect("ValueChanged",function(v)speed=v;end)
        
        m_flight:Connect("Enabled", function()
            clv = l_cam.CFrame.LookVector 
            normclv = clv
            
            ratio(l_humrp.Changed)
            ratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            ratio(l_humrp:GetPropertyChangedSignal("Velocity"))
            
            local curmod = mode:GetSelection()
            local curturn = turndir:GetSelection()
            
            local upp, downp, nonep = vec3(0, 1, 0), vec3(0, -1, 0), vec3(0,0,0)
            
            
            if (curturn == 'XYZ') then 
                clvcon = l_cam:GetPropertyChangedSignal("CFrame"):Connect(function() 
                    normclv = l_cam.CFrame.LookVector
                    clv = normclv
                end)
            elseif (curturn == 'XZ') then
                clvcon = l_cam:GetPropertyChangedSignal("CFrame"):Connect(function() 
                    normclv = l_cam.CFrame.LookVector
                    clv = vec3(normclv.X, 0, normclv.Z)
                end)
            elseif (curturn == 'Up') then
                if (cambased) then
                    clvcon = l_cam:GetPropertyChangedSignal("CFrame"):Connect(function() 
                        normclv = l_cam.CFrame.LookVector
                    end)
                end
                
                clv = upp
            elseif (curturn == 'Down') then
                if (cambased) then
                    clvcon = l_cam:GetPropertyChangedSignal("CFrame"):Connect(function() 
                        normclv = l_cam.CFrame.LookVector
                    end)
                end
                
                clv = downp
            end
            
            
            
            
            if (curmod == 'Standard') then
                local base = l_humrp.CFrame
                
                
                if (cambased) then
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        local f,b = serv_uis:IsKeyDown(119), serv_uis:IsKeyDown(115)
                        
                        l_hum:ChangeState(1)
                        l_humrp.Velocity = nonep
                        
                        base += (l_hum.MoveDirection * dt * 3 * speed)
                        base += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        base += ((f and vec3(0, normclv.Y, 0) or nonep) - (b and vec3(0, normclv.Y, 0) or nonep)*(dt*3*speed))
                        
                        local b = base.Position
                        l_humrp.CFrame = cfn(b, b + clv)
                    end)
                else
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        
                        l_hum:ChangeState(1)
                        l_humrp.Velocity = nonep
                        
                        base += (l_hum.MoveDirection * dt * 3 * speed)
                        base += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        
                        local b = base.Position
                        l_humrp.CFrame = cfn(b, b + clv)
                    end)
                end
            elseif (curmod == 'Smooth') then
                local base = l_humrp.CFrame
                
                fi1 = inst("Part")
                fi1.CFrame = base
                fi1.Transparency = 0.8
                fi1.CanCollide = false
                fi1.CanTouch = false
                fi1.Anchored = false
                fi1.Size = vec3(1, 1, 1)
                fi1.Parent = workspace
                
                local pos = inst("BodyPosition")
                pos.Position = base.Position
                pos.D = 1900
                pos.P = 125000
                pos.MaxForce = vec3(9e9, 9e9, 9e9)
                pos.Parent = fi1
                local gyro = inst("BodyGyro")
                gyro.D = 1900
                gyro.P = 125000
                gyro.MaxTorque = vec3(9e9, 9e9, 9e9)
                gyro.Parent = fi1
                
                if (cambased) then
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        local f,b = serv_uis:IsKeyDown(119), serv_uis:IsKeyDown(115)
                        
                        l_hum:ChangeState(1)
                        l_humrp.Velocity = nonep
                        
                        base += (l_hum.MoveDirection * dt * 3 * speed)
                        base += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        base += ((f and vec3(0, normclv.Y, 0) or nonep) - (b and vec3(0, normclv.Y, 0) or nonep)*(dt*3*speed))
                        
                        local b = base.Position
                        
                        pos.Position = b
                        gyro.CFrame = cfn(b, b + clv)
                        
                        l_humrp.CFrame = fi1.CFrame 
                    end)
                else
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        
                        l_hum:ChangeState(1)
                        l_humrp.Velocity = nonep
                        
                        base += (l_hum.MoveDirection * dt * 3 * speed)
                        base += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        
                        local b = base.Position
                        pos.Position = b
                        gyro.CFrame = cfn(b, b + clv)
                        
                        l_humrp.CFrame = fi1.CFrame                     
                    end)
                end
            elseif (curmod == 'Vehicle') then
                local base = l_humrp.CFrame
                
                ratio(l_humrp.ChildAdded)
                ratio(l_humrp.DescendantAdded)
                
                fi1 = inst("BodyPosition")
                fi1.Position = base.Position
                fi1.D = 1900
                fi1.P = 125000
                fi1.MaxForce = vec3(9e9, 9e9, 9e9)
                fi1.Parent = l_humrp
                
                fi2 = inst("BodyGyro")
                fi2.D = 1900
                fi2.P = 125000
                fi2.MaxTorque = vec3(9e9, 9e9, 9e9)
                fi2.Parent = l_humrp
                
                cscon = l_cam:GetPropertyChangedSignal("CameraSubject"):Connect(function() 
                    l_cam.CameraSubject = l_hum
                end)
                
                if (cambased) then
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        local f,b = serv_uis:IsKeyDown(119), serv_uis:IsKeyDown(115)
                        
                        l_hum:ChangeState(1)
                        --l_humrp.Velocity = vec3(0,0,0)
                        
                        base += (l_hum.MoveDirection * dt * 3 * speed)
                        base += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        base += ((f and vec3(0, normclv.Y, 0) or nonep) - (b and vec3(0, normclv.Y, 0) or nonep)*(dt*3*speed))
                        
                        local b = base.Position
                        
                        fi1.Position = b
                        fi2.CFrame = cfn(b, b + clv)
                    end)
                else
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        
                        l_hum:ChangeState(1)
                        --l_humrp.Velocity = vec3(0,0,0)
                        
                        base += (l_hum.MoveDirection * dt * 3 * speed)
                        base += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        
                        local b = base.Position
                        fi1.Position = b
                        fi2.CFrame = cfn(b, b + clv)                   
                    end)
                end
            end
        end)
        
        m_flight:Connect("Disabled",function() 
            if (fcon) then fcon:Disconnect() fcon = nil end 
            if (clvcon) then clvcon:Disconnect() clvcon = nil end
            if (fi1) then fi1:Destroy() fi1 = nil end
            if (fi2) then fi2:Destroy() fi2 = nil end
            if (cscon) then cscon:Destroy() cscon = nil end 
            l_hum:ChangeState(8)
            
            unratio(l_humrp.Changed)
            unratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            unratio(l_humrp:GetPropertyChangedSignal("Velocity"))
            unratio(l_humrp.ChildAdded)
            unratio(l_humrp.DescendantAdded)
        end)
        
        
        ascend_h:SetTooltip('When pressed you vertically ascend (move up)'):SetHotkey(Enum.KeyCode.E)
        descend_h:SetTooltip('When pressed you vertically descend (move down)'):SetHotkey(Enum.KeyCode.Q)
        mode:SetTooltip('The method Flight uses')
        speedslider:SetTooltip('The speed of your flight')
        camera:SetTooltip('When enabled, the direction of your camera affects your Y movement. <b>Leaving this on is the typical option in every other flight script</b>')
        turndir:SetTooltip('The direction your character faces')
    end
    
    m_airjump:SetTooltip('Lets you jump in air, may bypass jump restrictions')
    m_blink:SetTooltip('Pseudo lagswitch. Doesn\'t actually choke packets. Raknet libraries (like Celery\'s) will be supported eventually')
    m_clicktp:SetTooltip('Standard clickteleport')
    m_fastfall:SetTooltip('Makes you instantly / near instantly fall down. Useful for bypassing fall damage in games like Natural Disaster Survival')
    m_flight:SetTooltip('Standard flight, comes with a few bypasses')
    m_float:SetTooltip('Makes you float')
    m_highjump:SetTooltip('Increases how high you jump')
    m_jesus:SetTooltip('Lets you walk on non-collidable parts')
    m_jetpack:SetTooltip('Like flight but more velocity based')
    m_noclip:SetTooltip('Standard noclip, comes with a few bypasses')
    m_noslow:SetTooltip('Prevents you from being slowed down')
    m_parkour:SetTooltip('Jumps when you reach the end of a part')
    m_phase:SetTooltip('Like TPbot, but for movement rather than combat')
    m_safewalk:SetTooltip('Prevents you from walking off of a part')
    m_speed:SetTooltip('Speedhacks with various bypasses and settings')
    m_spider:SetTooltip('Climbs you up parts you walk into')
    m_step:SetTooltip('Teleports you on top of parts you walk into')
    m_velocity:SetTooltip('Limits velocity or disables it')
end
local m_render = ui:CreateMenu('Render') do 
    
    local r_betterui    = m_render:AddMod('Better UI')
    local r_bread       = m_render:AddMod('Breadcrumbs')
    local r_camtweaks   = m_render:AddMod('Camera tweaks')
    local r_crosshair   = m_render:AddMod('Crosshair')
    local r_esp         = m_render:AddMod('ESP')
    local r_freecam     = m_render:AddMod('Freecam'..donetxt)
    local r_fullbright  = m_render:AddMod('Fullbright')
    local r_nametag     = m_render:AddMod('Nametags')
    local r_zoom        = m_render:AddMod('Zoom'..donetxt)
    
    -- Freecam
    do 
        -- Hotkeys
        local ascend_h = r_freecam:AddHotkey('Ascend key')
        local descend_h = r_freecam:AddHotkey('Descend key')
        -- Dropdowns
        local mode = r_freecam:AddDropdown('Method', true)
        local freezemode = r_freecam:AddDropdown('Freeze mode')
        -- sliders 
        local speedslider = r_freecam:AddSlider('Speed',{min=0,max=300,step=0.1,cur=30})
        -- buttons
        local gotocam = r_freecam:AddButton('Goto freecam')
        local resetcam = r_freecam:AddButton('Reset freecam position')
        -- toggles
        local camera = r_freecam:AddToggle('Camera-based')
        local resetonenable = r_freecam:AddToggle('Reset pos on enable')
        
        
        mode:AddOption('Standard'):SetTooltip('Standard freecam'):Select()
        mode:AddOption('Smooth'):SetTooltip('Just like Standard, but smooth')  
        mode:AddOption('Bypass'):SetTooltip('<b>Currently unfinished.</b> May bypass some anticheats / game mechanics that break freecam, but it\'s extremely janky')      
        freezemode:AddOption('Anchor'):SetTooltip('Anchors your character'):Select()
        freezemode:AddOption('Walkspeed'):SetTooltip('Sets your walkspeed to 0')
        freezemode:AddOption('Stuck'):SetTooltip('Constantly overwrites your position')
        
        local campart -- camera part
        local fcon -- flight connection
        
        local clvcon -- clv connection
        local cscon -- camera subject connection
        
        local ask = Enum.KeyCode.E-- keycode for ascension
        local dsk = Enum.KeyCode.Q-- keycode for descension
        
        local fcampos = l_humrp.Position        
        local speed = 30 -- speed 
        
        local cambased = true 
        camera:Enable()
        
        ascend_h:Connect("HotkeySet",function(j)ask=j or 0;end)
        descend_h:Connect("HotkeySet",function(k)dsk=k or 0;end)
        camera:Connect("Toggled",function(t)
            cambased=t;
            if (r_freecam:IsEnabled()) then 
                r_freecam:Disable()
                r_freecam:Enable() 
            end
        end)
        mode:Connect("SelectionChanged",function() 
            if (r_freecam:IsEnabled()) then 
                r_freecam:Disable()
                r_freecam:Enable() 
            end
        end)
        freezemode:Connect("SelectionChanged",function() 
            if (r_freecam:IsEnabled()) then 
                r_freecam:Disable()
                r_freecam:Enable() 
            end
        end)
        speedslider:Connect("ValueChanged",function(v)speed=v;end)
        
        local stuckcon, stuckcf, oldwalk
        
        r_freecam:Connect("Enabled", function()
            
            local curmod = mode:GetSelection()        
            local upp, downp, nonep = vec3(0, 1, 0), vec3(0, -1, 0), vec3(0,0,0)
            
            if (resetonenable:IsEnabled()) then
                fcampos = l_humrp.Position
            end
            
            local normclv = l_cam.CFrame.LookVector
            clvcon = l_cam:GetPropertyChangedSignal("CFrame"):Connect(function() 
                normclv = l_cam.CFrame.LookVector
            end)
            
            if (curmod == 'Standard') then
                campart = inst("Part")
                campart.Position = fcampos
                campart.Transparency = 1
                campart.CanCollide = false
                campart.CanTouch = false
                campart.Anchored = true
                campart.Size = vec3(1, 1, 1)
                campart.Parent = workspace  
                
                l_cam.CameraSubject = campart
                cscon = l_cam:GetPropertyChangedSignal("CameraSubject"):Connect(function() 
                    if (l_cam.CameraSubject ~= campart) then
                        l_cam.CameraSubject = campart
                    end
                end)
                
                if (cambased) then
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        local f,b = serv_uis:IsKeyDown(119), serv_uis:IsKeyDown(115)
                        
                        fcampos += (l_hum.MoveDirection * dt * 3 * speed)
                        fcampos += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        fcampos += ((f and vec3(0, normclv.Y, 0) or nonep) - (b and vec3(0, normclv.Y, 0) or nonep)*(dt*3*speed))
                        
                        campart.Position = fcampos
                    end)
                else
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        
                        fcampos += (l_hum.MoveDirection * dt * 3 * speed)
                        fcampos += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        
                        campart.Position = fcampos
                    end)
                end
            elseif (curmod == 'Smooth') then
                campart = inst("Part")
                campart.Position = fcampos
                campart.Transparency = 1
                campart.CanCollide = false
                campart.CanTouch = false
                campart.Anchored = true
                campart.Size = vec3(1, 1, 1)
                campart.Parent = workspace  
                
                l_cam.CameraSubject = campart
                cscon = l_cam:GetPropertyChangedSignal("CameraSubject"):Connect(function() 
                    if (l_cam.CameraSubject ~= campart) then
                        l_cam.CameraSubject = campart
                    end
                end)
                
                
                local pos = inst("BodyPosition")
                pos.Position = fcampos
                pos.D = 1900
                pos.P = 125000
                pos.MaxForce = vec3(9e9, 9e9, 9e9)
                pos.Parent = campart
                
                campart.Anchored = false
                
                if (cambased) then
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        local f,b = serv_uis:IsKeyDown(119), serv_uis:IsKeyDown(115)
                        
                        fcampos += (l_hum.MoveDirection * dt * 3 * speed)
                        fcampos += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        fcampos += ((f and vec3(0, normclv.Y, 0) or nonep) - (b and vec3(0, normclv.Y, 0) or nonep)*(dt*3*speed))
                        
                        pos.Position = fcampos
                    end)
                else
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        
                        fcampos += (l_hum.MoveDirection * dt * 3 * speed)
                        fcampos += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        
                        pos.Position = fcampos
                    end)
                end
            
            elseif (curmod == 'Bypass') then
                
                l_cam.CameraSubject = l_hum
                cscon = l_cam:GetPropertyChangedSignal("CameraSubject"):Connect(function() 
                    if (l_cam.CameraSubject ~= l_hum) then
                        l_cam.CameraSubject = l_hum
                    end
                end)
                
                if (cambased) then
                    local cf = cfn(l_humrp.Position, l_humrp.Position + vec3(0, 0, 1))
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        l_humrp.CFrame = cf
                        
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        local f,b = serv_uis:IsKeyDown(119), serv_uis:IsKeyDown(115)
                        
                        local movevec = (l_hum.MoveDirection * dt * 3 * speed)
                        local upvec = (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        local cupvec = ((f and vec3(0, normclv.Y, 0) or nonep) - (b and vec3(0, normclv.Y, 0) or nonep)*(dt*3*speed))
                        
                        fcampos += movevec
                        fcampos -= upvec
                        fcampos -= cupvec
                        
                        local normalized = cfn(fcampos):ToObjectSpace(cf)
                        
                        l_hum.CameraOffset = (normalized).Position
                    end)
                else
                    local cf = cfn(l_humrp.Position, l_humrp.Position + vec3(0, 0, 1))
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        l_humrp.CFrame = cf
                        
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        
                        local movevec = (l_hum.MoveDirection * dt * 3 * speed)
                        local upvec = (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        
                        fcampos += movevec
                        fcampos -= upvec
                        
                        local normalized = cfn(fcampos):ToObjectSpace(cf)
                        
                        l_hum.CameraOffset = (normalized).Position
                    end)
                end
            end
            
            local fmode = freezemode:GetSelection()
            
            
            if (fmode == 'Anchor') then
                l_humrp.Anchored = true
                
            elseif (fmode == 'Walkspeed') then
                oldwalk = l_hum.WalkSpeed
                l_hum.WalkSpeed = 0
                
            elseif (fmode == 'Stuck') then
                
                stuckcf = l_humrp.CFrame
                ratio(l_humrp.Changed)
                ratio(l_humrp:GetPropertyChangedSignal("CFrame"))
                stuckcon = serv_rs.Heartbeat:Connect(function() 
                    l_humrp.CFrame = stuckcf
                end)
            end
        end)
        
        r_freecam:Connect("Disabled",function() 
            
            if (fcon) then 
                fcon:Disconnect() 
                fcon = nil 
            end 
            if (clvcon) then 
                clvcon:Disconnect() 
                clvcon = nil 
            end
            if (campart) then 
                campart:Destroy() 
                campart = nil 
            end
            if (cscon) then 
                cscon:Disconnect() 
                cscon = nil 
            end
            
            l_cam.CameraSubject = l_hum
            l_hum.CameraOffset = vec3(0, 0, 0)
            
            if (l_humrp.Anchored == true) then
                l_humrp.Anchored = false
            
            elseif (l_hum.WalkSpeed == 0) then
                l_humrp.WalkSpeed = (oldwalk == 0 and 16 or oldwalk) -- Prevent getting infinitely stuck
            end
            if (stuckcon) then
                stuckcon:Disconnect()
                stuckcon = nil
                unratio(l_humrp.Changed)
                unratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            end
        end)
        
        gotocam:Connect("Clicked",function() 
            local pos = campart.Position
            local new = cfn(pos, pos+l_humrp.CFrame.LookVector)
            stuckcf = new
            l_humrp.CFrame = new
        end)
        
        resetcam:Connect("Clicked",function() 
            fcampos = l_humrp.Position
        end)
        
        ascend_h:SetTooltip('When pressed the freecam vertically ascends'):SetHotkey(Enum.KeyCode.E)
        camera:SetTooltip('When enabled, the direction of your camera affects your Y movement. <b>Leaving this on is the typical option in every other freecam script</b>')
        descend_h:SetTooltip('When pressed the freecam vertically descends'):SetHotkey(Enum.KeyCode.Q)
        mode:SetTooltip('The method Freecam uses')
        speedslider:SetTooltip('The speed of your freecam flight')
        freezemode:SetTooltip('The method used to make your character not move')
        gotocam:SetTooltip('Brings you to the camera')
        resetcam:SetTooltip('Resets the camera\'s position')
        resetonenable:SetTooltip('Resets the camera\'s position when Freecam gets enabled')
    end
    -- Esp
    do 
        --r_esp:AddSlider('')
    end
    -- Zoom
    do 
        local slider = r_zoom:AddSlider('Zoom amount',{min=0,max=150,cur=30,step=0.1}):SetTooltip('The amount to zoom in by')
                
        r_zoom:Connect("Toggled",function(t) 
            if (t) then
                l_cam.FieldOfView = 70-(slider:GetValue()*.5)
                slider:Connect("ValueChanged",function(v) 
                    l_cam.FieldOfView = 70-(v*.5)
                end)
            else
                slider:Connect("ValueChanged",nil)
                l_cam.FieldOfView = 70
            end
        end)

    end
    
	r_fullbright:SetTooltip('Fullbright with different presets for different games')
    r_betterui:SetTooltip("Improves existing Roblox UIs, like the chat and inventory")
    r_bread:SetTooltip('Leaves a trail behind')
    r_camtweaks:SetTooltip('Options for configuring the camera, like noclip-cam, maxzoom, smooth camera, etc. For 3rd person, use Game tweaks under Misc')
    r_crosshair:SetTooltip('Crosshair configuration')
    r_esp:SetTooltip('Configurable ESP')
    r_freecam:SetTooltip('Standard freecam')
    r_nametag:SetTooltip('Better nametags')
    r_zoom:SetTooltip('Like Optifine\'s zoom')
    
    
end
local m_ui = ui:CreateMenu('UI') do 
    local u_cmd = m_ui:AddMod('Command bar')
    local u_jeff = m_ui:AddMod('Jeff')
    local u_plr = m_ui:AddMod('Player notifications')
    
    -- jeff 
    do 
        local _
        u_jeff:Connect("Toggled", function(t) 
            if (t) then
                _ = inst("ImageLabel")
                _.Size = dim2off(250, 250)
                _.BackgroundTransparency = 1
                _.Position = dim2(1, -250, 1, 0)
                _.Image = "rbxassetid://8723094657"
                _.ResampleMode = 'Pixelated'
                _.Parent = ui:GetScreen()
                
                ctwn(_, {Position = dim2(1, -250, 1, -130)}, 25)
            else
                _:Destroy()
            end
            
        end)
    end
    -- plr
    do 
        local rfriends = u_plr:AddToggle('Roblox friends only'):SetTooltip('Only send notifications if they are your roblox friend')
        
        local join
        local leave 
        
        u_plr:Connect("Enabled",function() 
            join = serv_players.PlayerAdded:Connect(function(p) 
                if (l_plr:IsFriendsWith(p.UserId)) then
                    ui:Notify('Friend joined',p.Name..' has joined your server',2)
                else
                    if (not rfriends:IsEnabled()) then
                        ui:Notify('Player joined',p.Name..' has joined the server',2)
                    end
                end
            end)
            leave = serv_players.PlayerRemoving:Connect(function(p) 
                if (l_plr:IsFriendsWith(p.UserId)) then
                    ui:Notify('Friend left',p.Name..' has left your server',2)
                else
                    if (not rfriends:IsEnabled()) then
                        ui:Notify('Player left',p.Name..' has left the server',2)
                    end
                end
            end)
        end)
        u_plr:Connect("Disabled",function() 
            join:Disconnect()
            leave:Disconnect()
        end)
    end
    
    u_cmd:SetTooltip('Redline command bar. Quickly toggle modules, do quick actions like chatting and leaving, and more')
    u_jeff:SetTooltip('I forgot what this does')
    u_plr:SetTooltip('Get notifications when a player joins / leaves')
end
local m_server = ui:CreateMenu('Server') do 
    local s_rejoin = m_server:AddMod('Rejoin'..donetxt, 'Button')
    local s_shop = m_server:AddMod('Serverhop', 'Button')
    
    s_rejoin:Connect("Clicked",function() 
        if #serv_players:GetPlayers() <= 1 then
        	l_plr:Kick("\nRejoining, one second...")
        	wait(0.3)
        	serv_tp:Teleport(game.PlaceId, l_plr)
        else
        	serv_tp:TeleportToPlaceInstance(game.PlaceId, game.JobId, l_plr)
        end
    end)
    
    s_rejoin:SetTooltip('Rejoins you into the current server. <b>Don\'t swap too many times, or you\'ll get error 268</b>')
    s_shop:SetTooltip('Server hops. <b>Don\'t hop too many times, or you\'ll get error 268</b>')
end
local m_integrations = ui:CreateMenu('Integrations') do 
    local m_alt = m_integrations:AddMod('Alt manager')
    local m_rpc = m_integrations:AddMod('Discord RPC')
	
    m_alt:SetTooltip('Roblox Alt Manager integration. Requires the 3rd party Roblox Alt Manager program.')
    m_rpc:SetTooltip('Discord Rich Presence integration')
end
local m_search = ui:CreateMenu('Search') do 
    local _ = m_search:AddMod('Enter module name', 'Textbox')
    _:SetTooltip('Search for a module')
    _:Connect("Unfocused", function(t, t2)
        if (not t2) then return end 
        
        local mods = ui:GetModules()
        for i = 1, #mods do 
            local mod = mods[i]
            if (mod.setvis) then mod:setvis(true, false) end
        end
    end)
    
    _:Connect("TextChanged", function(t) 
        local mods = ui:GetModules()
        for i = 1, #mods do 
            local mod = mods[i]
            if (mod.Name:lower():match(t)) then
                if (mod.setvis) then 
                    mod:setvis(true, true) 
                end
            else
                if (mod.setvis) then 
                    mod:setvis(true, false) 
                end
            end
        end
    end)
end

_G.RLLoaded = true
ui:Notify('Redline loaded', 'Redline is now ready to use. Press RightShift to begin.', 5)
