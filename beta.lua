--[[
⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀      ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⡿⠀⢿⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⢸⠇⠀⠸⡇⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀  ⠀  ⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⢀⡿⠀⠀⠀⢿⡀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⣶⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦
  ⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⣸⠃⠀⠀⠀⠘⣇⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⣿⠀⠴⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣶⣤⣤⡀⠀⢀⣤⣤⣤⡀⠀⢠⣤⣦⣼⡏⢀⣤⣞⠁⠀⠀⠀⠀⠀⢀⡟⠀⠀⠀⠀⠀⢻⡀⠀⠀⠀⠀⠀⠈⣳⣤⡀⠀⠀⢸⡟⠀⣦⠀⣶⣦⣦⣄⠀⠀⣠⣤⣤⡀⠀⠀⠀⠀⠀⠀⠀✦
⠀⠀⠀⠀⠀⠀⠀⢸⡏⠀⠈⠛⠀⣼⡇⠀⢹⡇⠀⣿⠁⠀⣿⡇⠈⠛⢯⡙⠛⠶⠦⣤⣄⣼⡃⠀⠀⠀⠀⠀⢘⣧⣠⣤⠴⠶⠛⢋⡽⠛⠁⠀⠀⢸⡇⢸⡏⢀⣿⠁⠀⣿⠆⢸⡏⠀⢈⣿⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⣿⠟⠛⠛⠁⢸⣏⠀⠀⣿⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⢹⡏⠛⠓⠶⠚⠛⢹⡏⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⣿⠃⢸⡇⢸⡟⠀⠀⣿⠀⢾⡟⠛⠛⠁⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠾⠃⠀⠀⠀⠀⠘⠻⠾⠿⠂⠀⠙⠿⠿⠿⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⣷⠀⠀⠀⠀⠀⣾⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠿⠀⠿⠃⠸⠇⠀⠀⠟⠀⠈⠻⠷⠿⠆⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⢸⡆⠀⠀⠀⢰⡇⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀✦⠀⠀⠀  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢶⣷⠀⠀⠀⣾⡶⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢧⣀⡼⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀✦⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
]]--


--[[
★☆
]]--


---@diagnostic disable:undefined-global
---@diagnostic disable:undefined-field

if (_G.RLLoaded) then
    if (printconsole) then 
        printconsole("Already loaded Redline", 255, 64, 64)
        printconsole("Destroy the current script by pressing [End]", 192, 192, 255)
        return
    else
        warn("Already loaded Redline\nDestroy the current script by pressing [End]")
        return
    end
end

-- { The funny } --
pcall(function()
    -- Some shitter exploits error on this
    -- so im wrapping it in a pcall
    
    
    local inf = getinfo or debug.getinfo(2)
    if (inf) then
        if (inf.source ~= "redline is pretty epic") then
            warn("Looks like you're using an older version of Redline")
            warn("Check the github to get the newest script")
            return
        end
    end
end)


-- { Handle file system } --
if (not isfile('REDLINE')) then
    makefolder('REDLINE')
end

if (not isfile('REDLINE/config.json')) then
    --writefile('REDLINE/config.json', '')
end

local REDLINEVER = "v0.1.1"


-- { Wait for load } --
if not game:IsLoaded() then game.Loaded:Wait() end

-- { Microops } --

-- Services
local serv_ctx     = game:GetService('ContextActionService')
local serv_gui     = game:GetService('GuiService')
local serv_http    = game:GetService('HttpService')
local serv_net     = game:GetService("NetworkClient")
local serv_players = game:GetService('Players')
local serv_rs      = game:GetService('RunService')
local serv_tp      = game:GetService('TeleportService')
local serv_ts      = game:GetService('TweenService')
local serv_uis     = game:GetService('UserInputService')
local serv_vim     = game:GetService("VirtualInputManager")

-- Colors
local rgb,hsv,c3n = Color3.fromRGB, Color3.fromHSV, Color3.new
-- UDim2
local dim2off, dim2sca, dim2 = UDim2.fromOffset, UDim2.fromScale, UDim2.new
-- Instances
local inst = Instance.new
-- Vectors
local vec3, vec2 = Vector3.new, Vector2.new
-- CFrames
local cfn = CFrame.new
-- Task
local wait, delay, spawn = task.wait, task.delay, task.spawn
-- Math
local mr = math.random
local mf = math.floor
local mc = math.clamp
-- Utf8
local uc = utf8.char
-- Table
local ins,rem,cle = table.insert, table.remove, table.clear
-- Os
local date = os.date
local time = tick


local workspace = workspace
local ipairs = ipairs


-- { UI Colors } --
local colors = _G.RLTHEME or {} do 
    -- generic
    colors['outline']       = rgb(075, 075, 080); -- outline color
    colors['shadow']        = rgb(005, 005, 010); -- go figure
    colors['bg']            = rgb(023, 022, 027); -- window background
    colors['enabled']       = rgb(225, 035, 035); -- enabled
    -- backgrounds
    colors['bg_header']     = rgb(035, 035, 040); -- header background
    colors['bg_object']     = rgb(030, 030, 035); -- object background
    colors['bg_setting']    = rgb(025, 025, 030); -- setting background
    colors['bg_dropdown']   = rgb(020, 020, 025); -- dropdown background
    -- backgrounds selected
    colors['bg_header-b']   = rgb(038, 038, 043); -- header hovering
    colors['bg_object-b']   = rgb(033, 033, 038); -- object hovering
    colors['bg_setting-b']  = rgb(028, 028, 033); -- setting hovering
    colors['bg_dropdown-b'] = rgb(023, 023, 028); -- dropdown hovering
    -- slider
    colors['slider_fg']     = rgb(160, 160, 165); -- slider foreground
    colors['slider_bg']     = rgb(055, 055, 060); -- slider background
    colors['slider_head']   = rgb(130, 130, 135); -- slider head
    -- text
    colors['text1']         = rgb(255, 255, 255); -- main text
    colors['text2']         = rgb(170, 170, 255); -- sub text
    colors['text3']         = rgb(020, 020, 025); -- sub text
end

-- { UI functions / variables } --
local shadow,twn,ctwn,getnext,stroke,round,uierror
do
    shadow = function(parent)
        local _ = inst('ImageLabel')
        _.BackgroundTransparency  = 1
        _.ImageTransparency       = 0.5
        _.SliceScale              = 1.3
        _.Image                   = 'rbxassetid://7603818383'
        _.AnchorPoint             = vec2(0.5,0.5)
        _.ImageColor3             = colors['shadow']
        _.Position                = dim2sca(0.5, 0.5)
        _.Size                    = dim2(1, 20, 1, 20)
        _.SliceCenter             = Rect.new(15, 15, 175, 175)
        _.ScaleType               = 'Slice'
        _.ZIndex                  = parent.ZIndex - 1 
        _.Parent                  = parent
    
        return _
    end
    stroke = function(parent,inset) 
        local _ = inst('UIStroke')
        _.ApplyStrokeMode = 'Contextual'
        _.Thickness = 1
        _.Color = colors['outline']
        _.Transparency = 0
        if (inset) then
            parent.Size -= dim2off(1,1)
        end
        
        _.Parent = parent
        return _
    end
    
    local info1, info2 = TweenInfo.new(0.1,10,1), TweenInfo.new(0.2,10,1)
    function twn(twn_target, twn_settings, twn_long) 
        local tween = serv_ts:Create(
            twn_target,
            twn_long and info2 or info1,
            twn_settings
        )
        tween:Play()
        return tween
    end
    function ctwn(twn_target, twn_settings, twn_dur) 
        local tween = serv_ts:Create(
            twn_target,
            TweenInfo.new(twn_dur,10,1),
            twn_settings
        )
        tween:Play()
        return tween
    end
    function getnext() 
        local a = ''
        for i = 1, 5 do a = a .. uc(mr(50,2000)) end 
        return a 
    end
    function round(num, place) 
        return mf(((num+(place*.5)) / place)) * place
    end
    function uierror(func, prop, type) 
        error(('%s failed; %s is not of type %s'):format(func,prop,type), 3)
    end
end



local W_WindowOpen = false
-- { UI } --
local ui = {} do 
    
    local ui_Hotkeys = {}
    local ui_Connections = {}
    local ui_Menus = {}
    local ui_Modules = {}
    
    local rgbinsts = {}
    
    local monitor_resolution = serv_gui:GetScreenResolution()
    local monitor_inset = serv_gui:GetGuiInset()
    
    -- connections
    ui_Connections['i'] = serv_uis.InputBegan:Connect(function(io, gpe) 
        if (gpe) then return end
        if (io.UserInputType.Value == 8) then
            local kcv = io.KeyCode.Value
            for i = 1, #ui_Hotkeys do 
                local hk = ui_Hotkeys[i]
                if (hk[1] == kcv) then
                    hk[2]()
                end
            end
        end
    end)
    do
        local _ = 0
        local __ = hsv
        
        ui_Connections['r'] = serv_rs.RenderStepped:Connect(function(___) 
            _ = (_ > 1 and 0 or _)+(___*.05)
            ___ = __(_,.9,1)
            for i = 1, #rgbinsts do 
                local v = rgbinsts[i]
                v[1][v[2]] = ___
            end
        end)
    end
    
    -- Gui creation
    local w_Screen
     local w_TooltipHeader
      local w_Tooltip
    local w_Backframe
     local w_Help
     local w_Modal
    local w_ModList
     local w_ModListLayout
     local w_ModListTitle
    
    
    do 
        w_Screen = inst('ScreenGui')
        w_Screen.IgnoreGuiInset = true
        w_Screen.ZIndexBehavior = Enum.ZIndexBehavior.Global
        w_Screen.Name = getnext()
        pcall(function() 
            syn.protect_gui(w_Screen)
        end)
        w_Screen.DisplayOrder = 939393
        w_Screen.Parent = (gethui and gethui()) or (get_hidden_gui and get_hidden_gui()) or game.CoreGui
        
        
        w_Backframe = inst('Frame')
        w_Backframe.BackgroundColor3 = colors['bg']
        w_Backframe.BackgroundTransparency = 0.3
        w_Backframe.BorderSizePixel = 0
        w_Backframe.ClipsDescendants = false
        w_Backframe.Size = dim2sca(1,1)
        w_Backframe.Visible = false
        w_Backframe.Parent = w_Screen
        
        w_Modal = inst('TextButton')
        w_Modal.Active = false
        w_Modal.BackgroundTransparency = 1
        w_Modal.Modal = true
        w_Modal.Parent = w_Backframe
        w_Modal.Size = dim2off(1,1)
        w_Modal.Text = ''
        
        w_Help = inst("TextLabel")
        w_Help.AnchorPoint = vec2(1,1)
        w_Help.BackgroundTransparency = 1
        w_Help.Font = 'SourceSans'
        w_Help.Position = dim2sca(1,1)
        w_Help.RichText = true
        w_Help.Size = dim2off(300,300)
        w_Help.Text = ""
        w_Help.TextColor3 = colors['text1']
        w_Help.TextSize = 20
        w_Help.TextStrokeColor3 = colors['text3']
        w_Help.TextStrokeTransparency = 0
        w_Help.TextXAlignment = 'Left'
        w_Help.TextYAlignment = 'Top'
        w_Help.Visible = false
        w_Help.ZIndex = 1
        w_Help.Parent = w_Backframe
        
        local w_Icon = inst("ImageLabel")
        w_Icon.Image = "rbxassetid://8677436980"
        w_Icon.Size = dim2off(256, 256)
        w_Icon.Position = dim2off(0, -64)
        w_Icon.BackgroundTransparency = 1
        w_Icon.ZIndex = 500
        w_Icon.Parent = w_Backframe
        
        w_ModList = inst('Frame')
        w_ModList.Size = dim2(0,200,0.3,0)
        w_ModList.Position = dim2sca(0,1)
        w_ModList.AnchorPoint = vec2(0, 1)
        w_ModList.BackgroundTransparency = 1
        w_ModList.BackgroundColor3 = colors['bg']
        w_ModList.BorderSizePixel = 1
        w_ModList.BorderMode = 'Inset'
        w_ModList.BorderColor3 = colors['outline']
        w_ModList.Parent = w_Screen
        
        w_ModListLayout = inst('UIListLayout')
        w_ModListLayout.FillDirection = 'Vertical'
        w_ModListLayout.HorizontalAlignment = 'Left'
        w_ModListLayout.VerticalAlignment = 'Bottom'
        w_ModListLayout.Parent = w_ModList
        
        w_ModListTitle = inst("TextLabel")
        w_ModListTitle.Size = dim2(1, 0, 0, 30)
        w_ModListTitle.BackgroundTransparency = 1
        w_ModListTitle.Font = 'SourceSans'
        w_ModListTitle.TextColor3 = colors['enabled']
        w_ModListTitle.TextXAlignment = 'Left'
        w_ModListTitle.TextColor3 = colors['text1']
        w_ModListTitle.TextSize = 24
        w_ModListTitle.Text = " Redline "..REDLINEVER
        w_ModListTitle.LayoutOrder = 939
        w_ModListTitle.TextStrokeTransparency = 0
        w_ModListTitle.TextStrokeColor3 = colors['text3']
        w_ModListTitle.ZIndex = 5
        w_ModListTitle.Parent = w_ModList
        
        w_TooltipHeader = inst("TextLabel")
        w_TooltipHeader.BackgroundColor3 = colors['bg_header']
        w_TooltipHeader.BackgroundTransparency = 0
        w_TooltipHeader.BorderColor3 = colors['outline']
        w_TooltipHeader.BorderMode = 'Inset'
        w_TooltipHeader.BorderSizePixel = 1
        w_TooltipHeader.Font = 'SourceSans'
        w_TooltipHeader.RichText = true
        w_TooltipHeader.Size = dim2off(175,20)
        w_TooltipHeader.Text = "Hi"
        w_TooltipHeader.TextColor3 = colors['text1']
        w_TooltipHeader.TextSize = 19
        w_TooltipHeader.TextStrokeColor3 = colors['text3']
        w_TooltipHeader.TextStrokeTransparency = 0
        w_TooltipHeader.TextXAlignment = 'Center'
        w_TooltipHeader.Visible = false 
        w_TooltipHeader.ZIndex = 1500
        w_TooltipHeader.Parent = w_Screen
        
        w_Tooltip = inst("TextLabel")
        w_Tooltip.BackgroundColor3 = colors['bg']
        w_Tooltip.BackgroundTransparency = 0.2
        w_Tooltip.BorderColor3 = colors['outline']
        w_Tooltip.BorderMode = 'Inset'
        w_Tooltip.BorderSizePixel = 1
        w_Tooltip.Font = 'SourceSans'
        w_Tooltip.Position = dim2off(-1, 18)
        w_Tooltip.RichText = true
        w_Tooltip.Size = dim2off(175,25)
        w_Tooltip.Text = ""
        w_Tooltip.TextColor3 = colors['text1']
        w_Tooltip.TextSize = 17
        w_Tooltip.TextStrokeColor3 = colors['text3']
        w_Tooltip.TextStrokeTransparency = 0
        w_Tooltip.TextWrapped = true
        w_Tooltip.TextXAlignment = 'Left'
        w_Tooltip.TextYAlignment = 'Top'
        w_Tooltip.Visible = true 
        w_Tooltip.ZIndex = 1500
        w_Tooltip.Parent = w_TooltipHeader
        
        local __ = inst("UIPadding")
        __.PaddingLeft = dim2off(5, 0).X
        --__.PaddingTop = dim2off(0, 5).Y
        __.Parent = w_Tooltip
        
        w_Tooltip:GetPropertyChangedSignal("Text"):Connect(function() 
            w_Tooltip.Size = dim2off(175,25)
            local n = dim2off(0,5)
            for i = 1, 25 do 
                w_Tooltip.Size += n
                if (w_Tooltip.TextFits) then break end
            end
            
        end)
    end
    
    ui_Connections['t'] = serv_rs.RenderStepped:Connect(function() 
        local pos = serv_uis:GetMouseLocation()
        w_TooltipHeader.Position = dim2off(pos.X+15, pos.Y+15)
    end)
    
    
    local ModListEnable,ModListDisable,ModListInit,ModListModify do 
        local mods_instance = {}
        
        
        ModListEnable = function(name) 
            local b = mods_instance[name]
            
            b.Parent = w_ModList
            twn(b.P, {PaddingLeft = dim2off(8, 0).X},true)
            twn(b, {Size = dim2(1, 0, 0, 24), TextTransparency = 0, TextStrokeTransparency = 0},true)
        end
        
        ModListDisable = function(name)
            local b = mods_instance[name]
            
            twn(b.P, {PaddingLeft = dim2off(-100, 0).X},true)
            twn(b, {Size = dim2(0, 0, 0, 0), TextTransparency = 1, TextStrokeTransparency = 1},true)
        end
        
        ModListModify = function(name, new) 
            mods_instance[name].Text = new
        end
        
        ModListInit = function(name) 
            local _ = inst("TextLabel")
            _.Size = dim2(0, 0, 0, 0)
            _.BackgroundTransparency = 1
            _.Font = 'SourceSans'
            _.TextXAlignment = 'Left'
            _.TextColor3 = colors['text1']
            _.TextSize = 22
            _.Text = name
            --_.Name = name
            _.RichText = true
            _.TextTransparency = 1
            _.TextStrokeTransparency = 1
            _.TextStrokeColor3 = colors['text3']
            _.ZIndex = 5
            
            mods_instance[name] = _
            
            ins(rgbinsts, {_,"TextColor3"})
            
            
            local __ = inst("UIPadding")
            __.Name = 'P'
            __.PaddingLeft = dim2off(-100, 0).X
            __.Parent = _
        end
    end
    
    -- Base class for stuff
    local base_class = {} do 
        local s1,s2 = dim2(1,0,1,0), dim2(0,0,1,0)
        
        
        
        -- objtype_action_actiontype
        
        -- Menu funcs
        do
            base_class.menu_toggle = function(self) 
                local t = not self.MToggled
                
                self.MToggled = t
                self.Menu.Visible = t
                
                twn(self.Icon, {Rotation = t and 0 or 180}, true)
            end
                base_class.menu_getstate = function(self) 
                return self.MToggled
            end
        end
        -- Module funcs
        do
            base_class.module_toggle_menu = function(self) 
                local t = not self.MToggled
                
                self.MToggled = t
                self.Menu.Visible = t
                
                twn(self.Icon, {Rotation = t and 360 or 0}, true)
                self.Icon.Text = t and '-' or '+'
            end
            base_class.module_toggle_self = function(self) 
                local t = not self.OToggled
                self.OToggled = t
                
                
                pcall(self.Flags.Toggled, t)
                pcall(self.Flags[t and 'Enabled' or 'Disabled'])
                
                twn(self.Effect, {Size = t and s1 or s2}, true)
                
                if (t) then
                    ModListEnable(self.Name)
                else
                    ModListDisable(self.Name)
                end
                return self 
            end
            base_class.module_toggle_enable = function(self) 
                self.OToggled = true
                
                pcall(self.Flags.Toggled, true)
                pcall(self.Flags.Enabled)
                
                twn(self.Effect, {Size = s1}, true)
                
                ModListEnable(self.Name)
                return self 
            end
            base_class.module_toggle_disable = function(self) 
                self.OToggled = false
                
                pcall(self.Flags.Toggled, false)
                pcall(self.Flags.Disabled)
                
                twn(self.Effect, {Size = s2}, true)
                
                ModListDisable(self.Name)
                return self
            end
            base_class.module_getstate_self = function(self) return self.OToggled end
            base_class.module_getstate_menu = function(self) return self.MToggled end
            
            base_class.module_setvis = function(self, t, t2) 
                self.Root.Visible = t 
                self.Highlight.Visible = t2
            end 
            
            base_class.module_click_self = function(self) 
                pcall(self.Flags.Clicked)
                
                self.Effect.BackgroundTransparency = 0.8
                twn(self.Effect, {BackgroundTransparency = 1}, true)
            end
            base_class.module_gettext = function(self) 
                return self.Text
            end
            
        end
        
        -- Setting funcs
        do
            base_class.setting_toggle_self = function(self) 
                local t = not self.Toggled
                
                pcall(self.Flags.Toggled, t)
                pcall(self.Flags.Enabled)
                pcall(self.Flags.Disabled)
                
                self.Toggled = t
                twn(self.Icon, {BackgroundTransparency = t and 0 or 1})
                return self
            end 
            base_class.setting_toggle_enable = function(self) 
                self.Toggled = true
                
                pcall(self.Flags.Toggled, true)
                pcall(self.Flags.Enabled)
                
                twn(self.Icon, {BackgroundTransparency = 0})
                return self
            end 
            base_class.setting_toggle_disable = function(self) 
                self.Toggled = false
                
                pcall(self.Flags.Toggled, false)
                pcall(self.Flags.Disabled)
                
                twn(self.Icon, {BackgroundTransparency = 1})
                return self
            end 
            base_class.setting_toggle_getstate = function(self) 
                return self.Toggled
            end
            
            base_class.setting_modhotkey_sethotkey = function(self) 
                local label = self.Label
                label.Text = "Press any key..."
                
                wait(0.01);
                local c;
                c = serv_uis.InputBegan:Connect(function(io,gpe)
                    
                    local kcv = io.KeyCode.Value
                    if (kcv ~= 0) then
                        
                        self.Hotkey = kcv
                        label.Text = "Hotkey: "..io.KeyCode.Name
                        
                        -- As scuffed as this is, it works
                        -- To prevent the module being bound from immediately toggling, a short delay is made
                        delay(0.01, function()
                            local n = self.Parent.Name
                            for i = 1, #ui_Hotkeys do 
                                if ui_Hotkeys[i][3] == n then
                                    rem(ui_Hotkeys, i)
                                    break
                                end
                            end
                            ins(ui_Hotkeys, {kcv, function() 
                                self.Parent:Toggle()
                            end, n})
                        end)
                    else
                        self.Hotkey = nil    
                        label.Text = "Hotkey: N/A"
                        
                        local n = self.Parent.Name
                        for i = 1, #ui_Hotkeys do 
                            if ui_Hotkeys[i][3] == n then
                                rem(ui_Hotkeys, i)
                                break
                            end
                        end
                    end
                    c:Disconnect()
                end)
                
            end
        
            base_class.setting_modhotkey_gethotkey = function(self) 
                return self.Hotkey
            end
            
            base_class.setting_hotkey_sethotkey = function(self) 
                local label = self.Label
                label.Text = "Press any key..."
                
                wait(0.01);
                local c;
                c = serv_uis.InputBegan:Connect(function(io,gpe)
                    local kc = io.KeyCode
                    local kcv = kc.Value
                    if (kcv ~= 0) then
                        
                        self.Hotkey = kc
                        label.Text = self.Name..": "..kc.Name
                        
                        pcall(self.Flags.HotkeySet, kc, kcv)
                    else
                        self.Hotkey = nil    
                        label.Text = self.Name..": N/A"
                        
                        pcall(self.Flags.HotkeySet, nil, 0)
                    end
                    c:Disconnect()
                end)
            end
            
            base_class.setting_hotkey_sethotkeyexplicit = function(self, kc) 
                self.Hotkey = kc
                self.Label.Text = self.Name..": "..kc.Name
                return self
            end
            
            base_class.setting_hotkey_gethotkey = function(self)
                return self.Hotkey
            end
            
            
            base_class.setting_dropdown_getselection = function(self) 
                return self.Selection
            end
            
            base_class.setting_ddoption_select_self = function(self) 
                local parent = self.Parent
                
                local objs = parent.Objects
                for i = 1, #objs do objs[i]:Deselect() end
                
                self.Selected = true
                parent.Selection = self.Name
                pcall(parent.Flags.SelectionChanged, self.Name, self)
                
                if (parent.Primary) then
                    
                    local n = parent.Parent.Name 
                    ModListModify(n, n .. " <font color='#DFDFDF'>["..self.Name.."]</font>")
                end
                
                twn(self.Effect, {Size = s1}, true)
                
                return self
            end
            base_class.setting_ddoption_deselect_self = function(self) 
                if (self.Selected) then 
                    self.Selected = false
                    twn(self.Effect, {Size = s2}, true)
                end
                
                return self
            end
            base_class.setting_ddoption_selected_getstate = function(self) 
                return self.Selected
            end
            
            base_class.setting_slider_getval = function(self) return self.CurrentVal end
            base_class.setting_slider_setvalnum = function(self, nval) 
                local min = self.Min
                local cval = self.CurrentVal
                local pval = self.PreviousVal

                
                cval = round(mc(nval, min, self.Max), self.Step)
                
                if (pval ~= cval) then
                    pval = cval
                    
                    self.SliderFill.Position = dim2off(mf((cval - min) * self.Ratio), 0)
                    self.SliderAmnt.Text = self.StepFormat:format(cval)
                    
                    pcall(self.Flags.ValueChanged, cval)
                end
                
                self.CurrentVal = cval
            end
            base_class.setting_slider_setvalpos = function(self, xval) 
                local min = self.Min
                local cval = self.CurrentVal
                local pval = self.PreviousVal
                
                local pos_normalized = mc(xval - self.SliderBg.AbsolutePosition.X, 0, self.SliderSize)
                
                cval = round((pos_normalized * self.RatioInverse)+min, self.Step)
                
                if (pval ~= cval) then
                    pval = cval
                    self.SliderFill.Position = dim2off(mf((cval - min)*self.Ratio), 0)
                    self.SliderAmnt.Text = self.StepFormat:format(cval)
                    
                    self.CurrentVal = cval
                    
                    pcall(self.Flags.ValueChanged, cval)
                end
            end
        end
        
        -- Button funcs
        base_class.button_click = function(self) 
            pcall(self.Flags['Clicked'])
        end
        
        -- Slider funcs
        base_class.slider_setval = function(self, value) 
            value = tonumber(value)
            if not value then uierror('slider_setval','value','number') end
            
            local m1,m2,m3 = self.min, self.max, self.step
            value = mc(round(value, m3),m1,m2)
            
            self.setval_internal(value)
        end
        base_class.slider_getval = function(self) 
            return self.value1
        end
        
        -- Input funcs
        base_class.input_gettxt = function(self) 
            return self.Text
        end
        
        -- Generic funcs
        
        ---@param self table
        ---@param tooltip string
        ---@return table
        base_class.generic_tooltip = function(self, tooltip) 
            if (tooltip) then
                self.Tooltip = tostring(tooltip)    
            else
                self.Tooltip = nil
            end
            return self 
        end
        base_class.generic_connect = function(self, flagname, func) 
            if (type(func) ~= 'function' and type(func) ~= 'nil') then
                uierror('generic_connect','func','function or type nil')
            end
            if (type(flagname) ~= 'string') then
                uierror('generic_connect','flagname','string')
            end
            
            self.Flags[flagname] = func
            return self 
        end
        
        -- Creation functions
        base_class.menu_create_module = function(self, text, Type, nohotkey) 
            Type = Type or 'Toggle'
            local M_IndexOffset = self.ZIndex+1
            
            if (Type == 'Toggle') then 
                ModListInit(text)
                
                
                
                
                local m_ModuleRoot
                 local m_ModuleBackground
                  local m_ModuleEnableEffect
                   local m_ModuleEnableEffect2
                  local m_Highlight
                  local m_ModuleText
                  local m_ModuleIcon
                 local m_Menu
                  local m_MenuListLayout
                
                do
                    m_ModuleRoot = inst("ImageButton")
                    m_ModuleRoot.Size = dim2(1, 0, 0, 25)
                    m_ModuleRoot.AutomaticSize = "Y"
                    m_ModuleRoot.ClipsDescendants = false
                    m_ModuleRoot.BackgroundTransparency = 1
                    m_ModuleRoot.BorderSizePixel = 0
                    m_ModuleRoot.ZIndex = M_IndexOffset-1
                    m_ModuleRoot.Parent = self.Menu
                    
                     m_ModuleBackground = inst("Frame")
                     m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                     m_ModuleBackground.BorderSizePixel = 0
                     m_ModuleBackground.Size = dim2(1,0,0,25)
                     m_ModuleBackground.ZIndex = M_IndexOffset
                     m_ModuleBackground.Parent = m_ModuleRoot
                     
                      m_Highlight = inst("Frame")
                      m_Highlight.Active = false
                      m_Highlight.BackgroundColor3 = colors['enabled']
                      m_Highlight.BackgroundTransparency = 0.7
                      m_Highlight.BorderSizePixel = 0
                      m_Highlight.Size = dim2sca(1,1)
                      m_Highlight.Visible = false
                      m_Highlight.ZIndex = M_IndexOffset
                      m_Highlight.Parent = m_ModuleBackground
                      
                      m_ModuleEnableEffect = inst("Frame")
                      m_ModuleEnableEffect.BackgroundColor3 = colors['text1']
                      m_ModuleEnableEffect.BackgroundTransparency = 0.92
                      m_ModuleEnableEffect.BorderSizePixel = 0
                      m_ModuleEnableEffect.ClipsDescendants = true
                      m_ModuleEnableEffect.Size = dim2(0,0,1,0)
                      m_ModuleEnableEffect.ZIndex = M_IndexOffset
                      m_ModuleEnableEffect.Parent = m_ModuleBackground
                      
                       m_ModuleEnableEffect2 = inst("Frame")
                       m_ModuleEnableEffect2.BackgroundColor3 = colors['enabled']
                       m_ModuleEnableEffect2.BorderSizePixel = 0
                       m_ModuleEnableEffect2.Size = dim2(0,2,1,0)
                       m_ModuleEnableEffect2.ZIndex = M_IndexOffset
                       m_ModuleEnableEffect2.Parent = m_ModuleEnableEffect
                      
                      m_ModuleText = inst('TextLabel')
                      m_ModuleText.BackgroundTransparency = 1
                      m_ModuleText.Font = 'SourceSans'
                      m_ModuleText.Position = dim2off(5, 0)
                      m_ModuleText.RichText = true
                      m_ModuleText.Size = dim2(1, -5, 1, 0)
                      m_ModuleText.Text = text
                      m_ModuleText.TextColor3 = colors['text1']
                      m_ModuleText.TextSize = 20
                      m_ModuleText.TextStrokeColor3 = colors['text3']
                      m_ModuleText.TextStrokeTransparency = 0
                      m_ModuleText.TextXAlignment = 'Left'
                      m_ModuleText.ZIndex = M_IndexOffset
                      m_ModuleText.Parent = m_ModuleBackground
                      
                      m_ModuleIcon = inst('TextLabel')
                      m_ModuleIcon.AnchorPoint = vec2(1,0)
                      m_ModuleIcon.BackgroundTransparency = 1
                      m_ModuleIcon.Font = 'SourceSans'
                      m_ModuleIcon.Position = dim2sca(1,0)
                      m_ModuleIcon.Rotation = 0
                      m_ModuleIcon.Size = dim2off(25, 25)
                      m_ModuleIcon.Text = '+'
                      m_ModuleIcon.TextColor3 = colors['text1']
                      m_ModuleIcon.TextSize = 18
                      m_ModuleIcon.TextStrokeColor3 = colors['text3']
                      m_ModuleIcon.TextStrokeTransparency = 0
                      m_ModuleIcon.TextXAlignment = 'Center'
                      m_ModuleIcon.ZIndex = M_IndexOffset
                      m_ModuleIcon.Parent = m_ModuleBackground
                    
                    m_Menu = inst('Frame')
                    m_Menu.Size = dim2(1,0,0,0)
                    m_Menu.Position = dim2off(0,25)
                    m_Menu.BackgroundColor3 = colors['bg_setting']
                    m_Menu.BorderSizePixel = 0
                    m_Menu.ZIndex = M_IndexOffset-1
                    m_Menu.Visible = false
                    m_Menu.Parent = m_ModuleRoot
                    
                     m_MenuListLayout = inst('UIListLayout')
                     m_MenuListLayout.FillDirection = 'Vertical'
                     m_MenuListLayout.SortOrder = 2
                     m_MenuListLayout.HorizontalAlignment = 'Left'
                     m_MenuListLayout.VerticalAlignment = 'Top'
                     m_MenuListLayout.Parent = m_Menu
                     
                end
                    
                local M_Object = {} do 
                    M_Object.Tooltip = nil
                    
                    M_Object.MToggled = false
                    M_Object.OToggled = false
                    
                    M_Object.Flags = {} do 
                        M_Object.Flags['Enabled'] = true
                        M_Object.Flags['Disabled'] = true
                        M_Object.Flags['Toggled'] = true
                    end
                    
                    M_Object.Name = text
                    M_Object.Menu = m_Menu
                    M_Object.Icon = m_ModuleIcon
                    M_Object.Effect = m_ModuleEnableEffect
                    M_Object.ZIndex = M_IndexOffset
                    
                    M_Object.Highlight = m_Highlight
                    
                    M_Object.Parent = self
                    M_Object.Root = m_ModuleRoot
                    
                    M_Object.AddToggle = base_class.module_create_toggle
                    M_Object.AddLabel = base_class.module_create_label
                    M_Object.AddDropdown = base_class.module_create_dropdown
                    M_Object.AddModHotkey = base_class.module_create_modhotkey
                    M_Object.AddHotkey = base_class.module_create_hotkey
                    M_Object.AddSlider = base_class.module_create_slider
                    M_Object.AddInput = base_class.module_create_input
                    M_Object.AddButton = base_class.module_create_button
                    
                    M_Object.setvis = base_class.module_setvis
                    
                    M_Object.Toggle = base_class.module_toggle_self
                    M_Object.Disable = base_class.module_toggle_disable
                    M_Object.Enable = base_class.module_toggle_enable
                    
                    M_Object.ToggleMenu = base_class.module_toggle_menu
                    M_Object.GetState = base_class.module_getstate_self
                    M_Object.IsEnabled = base_class.module_getstate_self
                    M_Object.GetMenuState = base_class.module_getstate_menu
                    
                    M_Object.Connect = base_class.generic_connect
                    M_Object.SetTooltip = base_class.generic_tooltip
                end
                
                do
                    m_ModuleBackground.InputBegan:Connect(function(io) 
                        local uitv = io.UserInputType.Value
                        if (uitv == 0) then
                            M_Object:Toggle()
                            return
                        end
                        
                        if (uitv == 1) then
                            M_Object:ToggleMenu()
                            return
                        end
                    end)
                    
                    m_ModuleBackground.MouseEnter:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object-b']
                        
                        
                        local tt = M_Object.Tooltip
                        if (tt) then
                            w_Tooltip.Text = tt
                            w_TooltipHeader.Text = M_Object.Name
                            w_TooltipHeader.Visible = true
                        end
                    end)
                    
                    m_ModuleBackground.MouseLeave:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                        
                        if (w_Tooltip.Text == M_Object.Tooltip) then
                            w_TooltipHeader.Visible = false
                        end
                    end)
                end
                
                if (not nohotkey) then M_Object:AddModHotkey() end
                
                ins(ui_Modules, M_Object)
                return M_Object
            elseif (Type == 'Textbox') then
                local m_ModuleRoot
                 local m_ModuleBackground
                 local m_ModuleEnableEffect
                  local m_ModuleText
                   local m_ModulePadding
                  local m_ModuleIcon

                do
                    m_ModuleRoot = inst("Frame")
                    m_ModuleRoot.Size = dim2(1, 0, 0, 25)
                    m_ModuleRoot.AutomaticSize = "Y"
                    m_ModuleRoot.BackgroundTransparency = 1
                    m_ModuleRoot.BorderSizePixel = 0
                    m_ModuleRoot.ZIndex = M_IndexOffset-1
                    m_ModuleRoot.Parent = self.Menu
                    
                     m_ModuleBackground = inst("Frame")
                     m_ModuleBackground.Size = dim2(1,0,0,25)
                     m_ModuleBackground.BorderSizePixel = 0
                     m_ModuleBackground.ZIndex = M_IndexOffset
                     m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                     m_ModuleBackground.Parent = m_ModuleRoot
                     
                      m_ModuleEnableEffect = inst("Frame")
                      m_ModuleEnableEffect.BackgroundColor3 = colors['text1']
                      m_ModuleEnableEffect.BackgroundTransparency = 1
                      m_ModuleEnableEffect.ClipsDescendants = true
                      m_ModuleEnableEffect.Size = dim2(1,0,1,0)
                      m_ModuleEnableEffect.BorderSizePixel = 0
                      m_ModuleEnableEffect.ZIndex = M_IndexOffset
                      m_ModuleEnableEffect.Parent = m_ModuleBackground
                     
                     m_ModuleText = inst('TextBox')
                     m_ModuleText.Size = dim2(1, 0, 1, 0)
                     m_ModuleText.Position = dim2off(0, 0)
                     m_ModuleText.ClearTextOnFocus = true
                     m_ModuleText.TextWrapped = true
                     m_ModuleText.BackgroundTransparency = 1
                     m_ModuleText.Font = 'SourceSans'
                     m_ModuleText.TextXAlignment = 'Left'
                     m_ModuleText.TextColor3 = colors['text1']
                     m_ModuleText.TextSize = 20
                     m_ModuleText.Text = text
                     m_ModuleText.TextStrokeTransparency = 0
                     m_ModuleText.TextStrokeColor3 = colors['text3']
                     m_ModuleText.ZIndex = M_IndexOffset
                     m_ModuleText.Parent = m_ModuleBackground
                      
                      m_ModulePadding = inst("UIPadding")
                      m_ModulePadding.PaddingLeft = dim2off(5, 0).X
                      m_ModulePadding.Parent = m_ModuleText
                     
                     m_ModuleIcon = inst('TextLabel')
                     m_ModuleIcon.Size = dim2off(25, 25)
                     m_ModuleIcon.Position = dim2sca(1,0)
                     m_ModuleIcon.AnchorPoint = vec2(1,0)
                     m_ModuleIcon.BackgroundTransparency = 1
                     m_ModuleIcon.Font = 'SourceSans'
                     m_ModuleIcon.TextXAlignment = 'Center'
                     m_ModuleIcon.TextColor3 = colors['text1']
                     m_ModuleIcon.TextSize = 18
                     m_ModuleIcon.Text = '🅃'
                     m_ModuleIcon.TextStrokeTransparency = 0
                     m_ModuleIcon.TextStrokeColor3 = colors['text3']
                     m_ModuleIcon.Rotation = 0
                     m_ModuleIcon.ZIndex = M_IndexOffset
                     m_ModuleIcon.Parent = m_ModuleBackground
                end
                    
                local M_Object = {} do 
                    M_Object.Tooltip = nil
                    
                    
                    M_Object.Flags = {} do 
                        M_Object.Flags['Focused'] = true
                        M_Object.Flags['Unfocused'] = true
                        M_Object.Flags['TextChanged'] = true
                    end
                    
                    M_Object.Effect = m_ModuleEnableEffect
                    
                    M_Object.Name = text
                    M_Object.ZIndex = M_IndexOffset
                                        
                    M_Object.Connect = base_class.generic_connect
                    M_Object.SetTooltip = base_class.generic_tooltip
                end
                
                do
                    m_ModuleBackground.MouseEnter:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object-b']
                        
                        
                        local tt = M_Object.Tooltip
                        if (tt) then
                            w_Tooltip.Text = tt
                            w_TooltipHeader.Text = M_Object.Name
                            w_TooltipHeader.Visible = true
                        end
                    end)
                    
                    m_ModuleBackground.MouseLeave:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                        
                        if (w_Tooltip.Text == M_Object.Tooltip) then
                            w_TooltipHeader.Visible = false
                        end
                    end)
                    
                    m_ModuleText.FocusLost:Connect(function(enter) 
                        pcall(M_Object.Flags.Unfocused, m_ModuleText.Text, enter)
                        m_ModuleText.Text = M_Object.Name
                    end)
                    m_ModuleText.Focused:Connect(function() 
                        pcall(M_Object.Flags.Focused)
                    end)
                    m_ModuleText:GetPropertyChangedSignal("Text"):Connect(function() 
                        pcall(M_Object.Flags.TextChanged, m_ModuleText.Text)
                    end)
                end
                
                ins(ui_Modules, M_Object)
                return M_Object
            elseif (Type == 'Button') then
                local m_ModuleRoot
                 local m_ModuleBackground
                  local m_Highlight
                  local m_ModuleEnableEffect
                  local m_ModuleText
                  local m_ModuleIcon

                do
                    m_ModuleRoot = inst("Frame")
                    m_ModuleRoot.Size = dim2(1, 0, 0, 25)
                    m_ModuleRoot.AutomaticSize = "Y"
                    m_ModuleRoot.BackgroundTransparency = 1
                    m_ModuleRoot.BorderSizePixel = 0
                    m_ModuleRoot.ZIndex = M_IndexOffset-1
                    m_ModuleRoot.Parent = self.Menu
                    
                     m_ModuleBackground = inst("Frame")
                     m_ModuleBackground.Size = dim2(1,0,0,25)
                     m_ModuleBackground.BorderSizePixel = 0
                     m_ModuleBackground.ZIndex = M_IndexOffset
                     m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                     m_ModuleBackground.Parent = m_ModuleRoot
                     
                     
                      m_ModuleEnableEffect = inst("Frame")
                      m_ModuleEnableEffect.BackgroundColor3 = colors['text1']
                      m_ModuleEnableEffect.BackgroundTransparency = 1
                      m_ModuleEnableEffect.ClipsDescendants = true
                      m_ModuleEnableEffect.Size = dim2(1,0,1,0)
                      m_ModuleEnableEffect.BorderSizePixel = 0
                      m_ModuleEnableEffect.ZIndex = M_IndexOffset
                      m_ModuleEnableEffect.Parent = m_ModuleBackground
                      
                      m_Highlight = inst("Frame")
                      m_Highlight.Size = dim2sca(1,1)
                      m_Highlight.BackgroundColor3 = colors['enabled']
                      m_Highlight.BackgroundTransparency = 0.7
                      m_Highlight.Visible = false
                      m_Highlight.ZIndex = M_IndexOffset
                      m_Highlight.BorderSizePixel = 0
                      m_Highlight.Parent = m_ModuleBackground
                     
                     m_ModuleText = inst('TextLabel')
                     m_ModuleText.BackgroundTransparency = 1
                     m_ModuleText.Font = 'SourceSans'
                     m_ModuleText.Position = dim2off(5, 0)
                     m_ModuleText.RichText = true
                     m_ModuleText.Size = dim2(1, -5, 1, 0)
                     m_ModuleText.Text = text
                     m_ModuleText.TextColor3 = colors['text1']
                     m_ModuleText.TextSize = 20
                     m_ModuleText.TextStrokeColor3 = colors['text3']
                     m_ModuleText.TextStrokeTransparency = 0
                     m_ModuleText.TextXAlignment = 'Left'
                     m_ModuleText.ZIndex = M_IndexOffset
                     m_ModuleText.Parent = m_ModuleBackground
                     
                     m_ModuleIcon = inst('TextLabel')
                     m_ModuleIcon.Size = dim2off(25, 25)
                     m_ModuleIcon.Position = dim2sca(1,0)
                     m_ModuleIcon.AnchorPoint = vec2(1,0)
                     m_ModuleIcon.BackgroundTransparency = 1
                     m_ModuleIcon.Font = 'SourceSans'
                     m_ModuleIcon.TextXAlignment = 'Center'
                     m_ModuleIcon.TextColor3 = colors['text1']
                     m_ModuleIcon.TextSize = 18
                     m_ModuleIcon.Text = '⦿'
                     m_ModuleIcon.TextStrokeTransparency = 0
                     m_ModuleIcon.TextStrokeColor3 = colors['text3']
                     m_ModuleIcon.Rotation = 0
                     m_ModuleIcon.ZIndex = M_IndexOffset
                     m_ModuleIcon.Parent = m_ModuleBackground
                end
                    
                local M_Object = {} do 
                    M_Object.Tooltip = nil
                    
                    
                    M_Object.Flags = {} do 
                        M_Object.Flags['Clicked'] = true
                    end
                    
                    M_Object.setvis = base_class.module_setvis
                    M_Object.Root = m_ModuleRoot
                    
                    M_Object.Highlight = m_Highlight
                    
                    
                    M_Object.Effect = m_ModuleEnableEffect
                    
                    M_Object.Name = text
                    M_Object.ZIndex = M_IndexOffset
                    
                    M_Object.Click = base_class.module_click_self
                    
                    M_Object.Connect = base_class.generic_connect
                    M_Object.SetTooltip = base_class.generic_tooltip
                end
                
                do
                    m_ModuleBackground.InputBegan:Connect(function(io) 
                        local uitv = io.UserInputType.Value
                        if (uitv == 0) then
                            M_Object:Click()
                            return
                        end
                    end)
                    
                    m_ModuleBackground.MouseEnter:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object-b']
                        
                        
                        local tt = M_Object.Tooltip
                        if (tt) then
                            w_Tooltip.Text = tt
                            w_TooltipHeader.Text = M_Object.Name
                            w_TooltipHeader.Visible = true
                        end
                    end)
                    
                    m_ModuleBackground.MouseLeave:Connect(function() 
                        m_ModuleBackground.BackgroundColor3 = colors['bg_object']
                        
                        if (w_Tooltip.Text == M_Object.Tooltip) then
                            w_TooltipHeader.Visible = false
                        end
                    end)
                end
                
                ins(ui_Modules, M_Object)
                return M_Object
            end
        end
        base_class.module_create_label = function(self, text) 
            text = tostring(text)
            
            -- Yes, this is recycled from toggles
            
            local T_IndexOffset = self.ZIndex+1
            
            local t_Text
            
            do
                 t_Text = inst('TextLabel')
                 t_Text.BackgroundTransparency = 0
                 t_Text.BorderSizePixel = 0
                 t_Text.BackgroundColor3 = colors['bg_setting']
                 t_Text.Font = 'SourceSans'
                 t_Text.Position = dim2off(10, 0)
                 t_Text.RichText = true
                 t_Text.Size = dim2(1, 0, 0, 25)
                 t_Text.Text = text
                 t_Text.TextColor3 = colors['text1']
                 t_Text.TextSize = 18
                 t_Text.TextStrokeColor3 = colors['text3']
                 t_Text.TextStrokeTransparency = 0
                 t_Text.TextWrapped = true
                 t_Text.TextXAlignment = 'Left'
                 t_Text.TextYAlignment = 'Top'
                 t_Text.ZIndex = T_IndexOffset
                 t_Text.Parent = self.Menu
            end
            
            for i = 1, 25 do 
                if (t_Text.TextFits) then
                    break
                end
                t_Text.Size += dim2off(0,25)
            end
                
            local T_Object = {} do 
                T_Object.Tooltip = nil
                T_Object.Toggled = false
                
                T_Object.Name = text
                T_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                t_Text.MouseEnter:Connect(function()                     
                    local tt = T_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = T_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                t_Text.MouseLeave:Connect(function() 
                    
                    if (w_Tooltip.Text == T_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            return T_Object            
        end
        base_class.module_create_toggle = function(self, text) 
            text = tostring(text)
            
            local T_IndexOffset = self.ZIndex+1
            
            
            local t_Toggle
             local t_Box1
              local t_Box2
             local t_Text
            
            do
                t_Toggle = inst("Frame")
                t_Toggle.Size = dim2(1, 0, 0, 25)
                t_Toggle.BackgroundColor3 = colors['bg_setting']
                t_Toggle.BorderSizePixel = 0
                t_Toggle.ZIndex = T_IndexOffset
                t_Toggle.Parent = self.Menu
                 
                 t_Text = inst('TextLabel')
                 t_Text.Size = dim2(1, -10, 1, 0)
                 t_Text.Position = dim2off(10, 0)
                 t_Text.BackgroundTransparency = 1
                 t_Text.Font = 'SourceSans'
                 t_Text.TextXAlignment = 'Left'
                 t_Text.TextColor3 = colors['text1']
                 t_Text.TextSize = 18
                 t_Text.Text = text
                 t_Text.TextStrokeTransparency = 0
                 t_Text.TextStrokeColor3 = colors['text3']
                 t_Text.ZIndex = T_IndexOffset
                 t_Text.Parent = t_Toggle
                 
                 t_Box1 = inst('Frame')
                 t_Box1.Size = dim2off(10, 10)
                 t_Box1.Position = dim2(1,-5,0.5,-5)
                 t_Box1.AnchorPoint = vec2(1,0)
                 t_Box1.BackgroundTransparency = 0
                 t_Box1.BackgroundColor3 = colors['slider_bg']
                 t_Box1.BorderSizePixel = 0
                 t_Box1.ZIndex = T_IndexOffset
                 t_Box1.Parent = t_Toggle
                 
                 stroke(t_Box1)
                 
                 t_Box2 = inst('Frame')
                 t_Box2.Size = dim2off(8, 8)
                 t_Box2.Position = dim2off(1,1)
                 t_Box2.BackgroundTransparency = 1
                 t_Box2.BackgroundColor3 = colors['enabled']
                 t_Box2.BorderSizePixel = 0
                 t_Box2.Visible = true
                 t_Box2.ZIndex = T_IndexOffset
                 t_Box2.Parent = t_Box1
            end
                
            local T_Object = {} do 
                T_Object.Tooltip = nil
                T_Object.Toggled = false
                
                T_Object.Flags = {}
                T_Object.Flags['Enabled'] = true
                T_Object.Flags['Disabled'] = true
                T_Object.Flags['Toggled'] = true
                
                T_Object.Icon = t_Box2
                T_Object.Name = text
                
                T_Object.Toggle = base_class.setting_toggle_self
                T_Object.Disable = base_class.setting_toggle_disable
                T_Object.Enable = base_class.setting_toggle_enable
                T_Object.GetState = base_class.setting_toggle_getstate
                T_Object.IsEnabled = base_class.setting_toggle_getstate
                
                T_Object.Connect = base_class.generic_connect
                T_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                t_Toggle.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        T_Object:Toggle()
                        return
                    end
                end)
                
                t_Toggle.MouseEnter:Connect(function() 
                    t_Toggle.BackgroundColor3 = colors['bg_setting-b']
                    
                    local tt = T_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = T_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                t_Toggle.MouseLeave:Connect(function() 
                    t_Toggle.BackgroundColor3 = colors['bg_setting']
                    
                    if (w_Tooltip.Text == T_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            return T_Object            
        end
        base_class.module_create_dropdown = function(self, text, primary) 
            text = tostring(text)
            primary = primary or false
            
            local D_IndexOffset = self.ZIndex+1
            
            local d_Root
             local d_Header
              local d_HeaderText
              local d_HeaderIcon
              
              local d_Menu
               local d_MenuListLayout
            
            do
                d_Root = inst("Frame")
                d_Root.Size = dim2(1, 0, 0, 25)
                d_Root.AutomaticSize = "Y"
                d_Root.BackgroundTransparency = 1
                d_Root.BorderSizePixel = 0
                d_Root.ZIndex = D_IndexOffset-1
                d_Root.Parent = self.Menu
            
                 d_Header = inst('Frame')
                 d_Header.BackgroundColor3 = colors['bg_setting']
                 d_Header.Size = dim2(1, 0, 0, 25)
                 d_Header.Active = true
                 d_Header.BorderSizePixel = 0
                 d_Header.ZIndex = D_IndexOffset+1
                 d_Header.Parent = d_Root
                 
                  d_HeaderText = inst('TextLabel')
                  d_HeaderText.Size = dim2(1, -10, 1, 0)
                  d_HeaderText.Position = dim2off(10, 0)
                  d_HeaderText.BackgroundTransparency = 1
                  d_HeaderText.Font = 'SourceSans'
                  d_HeaderText.TextXAlignment = 'Left'
                  d_HeaderText.TextColor3 = colors['text1']
                  d_HeaderText.TextSize = 18
                  d_HeaderText.Text = text
                  d_HeaderText.TextStrokeTransparency = 0
                  d_HeaderText.TextStrokeColor3 = colors['text3']
                  d_HeaderText.ZIndex = D_IndexOffset+1
                  d_HeaderText.Parent = d_Header
                  
                  d_HeaderIcon = inst('ImageLabel')
                  d_HeaderIcon.Size = dim2off(25, 25)
                  d_HeaderIcon.Position = dim2sca(1,0)
                  d_HeaderIcon.AnchorPoint = vec2(1,0)
                  d_HeaderIcon.BackgroundTransparency = 1
                  d_HeaderIcon.ImageColor3 = colors['text1']
                  d_HeaderIcon.Image = 'rbxassetid://7184113125'
                  d_HeaderIcon.Rotation = 180
                  d_HeaderIcon.ZIndex = D_IndexOffset+1
                  d_HeaderIcon.Parent = d_Header
                 
                 d_Menu = inst('Frame')
                 d_Menu.Size = dim2(1,0,0,0)
                 d_Menu.AutomaticSize = "Y"
                 d_Menu.Position = dim2off(0, 25)
                 d_Menu.BackgroundColor3 = colors['bg_dropdown']
                 d_Menu.BorderSizePixel = 0
                 d_Menu.ZIndex = D_IndexOffset
                 d_Menu.Visible = false
                 d_Menu.Parent = d_Header
                 
                  d_MenuListLayout = inst('UIListLayout')
                  d_MenuListLayout.FillDirection = 'Vertical'
                  d_MenuListLayout.HorizontalAlignment = 'Left'
                  d_MenuListLayout.VerticalAlignment = 'Top'
                  d_MenuListLayout.Parent = d_Menu
            end
            
            local D_Object = {} do 
                D_Object.Tooltip = nil
                D_Object.MToggled = false
                
                D_Object.Primary = primary
                
                D_Object.Menu = d_Menu
                D_Object.Name = text
                D_Object.Parent = self
                D_Object.Icon = d_HeaderIcon
                D_Object.ZIndex = D_IndexOffset
                
                D_Object.Selection = nil
                
                D_Object.Objects = {}
                
                
                D_Object.Flags = {}
                D_Object.Flags['SelectionChanged'] = true
                
                D_Object.Toggle = base_class.menu_toggle
                D_Object.GetSelection = base_class.setting_dropdown_getselection
                
                D_Object.Connect = base_class.generic_connect
                D_Object.SetTooltip = base_class.generic_tooltip
                D_Object.AddOption = base_class.dropdown_create_option
            end
            
            do
                d_Header.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0 or uitv == 1) then
                        D_Object:Toggle()
                        return
                    end
                end)
                
                d_Header.MouseEnter:Connect(function() 
                    d_Header.BackgroundColor3 = colors['bg_setting-b']
                    
                    local tt = D_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = D_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                d_Header.MouseLeave:Connect(function() 
                    d_Header.BackgroundColor3 = colors['bg_setting']
                    
                    if (w_Tooltip.Text == D_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            return D_Object
        end
        base_class.module_create_modhotkey = function(self) 
            local H_IndexOffset = self.ZIndex+1
            
            local h_Hotkey
             local h_Text
            
            do
                h_Hotkey = inst("Frame")
                h_Hotkey.Size = dim2(1, 0, 0, 25)
                h_Hotkey.BackgroundColor3 = colors['bg_setting']
                h_Hotkey.BorderSizePixel = 0
                h_Hotkey.ZIndex = H_IndexOffset
                h_Hotkey.Parent = self.Menu
                 
                 h_Text = inst('TextLabel')
                 h_Text.Size = dim2(1, -10, 1, 0)
                 h_Text.Position = dim2off(10, 0)
                 h_Text.BackgroundTransparency = 1
                 h_Text.Font = 'SourceSans'
                 h_Text.TextXAlignment = 'Left'
                 h_Text.TextColor3 = colors['text1']
                 h_Text.TextSize = 18
                 h_Text.Text = 'Hotkey: N/A'
                 h_Text.TextStrokeTransparency = 0
                 h_Text.TextStrokeColor3 = colors['text3']
                 h_Text.ZIndex = H_IndexOffset
                 h_Text.Parent = h_Hotkey
            end
                
            local H_Object = {} do 
                H_Object.Label = h_Text
                H_Object.Hotkey = nil
                
                H_Object.Parent = self
                H_Object.Tooltip = nil
                
                H_Object.Flags = {}
                H_Object.Flags['HotkeySet'] = true
                
                H_Object.SetHotkey = base_class.setting_modhotkey_sethotkey
                H_Object.GetHotkey = base_class.setting_modhotkey_gethotkey
                
                H_Object.Connect = base_class.generic_connect
                H_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                h_Hotkey.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        H_Object:SetHotkey()
                        return
                    end
                end)
                
                h_Hotkey.MouseEnter:Connect(function() 
                    h_Hotkey.BackgroundColor3 = colors['bg_setting-b']
                end)
                
                h_Hotkey.MouseLeave:Connect(function() 
                    h_Hotkey.BackgroundColor3 = colors['bg_setting']
                end)
            end
            
            return H_Object   
        end
        base_class.module_create_hotkey = function(self, text) 
            local H_IndexOffset = self.ZIndex+1
            
            local h_Hotkey
             local h_Text
            
            do
                h_Hotkey = inst("Frame")
                h_Hotkey.Size = dim2(1, 0, 0, 25)
                h_Hotkey.BackgroundColor3 = colors['bg_setting']
                h_Hotkey.BorderSizePixel = 0
                h_Hotkey.ZIndex = H_IndexOffset
                h_Hotkey.Parent = self.Menu
                 
                 h_Text = inst('TextLabel')
                 h_Text.Size = dim2(1, -10, 1, 0)
                 h_Text.Position = dim2off(10, 0)
                 h_Text.BackgroundTransparency = 1
                 h_Text.Font = 'SourceSans'
                 h_Text.TextXAlignment = 'Left'
                 h_Text.TextColor3 = colors['text1']
                 h_Text.TextSize = 18
                 h_Text.Text = tostring(text)..': N/A'
                 h_Text.TextStrokeTransparency = 0
                 h_Text.TextStrokeColor3 = colors['text3']
                 h_Text.ZIndex = H_IndexOffset
                 h_Text.Parent = h_Hotkey
            end
                
            local H_Object = {} do 
                H_Object.Label = h_Text
                H_Object.Hotkey = nil
                
                H_Object.Parent = self
                H_Object.Tooltip = nil
                
                H_Object.Name = tostring(text)
                H_Object.Flags = {}
                H_Object.Flags['HotkeySet'] = true
                
                H_Object.bind = base_class.setting_hotkey_sethotkey
                H_Object.SetHotkey = base_class.setting_hotkey_sethotkeyexplicit
                H_Object.GetHotkey = base_class.setting_hotkey_gethotkey
                
                H_Object.Connect = base_class.generic_connect
                H_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                h_Hotkey.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        H_Object:bind()
                        return
                    end
                end)
                
                h_Hotkey.MouseEnter:Connect(function() 
                    h_Hotkey.BackgroundColor3 = colors['bg_setting-b']
                    
                    local tt = H_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = H_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                h_Hotkey.MouseLeave:Connect(function() 
                    h_Hotkey.BackgroundColor3 = colors['bg_setting']
                    
                    if (w_Tooltip.Text == H_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            return H_Object   
        end
        base_class.module_create_slider = function(self, text, args) 
            text = tostring(text)
            
            args['min'] = args['min'] or 0
            args['max'] = args['max'] or 100
            args['cur'] = args['cur'] or args['min']
            args['step'] = args['step'] or 1
            
            
            if (tostring(args['step']):match("e%-")) then
                error(("%s failed; %s was too %s"):format('module_create_slider', 'args.step', 'small'))
            end
            if (tostring(args['step']):match("e%+")) then 
                error(("%s failed; %s was too %s"):format('module_create_slider', 'args.step', 'large'))
            end
            
            local S_IndexOffset = self.ZIndex+1
            
            local s_Slider
             local s_Text
              local s_TextPad
             local s_Amount
             local s_SliderBarBg
              local s_SliderBar
              
            do
                s_Slider = inst("Frame")
                s_Slider.Size = dim2(1, 0, 0, 25)
                s_Slider.BackgroundColor3 = colors['bg_setting']
                s_Slider.BorderSizePixel = 0
                s_Slider.ZIndex = S_IndexOffset
                s_Slider.Parent = self.Menu
                 
                 s_Text = inst('TextLabel')
                 s_Text.Size = dim2sca(1, 1)
                 s_Text.Position = dim2off(0, 0)
                 s_Text.BackgroundTransparency = 0.6
                 s_Text.BorderSizePixel = 0
                 s_Text.BackgroundColor3 = colors['bg_setting']
                 s_Text.Font = 'SourceSans'
                 s_Text.TextXAlignment = 'Left'
                 s_Text.TextColor3 = colors['text1']
                 s_Text.TextSize = 18
                 s_Text.Text = text
                 s_Text.Visible = true
                 s_Text.TextStrokeTransparency = 0
                 s_Text.TextStrokeColor3 = colors['text3']
                 s_Text.ZIndex = S_IndexOffset + 1
                 s_Text.Parent = s_Slider
                  
                  s_TextPad = inst("UIPadding")
                  s_TextPad.PaddingLeft = dim2off(10, 0).X
                  s_TextPad.Parent = s_Text 
                 
                 s_Amount = inst('TextLabel')
                 s_Amount.Size = dim2(0, 30, 1, 0)
                 s_Amount.Position = dim2(1,-5,0,0)
                 s_Amount.AnchorPoint = vec2(1,0)
                 s_Amount.BackgroundTransparency = 1
                 s_Amount.BorderSizePixel = 0
                 s_Amount.Font = 'SourceSans'
                 s_Amount.TextXAlignment = 'Center'
                 s_Amount.TextColor3 = colors['text1']
                 s_Amount.TextSize = 18
                 s_Amount.Visible = true
                 s_Amount.TextStrokeTransparency = 0
                 s_Amount.TextStrokeColor3 = colors['text3']
                 s_Amount.ZIndex = S_IndexOffset + 1 
                 s_Amount.Parent = s_Slider
                 
                 s_SliderBarBg = inst("Frame")
                 s_SliderBarBg.Size = dim2(1, -16, 0, 6)
                 s_SliderBarBg.Position = dim2(0, 8, 0.5, -3)
                 s_SliderBarBg.BackgroundColor3 = colors['slider_bg']
                 s_SliderBarBg.BorderSizePixel = 0
                 s_SliderBarBg.ZIndex = S_IndexOffset
                 s_SliderBarBg.ClipsDescendants = true
                 s_SliderBarBg.Parent = s_Slider
                 
                  s_SliderBar = inst("Frame")
                  s_SliderBar.Size = dim2sca(1, 1)
                  s_SliderBar.Position = dim2(0,0)
                  s_SliderBar.AnchorPoint = vec2(0, 0)
                  s_SliderBar.BackgroundColor3 = colors['slider_fg']
                  s_SliderBar.BorderSizePixel = 0
                  s_SliderBar.ZIndex = S_IndexOffset
                  s_SliderBar.Parent = s_SliderBarBg
                 
            end
            
            local StepFormat = #(tostring(args['step']):match("%.(%d+)") or '')
            StepFormat = ("%."..StepFormat.."f")
            
            s_Amount.Text = StepFormat:format(args['cur'])
            
            
            local DragConn
                
            local S_Object = {} do 
                S_Object.Tooltip = nil
                S_Object.Name = text
                
                S_Object.SliderFill = s_SliderBar
                S_Object.SliderBg = s_SliderBarBg
                S_Object.SliderAmnt = s_Amount
                
                
                S_Object.SliderSize = s_SliderBarBg.AbsoluteSize.X
                
                S_Object.CurrentVal = args['cur']
                S_Object.PreviousVal = nil
                S_Object.Min = args['min']
                S_Object.Max = args['max']
                S_Object.Step = args['step']
                S_Object.Ratio = S_Object.SliderSize / (S_Object.Max - S_Object.Min)
                S_Object.RatioInverse = 1 / S_Object.Ratio
                S_Object.StepFormat = StepFormat
                
                
                
                
                
                S_Object.Flags = {}
                S_Object.Flags['ValueChanged'] = true
                
                S_Object.GetValue = base_class.setting_slider_getval
                S_Object.SetValue = base_class.setting_slider_setvalnum
                S_Object.SetValuePos = base_class.setting_slider_setvalpos
                
                S_Object.Connect = base_class.generic_connect
                S_Object.SetTooltip = base_class.generic_tooltip
            end
            
            S_Object:SetValue(args['cur'])
            
            do
                s_Slider.MouseEnter:Connect(function() 
                    s_Slider.BackgroundColor3 = colors['bg_setting-b']
                    
                    twn(s_Text, {BackgroundTransparency = 1, TextTransparency = 1, TextStrokeTransparency = 1},true)
                    twn(s_Amount, {Position = dim2(0.5,15,0,0)}, true)
                    
                    local tt = S_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = S_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                s_Slider.MouseLeave:Connect(function() 
                    s_Slider.BackgroundColor3 = colors['bg_setting']
                    twn(s_Text, {BackgroundTransparency = 0.2, TextTransparency = 0, TextStrokeTransparency = 0},true)
                    twn(s_Amount, {Position = dim2(1,-5,0,0)}, true)
                    
                    if (w_Tooltip.Text == S_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
                
                s_SliderBarBg.InputBegan:Connect(function(io) 
                    if (io.UserInputType.Value == 0) then
                        S_Object:SetValuePos(io.Position.X)
                        
                        DragConn = serv_uis.InputChanged:Connect(function(io) 
                            if (io.UserInputType.Value == 4) then
                                S_Object:SetValuePos(io.Position.X)
                            end
                        end)
                    end
                end)
                
                s_SliderBarBg.InputEnded:Connect(function(io) 
                    if (io.UserInputType.Value == 0) then
                        DragConn:Disconnect()
                    end
                end)
            end
            return S_Object            
        end
        base_class.module_create_input = function(self, text) 
            text = tostring(text)
            local I_IndexOffset = self.ZIndex + 1 
            
            local i_Input
             local i_Padding
             local i_Icon

            do

                
                i_Input = inst('TextBox')
                i_Input.BackgroundColor3 = colors['bg_setting']
                i_Input.BackgroundTransparency = 0
                i_Input.BorderSizePixel = 0 
                i_Input.ClearTextOnFocus = true
                i_Input.Font = 'SourceSans'
                i_Input.Position = dim2off(0, 0)
                i_Input.Size = dim2(1, 0, 0, 25)
                i_Input.Text = text
                i_Input.TextColor3 = colors['text1']
                i_Input.TextSize = 18
                i_Input.TextStrokeColor3 = colors['text3']
                i_Input.TextStrokeTransparency = 0
                i_Input.TextWrapped = true
                i_Input.TextXAlignment = 'Left'
                i_Input.ZIndex = I_IndexOffset
                i_Input.Parent = self.Menu
                 
                 i_Padding = inst("UIPadding")
                 i_Padding.PaddingLeft = dim2off(10, 0).X
                 i_Padding.Parent = i_Input
                
                i_Icon = inst('TextLabel')
                i_Icon.AnchorPoint = vec2(1,0)
                i_Icon.BackgroundTransparency = 1
                i_Icon.Font = 'SourceSans'
                i_Icon.Position = dim2sca(1,0)
                i_Icon.Rotation = 0
                i_Icon.Size = dim2off(25, 25)
                i_Icon.Text = '🅃'
                i_Icon.TextColor3 = colors['text1']
                i_Icon.TextSize = 18
                i_Icon.TextStrokeColor3 = colors['text3']
                i_Icon.TextStrokeTransparency = 0
                i_Icon.TextXAlignment = 'Center'
                i_Icon.ZIndex = I_IndexOffset
                i_Icon.Parent = i_Input
            end
                
            local I_Object = {} do 
                I_Object.Tooltip = nil
                
                
                I_Object.Flags = {} do 
                    I_Object.Flags['Focused'] = true
                    I_Object.Flags['Unfocused'] = true
                    I_Object.Flags['TextChanged'] = true
                end
                
                I_Object.Name = text
                I_Object.ZIndex = I_IndexOffset
                                
                I_Object.Connect = base_class.generic_connect
                I_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                i_Input.MouseEnter:Connect(function() 
                    i_Input.BackgroundColor3 = colors['bg_setting-b']
                    
                    
                    local tt = I_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = I_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                i_Input.MouseLeave:Connect(function() 
                    i_Input.BackgroundColor3 = colors['bg_setting']
                    
                    if (w_Tooltip.Text == I_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
                
                i_Input.FocusLost:Connect(function(enter) 
                    pcall(I_Object.Flags.Unfocused, i_Input.Text, enter)
                    i_Input.Text = I_Object.Name
                end)
                i_Input.Focused:Connect(function() 
                    pcall(I_Object.Flags.Focused)
                end)
                i_Input:GetPropertyChangedSignal("Text"):Connect(function() 
                    pcall(I_Object.Flags.TextChanged, i_Input.Text)
                end)
            end
            
            return I_Object
        end
        base_class.module_create_button = function(self, text) 
            text = tostring(text)
            
            local B_IndexOffset = self.ZIndex + 1
            
            local b_Background
             local b_EnableEffect
             local b_Text
             local b_Icon
            
            do
                b_Background = inst("Frame")
                b_Background.BackgroundColor3 = colors['bg_setting'] 
                b_Background.BorderSizePixel = 0
                b_Background.Size = dim2(1,0,0,25)
                b_Background.ZIndex = B_IndexOffset
                b_Background.Parent = self.Menu
                
                 b_EnableEffect = inst("Frame")
                 b_EnableEffect.BackgroundColor3 = colors['text1']
                 b_EnableEffect.BackgroundTransparency = 1
                 b_EnableEffect.BorderSizePixel = 0
                 b_EnableEffect.ClipsDescendants = true
                 b_EnableEffect.Size = dim2(1,0,1,0)
                 b_EnableEffect.ZIndex = B_IndexOffset
                 b_EnableEffect.Parent = b_Background
                
                 b_Text = inst('TextLabel')
                 b_Text.BackgroundTransparency = 1
                 b_Text.Font = 'SourceSans'
                 b_Text.Position = dim2off(10, 0)
                 b_Text.Size = dim2(1, -10, 1, 0)
                 b_Text.Text = text
                 b_Text.TextColor3 = colors['text1']
                 b_Text.TextSize = 18
                 b_Text.TextStrokeColor3 = colors['text3']
                 b_Text.TextStrokeTransparency = 0
                 b_Text.TextXAlignment = 'Left'
                 b_Text.ZIndex = B_IndexOffset
                 b_Text.Parent = b_Background
                 
                 b_Icon = inst('TextLabel')
                 b_Icon.AnchorPoint = vec2(1,0)
                 b_Icon.BackgroundTransparency = 1
                 b_Icon.Font = 'SourceSans'
                 b_Icon.Position = dim2sca(1,0)
                 b_Icon.Rotation = 0
                 b_Icon.Size = dim2off(25, 25)
                 b_Icon.Text = '⦿'
                 b_Icon.TextColor3 = colors['text1']
                 b_Icon.TextSize = 18
                 b_Icon.TextStrokeColor3 = colors['text3']
                 b_Icon.TextStrokeTransparency = 0
                 b_Icon.TextXAlignment = 'Center'
                 b_Icon.ZIndex = B_IndexOffset
                 b_Icon.Parent = b_Background
            end
                
            local B_Object = {} do 
                B_Object.Tooltip = nil
                
                
                B_Object.Flags = {} do 
                    B_Object.Flags['Clicked'] = true
                end
                
                B_Object.Effect = b_EnableEffect
                
                B_Object.Name = text
                B_Object.ZIndex = B_IndexOffset
                
                B_Object.Click = base_class.module_click_self
                
                B_Object.Connect = base_class.generic_connect
                B_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                b_Background.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        B_Object:Click()
                        return
                    end
                end)
                
                b_Background.MouseEnter:Connect(function() 
                    b_Background.BackgroundColor3 = colors['bg_setting-b']
                    
                    
                    local tt = B_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = B_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                b_Background.MouseLeave:Connect(function() 
                    b_Background.BackgroundColor3 = colors['bg_setting'] 
                    
                    if (w_Tooltip.Text == B_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            return B_Object
        end
        
        
        
        base_class.dropdown_create_option = function(self, text) 
            text = tostring(text)

            local O_IndexOffset = self.ZIndex + 1
            
            local o_Option
             local o_Text
             local o_EnableEffect
             local o_EnableEffect2
            
            do
                o_Option = inst("Frame")
                o_Option.Size = dim2(1, 0, 0, 25)
                o_Option.BackgroundColor3 = colors['bg_dropdown']
                o_Option.BorderSizePixel = 0
                o_Option.ZIndex = O_IndexOffset
                o_Option.Parent = self.Menu
                 
                 o_Text = inst('TextLabel')
                 o_Text.Size = dim2(1, -15, 1, 0)
                 o_Text.Position = dim2off(15, 0)
                 o_Text.BackgroundTransparency = 1
                 o_Text.Font = 'SourceSans'
                 o_Text.TextXAlignment = 'Left'
                 o_Text.TextColor3 = colors['text1']
                 o_Text.TextSize = 18
                 o_Text.Text = text
                 o_Text.TextStrokeTransparency = 0
                 o_Text.TextStrokeColor3 = colors['text3']
                 o_Text.ZIndex = O_IndexOffset
                 o_Text.Parent = o_Option
                 
                 o_EnableEffect = inst("Frame")
                 o_EnableEffect.BackgroundColor3 = colors['text1']
                 o_EnableEffect.BackgroundTransparency = 0.96
                 o_EnableEffect.ClipsDescendants = true
                 o_EnableEffect.Size = dim2(0,0,1,0)
                 o_EnableEffect.BorderSizePixel = 0
                 o_EnableEffect.ZIndex = O_IndexOffset
                 o_EnableEffect.Parent = o_Option
                 
                  o_EnableEffect2 = inst("Frame")
                  o_EnableEffect2.BackgroundColor3 = colors['enabled']
                  o_EnableEffect2.Size = dim2(0,2,1,0)
                  o_EnableEffect2.BorderSizePixel = 0
                  o_EnableEffect2.ZIndex = O_IndexOffset
                  o_EnableEffect2.Parent = o_EnableEffect
            end
                
            local O_Object = {} do 
                O_Object.Tooltip = nil
                O_Object.Selected = false
                
                O_Object.Name = text
                O_Object.Parent = self
                
                O_Object.Effect = o_EnableEffect
                
                O_Object.Select = base_class.setting_ddoption_select_self
                O_Object.Deselect = base_class.setting_ddoption_deselect_self
                
                O_Object.GetState = base_class.setting_ddoption_selected_getstate
                O_Object.IsSelected = base_class.setting_ddoption_selected_getstate
                
                O_Object.SetTooltip = base_class.generic_tooltip
            end
            
            do
                o_Option.InputBegan:Connect(function(io) 
                    local uitv = io.UserInputType.Value
                    if (uitv == 0) then
                        O_Object:Select()
                        return
                    end
                end)
                
                o_Option.MouseEnter:Connect(function() 
                    o_Option.BackgroundColor3 = colors['bg_dropdown-b']
                    
                    local tt = O_Object.Tooltip
                    if (tt) then
                        w_Tooltip.Text = tt
                        w_TooltipHeader.Text = O_Object.Name
                        w_TooltipHeader.Visible = true
                    end
                end)
                
                o_Option.MouseLeave:Connect(function() 
                    o_Option.BackgroundColor3 = colors['bg_dropdown']
                    
                    if (w_Tooltip.Text == O_Object.Tooltip) then
                        w_TooltipHeader.Visible = false
                    end
                end)
            end
            
            ins(self.Objects, O_Object)
            return O_Object
        end
    end
    
    -- UI functions
    function ui:CreateMenu(text) 
        local M_Id = #ui_Menus+1
        local M_IndexOffset = M_Id * 15
        
        local m_Header
         local m_HeaderEnableEffect
         local m_HeaderText
         local m_HeaderIcon
         
         local m_Menu
          local m_MenuListLayout
        
        m_Header = inst('ImageButton')
        m_Header.BackgroundColor3 = colors['bg_header']
        m_Header.Size = dim2off(250, 30)
        m_Header.Active = true
        m_Header.ClipsDescendants = false
        m_Header.AutoButtonColor = false
        m_Header.BorderSizePixel = 0
        m_Header.Position = dim2off(
            (0.1*((M_Id-1)%6) * monitor_resolution.X)+(100*((M_Id-1)%6)+100), 
            0
        )
        
        local t_MID = M_Id
        local y = 100 
        for i=0, 100, 6 do 
            if t_MID > i then
                y += 100
            else
                break
            end
        end
        m_Header.Position += dim2off(0,y)
        
        m_Header.ZIndex = M_IndexOffset+2
        m_Header.Parent = w_Backframe
        
         m_HeaderEnableEffect = inst("Frame")
         m_HeaderEnableEffect.BackgroundColor3 = colors['enabled']
         m_HeaderEnableEffect.Size = dim2(0,0,1,0)
         m_HeaderEnableEffect.BorderSizePixel = 0
         m_HeaderEnableEffect.ZIndex = M_IndexOffset+2
         m_HeaderEnableEffect.Parent = m_Header
        
         m_HeaderText = inst('TextLabel')
         m_HeaderText.Size = dim2(1, 0, 1, 0)
         m_HeaderText.Position = dim2off(0, 0)
         m_HeaderText.BackgroundTransparency = 1
         m_HeaderText.Font = 'SourceSans'
         m_HeaderText.TextXAlignment = 'Center'
         m_HeaderText.TextColor3 = colors['text1']
         m_HeaderText.TextSize = 22
         m_HeaderText.Text = text
         m_HeaderText.TextStrokeTransparency = 0
         m_HeaderText.TextStrokeColor3 = colors['text3']
         m_HeaderText.ZIndex = M_IndexOffset+2
         m_HeaderText.Parent = m_Header
         
         m_HeaderIcon = inst('ImageLabel')
         m_HeaderIcon.Size = dim2off(30, 30)
         m_HeaderIcon.Position = dim2sca(1,0)
         m_HeaderIcon.AnchorPoint = vec2(1,0)
         m_HeaderIcon.BackgroundTransparency = 1
         m_HeaderIcon.ImageColor3 = colors['text1']
         m_HeaderIcon.Image = 'rbxassetid://7184113125'
         m_HeaderIcon.Rotation = 180
         m_HeaderIcon.ZIndex = M_IndexOffset+2
         m_HeaderIcon.Parent = m_Header
        
        m_Menu = inst('Frame')
        m_Menu.Size = dim2(1,0,0,0)
        m_Menu.Position = dim2off(0, 30)
        m_Menu.AutomaticSize = "Y"
        m_Menu.BackgroundColor3 = colors['bg_object']
        m_Menu.BorderSizePixel = 0
        m_Menu.ZIndex = M_IndexOffset
        m_Menu.Visible = false
        m_Menu.Parent = m_Header
        
         m_MenuListLayout = inst('UIListLayout')
         m_MenuListLayout.FillDirection = 'Vertical'
         m_MenuListLayout.HorizontalAlignment = 'Left'
         m_MenuListLayout.VerticalAlignment = 'Top'
         m_MenuListLayout.Parent = m_Menu
        
        stroke(m_Header)
        stroke(m_Menu)
        
        
        
        
        local M_Object = {} do 
            M_Object.MToggled = false
            M_Object.Menu = m_Menu
            M_Object.Icon = m_HeaderIcon
            M_Object.ZIndex = M_IndexOffset
            M_Object.Enabled = m_HeaderEnableEffect
            
            M_Object.AddMod = base_class.menu_create_module
            
            
            M_Object.Toggle = base_class.menu_toggle
            M_Object.GetState = base_class.menu_getstate
        end
        
        do
            local prevclicktime = 0
            m_Header.InputBegan:Connect(function(io) 
                local uitv = io.UserInputType.Value
                if (uitv == 0) then
                    local currclicktime = time()
                    if (currclicktime - prevclicktime < 0.3) then
                        M_Object:Toggle()
                    end
                    prevclicktime = currclicktime
                    
                    
                    local root_pos = m_Header.AbsolutePosition
                    local start_pos = io.Position
                    start_pos = vec2(start_pos.X, start_pos.Y)
                    
                    ui_Connections['menu-'..M_Id] = serv_uis.InputChanged:Connect(function(io) 
                        if (io.UserInputType.Value == 4) then
                            local curr_pos = io.Position
                            curr_pos = vec2(curr_pos.X, curr_pos.Y)
                            
                            local destination = root_pos + (curr_pos - start_pos) + monitor_inset
                            
                            twn(m_Header, {Position = dim2off(destination.X, destination.Y)})
                        end
                    end)
                    return
                end
                
                if (uitv == 1) then
                    M_Object:Toggle()
                end
            end)
            m_Header.InputEnded:Connect(function(io) 
                if (io.UserInputType.Value == 0) then
                    local a = ui_Connections['menu-'..M_Id]
                    if (a) then a:Disconnect() end
                end
            end)
            
            m_Header.MouseEnter:Connect(function() 
                m_Header.BackgroundColor3 = colors['bg_header-b']
            end)
            
            m_Header.MouseLeave:Connect(function() 
                m_Header.BackgroundColor3 = colors['bg_header']
            end)
        end
        
        
        
        ins(ui_Menus, M_Object)
        return M_Object
    end
    function ui:Destroy() 
        pcall(ui.Flags.Destroying)
        
        
        -- Destroy
        w_Screen:Destroy()
        
        -- Unbinds
        serv_ctx:UnbindAction('RL-ToggleMenu')
        
        -- Disconnections
        pcall(function() input_connection:Disconnect() end)
        
        for i,v in pairs(ui_Connections) do 
            v:Disconnect() 
        end
        
        -- Variable clearing
        colors = nil
        shadow,getnext,stroke,round,uierror = nil,nil,nil,nil,nil
        ui_Menus = nil
        
        _G.RLLoaded = false
    end
    function ui:GetModules() 
        return ui_Modules
    end
    function ui:GetScreen() 
        return w_Screen 
    end
    
    local notifs = {}
    local notifsounds = {"rbxassetid://8747340426","rbxassetid://8745692251",''}
    function ui:Notify(title, text, duration, tone) 
        duration = mc(duration or 2, 0.1, 30)
        
        local m_Notif
         local m_Description
         local m_Header
          local m_Title
          local m_Icon
          local m_Text
        
        local sound
        do 
            
            m_Notif = inst('Frame')
            m_Notif.AnchorPoint = vec2(1,1)
            m_Notif.BackgroundColor3 = colors['bg_object']
            m_Notif.BorderColor3 = colors['outline']
            m_Notif.BorderSizePixel = 1
            m_Notif.Position = dim2(1, 275, 1, -((#notifs*125)+((#notifs+1)*25)))
            m_Notif.Size = dim2off(225, 125)
            m_Notif.ZIndex = 162
            m_Notif.Parent = w_Screen
            
            sound = inst("Sound")
            sound.Playing = true
            sound.SoundId = notifsounds[tone or 3]
            sound.Volume = 2
            sound.Parent = m_Notif 
            
             m_Progress = inst("Frame")
             m_Progress.BackgroundColor3 = colors['enabled']
             m_Progress.BorderSizePixel = 0
             m_Progress.Position = dim2off(0, 30)
             m_Progress.Size = dim2off(225, 1)
             m_Progress.ZIndex = 163
             m_Progress.Parent = m_Notif
            
             m_Header = inst('Frame')
             m_Header.BackgroundColor3 = colors['bg_header']
             m_Header.BorderColor3 = colors['outline']
             m_Header.BorderSizePixel = 1
             m_Header.Size = dim2off(225, 30)
             m_Header.ZIndex = 162
             m_Header.Parent = m_Notif
             
              m_Text = inst('TextLabel')
              m_Text.BackgroundTransparency = 1
              m_Text.Font = 'SourceSans'
              m_Text.Position = dim2off(32, 0)
              m_Text.RichText = true
              m_Text.Size = dim2(1, -32, 1, 0)
              m_Text.Text = tostring(title)
              m_Text.TextColor3 = colors['text1']
              m_Text.TextSize = 22
              m_Text.TextStrokeColor3 = colors['text3']
              m_Text.TextStrokeTransparency = 0
              m_Text.TextXAlignment = 'Left'
              m_Text.ZIndex = 162
              m_Text.Parent = m_Header
              
              m_Description = inst('TextLabel')
              m_Description.BackgroundTransparency = 1
              m_Description.Font = 'SourceSans'
              m_Description.Position = dim2off(4, 32)
              m_Description.RichText = true
              m_Description.Size = dim2(1, -4, 1, -32)
              m_Description.Text = tostring(text)
              m_Description.TextColor3 = colors['text1']
              m_Description.TextSize = 20
              m_Description.TextStrokeColor3 = colors['text3']
              m_Description.TextStrokeTransparency = 0
              m_Description.TextWrapped = true
              m_Description.TextXAlignment = 'Left'
              m_Description.TextYAlignment = 'Top'
              m_Description.ZIndex = 162
              m_Description.Parent = m_Notif
              
              m_Icon = inst('ImageLabel')
              m_Icon.Size = dim2off(26, 26)
              m_Icon.Position = dim2off(2,2)
              m_Icon.BackgroundTransparency = 1
              m_Icon.ImageColor3 = colors['text1']
              m_Icon.Image = 'rbxassetid://8745673635'
              m_Icon.Rotation = 0
              m_Icon.ZIndex = 162
              m_Icon.Parent = m_Header
        end
        
        ins(notifs, m_Notif)
        
        twn(m_Notif, {Position = m_Notif.Position - dim2off(300)},true)
        ctwn(m_Progress, {Size = dim2off(0, 1)}, duration)
        delay(duration, function() 
            for i = 1, #notifs do 
                if (notifs[i] == m_Notif) then 
                    rem(notifs, i) 
                end 
            end
            for i = 1, #notifs do 
                twn(notifs[i], {Position = dim2(1, -25, 1, -(((i-1)*125)+(i*25)))}, true)
            end
            twn(m_Notif, {Position = dim2(1, -25, 1, 200)}, true).Completed:Wait()
            m_Notif:Destroy()
        end)
    end
    
    
    ui.Flags = {}
    ui.Flags.Destroying = true
    ui.Connect = base_class.generic_connect
    
    
    -- Bind gui
    serv_ctx:BindActionAtPriority('RL-ToggleMenu',function(_,uis) 
        
        if (uis.Value == 0) then
            W_WindowOpen = not W_WindowOpen
            
            if (W_WindowOpen) then
                w_Backframe.Visible = true
                twn(w_Backframe, {Position = dim2(0, 0, 0, 0)}, true)
            else
                twn(w_Backframe, {Position = dim2(0, 0, -1, 0)}, true).Completed:Connect(function() w_Backframe.Visible = false end)
            end
        end
    end,false,999999,Enum.KeyCode.RightShift)
    -- Auto collection
    delay(5, function() 
        if (ui_Menus ~= nil and #ui_Menus == 0) then
            ui:Destroy()
            warn'[REDLINE] Failure to clean library resources!\nAutomatically cleared for you; make sure to\ncall ui:Destroy() when finished'
        end
    end)
end

--delay(40, ui.Destroy, ui)
serv_ctx:BindActionAtPriority('RL-Destroy',function(_,uis) 
        
    if (uis.Value == 0) then
        ui:Destroy()
    end
end,false,999999,Enum.KeyCode.End)

-- holy shit
local isexecclosure = is_synapse_function or 


    is_exec_closure or 
    is_exec_func or 
    is_exec_function or 
    is_executor_closure or 
    is_executor_func or 
    is_executor_function or
    is_our_closure or 
    is_our_func or
    is_our_function or 
    is_synapse_closure or 
    is_synapse_func or 
    is_synapse_function or 
    iselectronfunction or 
    isexecclosure or 
    isexecfunc or 
    isexecfunction or 
    isexecutorclosure or
    isexecutorfunc or 
    isexecutorfunction or
    isfluxusfunction or 
    iskrnlclosure or
    iskrnlfunction or
    isourclosure or 
    isourfunc or
    isourfunction or
    isoxygenfunction
    
-- disable non executor connections
local function ratio(signal) 
    local average = getconnections(signal)
    for i = 1, #average do 
        local connection = average[i]
        local confunc = connection.Function
        
        if (type(confunc) == "function" and islclosure(confunc)) then
            if (not isexecclosure(confunc)) then
                connection:Disable()
            end
        end
    end
end
local function unratio(signal)
    local average = getconnections(signal)
    for i = 1, #average do 
        local connection = average[i]
        local confunc = connection.Function
        
        if (type(confunc) == "function" and islclosure(confunc)) then
            if (not isexecclosure(confunc)) then
                connection:Enable()
            end
        end
    end
end

local cons = {}

local l_plr = serv_players.LocalPlayer
local l_mouse = l_plr:GetMouse()
local l_chr = l_plr.Character
local l_hum = l_chr and l_chr:FindFirstChild("Humanoid")
local l_humrp = l_chr and l_chr:FindFirstChild("HumanoidRootPart")

local l_cam = workspace.CurrentCamera or workspace:FindFirstChildOfClass("Camera")

cons['chr'] = l_plr.CharacterAdded:Connect(function(c) 
    l_chr = c
    l_hum = c:WaitForChild("Humanoid",3)
    l_humrp = c:WaitForChild("HumanoidRootPart",3)
end)

local rlfriends = {}

-- Every single player 
local p_players_all = {}
-- Every player minus friends and local player 
local p_players = {}
local p_names = {}

local function addplr(p) 
    --printconsole('Adding player '..p.Name, 0, 255, 255)
    local ptable = {}
    ptable['plr'] = p
    ptable['chr'] = nil
    ptable['hum'] = nil
    ptable['rp'] = nil
    
    ptable['cons'] = {}
    
    --printconsole('Set up the table', 128, 128, 128)
    ptable['cons'][1] = p.CharacterAdded:Connect(function(c) 
        ptable['chr'] = c
        ptable['hum'] = c:WaitForChild("Humanoid", 1)
        ptable['rp'] = c:WaitForChild("HumanoidRootPart", 1)
        --printconsole(p.Name..' respawned; Updated some vars n shit', 0, 255, 0)
    end)
    
    if (p.Character) then
        ptable['chr'] = p.Character
        ptable['hum'] = p.Character:FindFirstChild("Humanoid")
        ptable['rp'] = p.Character:FindFirstChild("HumanoidRootPart")
        --printconsole('Got character stuff', 128, 128, 128)
    end
    
    
    ins(p_players_all, ptable)
    if not (p == l_plr or rlfriends[p.Name]) then
        --printconsole('Not blacklisted / local plr, added to player table', 0, 255, 0)
        ins(p_players, ptable)
    end
    --printconsole('Inserted into proper tables', 128, 128, 128)
    
    p_names[p.Name] = p
end 
local function remplr(p) 
    --printconsole(p.Name..' left cleaning shit', 255, 255, 0)
    -- Player left, find the player object in each table
    --printconsole('Clearing their player table [1]', 0, 255, 0)
    for i = 1, #p_players do 
        local plr = p_players[i]
        -- Check for matching player objects
        if (plr.plr == p) then
            local cons = plr.cons
            -- Disable connections
            for i = 1, #cons do cons[i]:Disconnect() end
            -- Clear table and stuff
            p_players[i] = nil
            -- Remove it from the player list
            --printconsole('Removed their player table [1]', 0, 255, 0)
            rem(p_players, i)
            break
        end
    end
    -- Next check the other table
    --printconsole('Clearing their player table [2]', 0, 255, 0)
    for i = 1, #p_players_all do 
        local plr = p_players_all[i]
        -- Check for matching player objects
        if (plr.plr == p) then
            local cons = plr.cons
            -- Disable connections
            for i = 1, #cons do cons[i]:Disconnect() end
            -- Clear table and stuff
            p_players_all[i] = nil
            -- Remove it from the player list
            --printconsole('Removed their player table [2]', 0, 255, 0)
            rem(p_players_all, i)
            break
        end
    end
    
    p_names[p.Name] = nil
end

cons['p1'] = serv_players.PlayerAdded:Connect(addplr)
cons['p2'] = serv_players.PlayerRemoving:Connect(remplr)
cons['cam'] = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function() 
    local cc = workspace.CurrentCamera
    if not cc then
        cc = workspace:FindFirstChildOfClass("Camera")
    end
    l_cam = cc
end)
for i,p in ipairs(serv_players:GetChildren()) do 
    addplr(p)
end

local fakechar do 
    fakechar = inst("Model")
    fakechar.Name = getnext()


    local Head = inst("Part")
    Head.Anchored = false
    Head.CanCollide = false
    Head.Name = "Head"
    Head.Size = vec3(2, 1, 1)
    Head.Transparency = 0
    Head.Parent = fakechar

    local Torso = inst("Part")
    Torso.Anchored = false
    Torso.CanCollide = false
    Torso.Name = "Torso"
    Torso.Size = vec3(2, 2, 1)
    Torso.Parent = fakechar

    local Left_Arm = inst("Part")
    Left_Arm.Anchored = false
    Left_Arm.CanCollide = false
    Left_Arm.Name = "Left Arm"
    Left_Arm.Size = vec3(1, 2, 1)
    Left_Arm.Parent = fakechar

    local Right_Arm = inst("Part")
    Right_Arm.Anchored = false
    Right_Arm.CanCollide = false
    Right_Arm.Name = "Right Arm"
    Right_Arm.Size = vec3(1, 2, 1)
    Right_Arm.Parent = fakechar

    local Left_Leg = inst("Part")
    Left_Leg.Anchored = false
    Left_Leg.CanCollide = false
    Left_Leg.Name = "Left Leg"
    Left_Leg.Size = vec3(1, 2, 1)
    Left_Leg.Parent = fakechar

    local Right_Leg = inst("Part")
    Right_Leg.Anchored = false
    Right_Leg.CanCollide = false
    Right_Leg.Name = "Right Leg"
    Right_Leg.Size = vec3(1, 2, 1)
    Right_Leg.Parent = fakechar

    local HumanoidRootPart = inst("Part")
    HumanoidRootPart.Anchored = true
    HumanoidRootPart.CanCollide = false
    HumanoidRootPart.Name = "HumanoidRootPart"
    HumanoidRootPart.Size = vec3(2, 2, 1)
    HumanoidRootPart.Transparency = 1
    HumanoidRootPart.Parent = fakechar

    local Right_Shoulder = inst("Motor6D")
    Right_Shoulder.C0 = cfn(1, 0.5, 0)
    Right_Shoulder.C1 = cfn(-0.5, 0.5, 0)
    Right_Shoulder.Name = "Right Shoulder"
    Right_Shoulder.Part0 = Torso
    Right_Shoulder.Part1 = Right_Arm
    Right_Shoulder.Parent = Torso

    local Left_Shoulder = inst("Motor6D")
    Left_Shoulder.C0 = cfn(-1, 0.5, 0)
    Left_Shoulder.C1 = cfn(0.5, 0.5, 0)
    Left_Shoulder.Name = "Left Shoulder"
    Left_Shoulder.Part0 = Torso
    Left_Shoulder.Part1 = Left_Arm
    Left_Shoulder.Parent = Torso

    local Right_Hip = inst("Motor6D")
    Right_Hip.C0 = cfn(1, -1, 0)
    Right_Hip.C1 = cfn(0.5, 1, 0)
    Right_Hip.Name = "Right Hip"
    Right_Hip.Part0 = Torso
    Right_Hip.Part1 = Right_Leg
    Right_Hip.Parent = Torso

    local Left_Hip = inst("Motor6D")
    Left_Hip.C0 = cfn(-1, -1, 0)
    Left_Hip.C1 = cfn(-0.5, 1, 0)
    Left_Hip.Name = "Left Hip"
    Left_Hip.Part0 = Torso
    Left_Hip.Part1 = Left_Leg
    Left_Hip.Parent = Torso

    local Neck = inst("Motor6D")
    Neck.C0 = cfn(0, 1, 0)
    Neck.C1 = cfn(0, -0.5, 0)
    Neck.Name = "Neck"
    Neck.Part0 = Torso
    Neck.Part1 = Head
    Neck.Parent = Torso

    local RootJoint = inst("Motor6D")
    RootJoint.C0 = cfn(0, 0, 0)
    RootJoint.C1 = cfn(0, 0, 0)
    RootJoint.Name = "RootJoint"
    RootJoint.Part0 = HumanoidRootPart
    RootJoint.Part1 = Torso
    RootJoint.Parent = HumanoidRootPart
    
    do 
        local _ = fakechar:GetChildren()
        for i = 1, #_ do
            local c = _[i]
            if (not c:IsA("BasePart")) then continue end
            c.Material = 1584
            c.Color = c3n(0.52, 0.52, 0.55)
            
            local _ = inst("BoxHandleAdornment")
            _.Adornee = c
            _.AlwaysOnTop = true
            _.ZIndex = 10
            _.Color3 = colors['enabled']
            _.Size = c.Size
            _.Transparency = 0.5
            _.Parent = c
        end
    end
end

ui:Connect("Destroying", function() 
    for i,v in pairs(cons) do v:Disconnect() end
    for i,v in ipairs(ui:GetModules()) do 
        if (v.Toggle and v:IsEnabled()) then
            v:Toggle()
        end
    end
    
    for i = 1, #p_players_all do 
        local _ = p_players_all[i].cons
        for i = 1, #_ do _[i]:Disconnect() end
    end

    for i = 1, #p_players_nolfr do 
        local _ = p_players_nolfr[i].cons
        for i = 1, #_ do _[i]:Disconnect() end
    end
    
    fakechar:Destroy()
end)

local donetxt = ' <font color="rgb(255,87,68)">[Done]</font>'


local m_combat = ui:CreateMenu('Combat') do 
    local c_aimbot  = m_combat:AddMod('Aimbot')
    local c_antiaim = m_combat:AddMod('Anti-aim')
    local c_hitbox  = m_combat:AddMod('Hitboxes')
    local c_stare   = m_combat:AddMod('Stare')
    local c_tpbot   = m_combat:AddMod('TPbot')
    local c_trigbot = m_combat:AddMod('Triggerbot'..donetxt)
    
    
    -- Aimbot 
    do
        local c_aim_team   = c_aimbot:AddToggle('Team check')
        local c_aim_friend = c_aimbot:AddToggle('Friend check')
        local c_aim_lock   = c_aimbot:AddToggle('Player lock')
        local c_aim_mode   = c_aimbot:AddDropdown('Mode',true)
        local c_aim_smooth = c_aimbot:AddSlider('Smoothness',{min=0,max=100,cur=15,step=0.25})
        
        
        c_aim_team:SetTooltip('Blacklists players on your team from the aimbot check')
        c_aim_friend:SetTooltip('Blacklists players added to your Redline friends list from the aimbot check')
        c_aim_lock:SetTooltip('Locks onto the first valid player and doesn\'t switch from them')
        c_aim_mode:SetTooltip('The aimbot mode used')
        
        do
            c_aim_mode:AddOption('Mouse')
            :Select()
            :SetTooltip('Uses mousemoverel. May not be as stable as Camera, but it\'s significantly better.');
            
            c_aim_mode:AddOption('Camera')
            :SetTooltip('Makes the Camera face the target. Although it works good, it has compatibility issues with complex games');
        end
        
        
        c_aimbot:SetTooltip('Classic aimbot, use in FPS games like Arsenal')
    end
    -- Antiaim
    do 
        local c_aim_always = c_antiaim:AddToggle('Always spin'):SetTooltip('Spins while not moving')
        local c_aim_mode = c_antiaim:AddDropdown('Direction', true):SetTooltip('The mode Anti-aim uses')
        
        c_aim_mode:AddOption('Horizontal'):Select():SetTooltip('Only spins you around horizontally')
        c_aim_mode:AddOption('Omnidirectional'):SetTooltip('Spins you around in every direction')
        
        c_aim_always:Connect("Toggled",function(t) 
            if (c_antiaim:IsEnabled()) then
                c_antiaim:Disable()
                c_antiaim:Enable()
            end
        end)
        
        local aacon
        
        c_antiaim:Connect("Enabled",function() 
            if (c_aim_always:IsEnabled()) then 
                aacon = serv_rs.RenderStepped:Connect(function() 
                    local p = l_humrp.Position
                    l_humrp.CFrame = cfn(p, p+vec3(mr()-.5,0,mr()-.5))
                end)
            else
                aacon = serv_rs.RenderStepped:Connect(function() 
                    if (l_hum.MoveDirection.Magnitude < 0.02) then return end
                    
                    local p = l_humrp.Position
                    l_humrp.CFrame = cfn(p, p+vec3(mr()-.5,0,mr()-.5))
                end)
            end
        end)
        c_antiaim:Connect("Disabled",function() 
            if (aacon) then aacon:Disconnect() aacon = nil end 
        end)
        
        
        c_antiaim:SetTooltip('Prevents others from headshotting you by spinning you around')
    end
    -- Hitbox
    do 
        local c_hitb_team    = c_hitbox:AddToggle('Team check')
        local c_hitb_friend  = c_hitbox:AddToggle('Friend check')
        local c_hitb_display = c_hitbox:AddToggle('Show hitboxes')
        
        c_hitb_team:SetTooltip('Disables the expander for your teammates')
        c_hitb_friend:SetTooltip('Disables the expander for players on your Redline friends list')
        c_hitb_display:SetTooltip('Displays the expanded hitboxes')
        
        
        c_hitbox:SetTooltip('Hitbox expander, use in FPS or swordfighting games')
    end
    -- Stare
    do
        local c_stare_team   = c_stare:AddToggle('Team check')
        local c_stare_friend = c_stare:AddToggle('Friend check')
        
        c_stare_team:SetTooltip('Disables stare for your teammates')
        c_stare_friend:SetTooltip('Disables stare for your friends')
        
        
        
        c_stare:SetTooltip('Always faces you towards the nearest player, useful for sword fighting games')
    end
    -- Tp bot 
    do
        local c_tpbot_team   = c_tpbot:AddToggle('Team check')
        local c_tpbot_friend = c_tpbot:AddToggle('Friend check')
        local c_tpbot_face   = c_tpbot:AddToggle('Face center')
        
        c_tpbot_team:SetTooltip('Disables TPbot for your teammates')
        c_tpbot_friend:SetTooltip('Disables TPbot for your friends')
        c_tpbot_face:SetTooltip('Faces your character towards the position you\'re teleporting around')
        
        
        c_tpbot:SetTooltip('Teleports you around the nearest player. Can prevent you from being hit, also useful for swordfighting games')
        
        -- Check for closest player every .03s or so
        -- Get distance, check if less than user input 
        -- If so then lock onto them until their character dies or you move away
    end
    -- Trig bot
    do 
        local keydd = c_trigbot:AddDropdown('Click type'):SetTooltip('The key that gets pressed')
        local modedd = c_trigbot:AddDropdown('Shoot mode',true):SetTooltip('The type of click to do (i.e. auto = hold, semi = spam, etc.)')
        local needsheldh = c_trigbot:AddHotkey('Safety key'):SetTooltip('Triggerbot only clicks if this key is held')
        local rateslid = c_trigbot:AddSlider('Check rate',{min=0,max=0.1,step=0.01,cur=0.03}):SetTooltip('How often targets are checked for')
        local clickslid = c_trigbot:AddSlider('Click speed',{min=0,max=0.5,step=0.01,cur=0}):SetTooltip('The delay between clicks on Spam')
        local team = c_trigbot:AddToggle('Team check'):SetTooltip('Disables Triggerbot for your teammates')
        
        keydd:AddOption('Mouse1'):SetTooltip('Clicks MouseButton1 (left click)'):Select()
        keydd:AddOption('Mouse2'):SetTooltip('Clicks MouseButton2 (right click')
        
        modedd:AddOption('Spam'):SetTooltip('Spams button down while there\'s a target'):Select()
        modedd:AddOption('Hold'):SetTooltip('Holds button down while there\'s a target')
        
        
                
        local isholding = false -- if currently holding down
        local washolding = false -- if previously was holding down
        local isspamming = false -- if spamming
        local slowspam = false -- slow spam
        local prox = false
        local dont = false -- whether or not to delay a stop spamming
        local tcon1 -- triggerbot connection
        local tcon2 -- spam connection
        
        local mode = 'Spam'
        local key = 1
        local rate = 0.03
        local click = 0
        local needsheld = needsheldh:GetHotkey()
        
        needsheldh:Connect("HotkeySet",function(v)needsheld=v;end)
        rateslid:Connect("ValueChanged",function(v)rate=v;end)
        clickslid:Connect("ValueChanged",function(v)click=v;end)
        keydd:Connect("SelectionChanged",function(v)key=(v=='Mouse1'and 1 or 2);end)
        
        modedd:Connect("SelectionChanged",function(v) 
            mode = v
            if (c_trigbot:IsEnabled()) then
                c_trigbot:Disable()
                c_trigbot:Enable()
            end
        end)
        
        local wl
        c_trigbot:Connect("Enabled",function() 
            wl = {}
            wl['HumanoidRootPart'] = true
            wl['Left Leg'] = true
            wl['Right Leg'] = true
            wl['Left Arm'] = true
            wl['Right Arm'] = true
            wl['Torso'] = true
            wl['Head'] = true        
            wl['UpperTorso'] = true
            wl['LowerTorso'] = true
            wl['LeftUpperArm'] = true
            wl['LeftLowerArm'] = true
            wl['LeftHand'] = true
            wl['RightUpperArm'] = true
            wl['RightLowerArm'] = true
            wl['RightHand'] = true
            wl['LeftUpperLeg'] = true
            wl['LeftLowerLeg'] = true
            wl['LeftFoot'] = true
            wl['RightUpperLeg'] = true
            wl['RightLowerLeg'] = true
            wl['RightFoot'] = true
            
            local spam_handleclick
            local spam_handletarget
            local hold_handle
            
            spam_handleclick = function() 
                if (W_WindowOpen or (needsheld ~= nil and serv_uis:IsKeyDown(needsheld) == false)) then 
                    return 
                end
                
                if (isspamming) then
                    (key < 2 and mouse1click or mouse2click)();
                end
            end
            
            if (team:IsEnabled()) then
                
                if (game.PlaceId == 292439477) then
                    
                else
                
                    spam_handletarget = function() 
                        local t = l_mouse.Target
                        if (t) then
                            local a = wl[t.Name] and p_names[t.Parent.Name]
                            print(t.Parent.Name)
                            if (a and (a.Team ~= l_plr.Team)) then 
                                isspamming = true
                            else
                                prox = false
                                local mp = l_mouse.Hit.Position
                                for i = 1, #p_players do 
                                    local rp = p_players[i]['rp']
                                    if (rp and ((rp.Position - mp).Magnitude < 5)) then
                                        isspamming = true
                                        prox = true
                                        break
                                    end
                                end
                                
                                if (prox == false and isspamming == true) then 
                                    if (dont == false) then
                                        dont = true
                                        delay(0.02, function() 
                                            isspamming = false
                                            dont = false
                                        end)
                                    end
                                end
                            end
                        else
                            isspamming = false
                        end
                    end
                    
                    hold_handle = function() 
                        isholding = 1
                        local t = l_mouse.Target
                        local a = wl[t.Name] and p_names[t.Parent.Name]
                        if (t) then 
                            print(t.Parent.Name)
                            if (a and (a.Team ~= l_plr.Team)) then 
                                isholding = 2
                            else
                                local mp = l_mouse.Hit.Position
                                for i = 1, #p_players do 
                                    local rp = p_players[i]['rp']
                                    if (rp and ((rp.Position - mp).Magnitude < 5)) then
                                        isholding = 2
                                        break
                                    end
                                end
                            end
                            if (isholding == 2 and washolding == false) then 
                                if (W_WindowOpen or (needsheld ~= nil and serv_uis:IsKeyDown(needsheld) == false)) then 
                                else
                                    (key < 2 and mouse1press or mouse2press)();
                                    washolding = true
                                end
                            elseif (isholding == 1 and washolding == true) then
                                if (W_WindowOpen or needsheld and not serv_uis:IsKeyDown(needsheld)) then 
                                else
                                    (key < 2 and mouse1release or mouse2release)();
                                    washolding = false
                                end
                            end
                        else
                            if (isholding == 1 and washolding == true) then
                                if (W_WindowOpen or needsheld and not serv_uis:IsKeyDown(needsheld)) then 
                                else
                                    (key < 2 and mouse1release or mouse2release)();
                                    washolding = false
                                end
                            end
                        end
                    end
                
                end
            else
                spam_handletarget = function() 
                    local t = l_mouse.Target
                    if (t) then
                        if (wl[t.Name]) then 
                            isspamming = true
                        else
                            prox = false
                            local mp = l_mouse.Hit.Position
                            for i = 1, #p_players do 
                                local rp = p_players[i]['rp']
                                if (rp and ((rp.Position - mp).Magnitude < 5)) then
                                    isspamming = true
                                    prox = true
                                    break
                                end
                            end
                            
                            if (prox == false and isspamming == true) then 
                                if (dont == false) then
                                    dont = true
                                    delay(0.02, function() 
                                        isspamming = false
                                        dont = false
                                    end)
                                end
                            end
                        end
                    else
                        isspamming = false
                    end
                end
                
                hold_handle = function() 
                    isholding = 1
                    local t = l_mouse.Target
                    if (t) then
                        if (wl[t.Name]) then 
                            isholding = 2
                        else
                            local mp = l_mouse.Hit.Position
                            for i = 1, #p_players do 
                                local rp = p_players[i]['rp']
                                if (rp and ((rp.Position - mp).Magnitude < 5)) then
                                    isholding = 2
                                    break
                                end
                            end
                        end
                        if (isholding == 2 and washolding == false) then 
                            if (W_WindowOpen or (needsheld ~= nil and serv_uis:IsKeyDown(needsheld) == false)) then 
                            else
                                (key < 2 and mouse1press or mouse2press)();
                                washolding = true
                            end
                        elseif (isholding == 1 and washolding == true) then
                            if (W_WindowOpen or needsheld and not serv_uis:IsKeyDown(needsheld)) then 
                            else
                                (key < 2 and mouse1release or mouse2release)();
                                washolding = false
                            end
                        end
                    else
                        if (isholding == 1 and washolding == true) then
                            if (W_WindowOpen or needsheld and not serv_uis:IsKeyDown(needsheld)) then 
                            else
                                (key < 2 and mouse1release or mouse2release)();
                                washolding = false
                            end
                        end
                    end
                end
            end
            
            
            
            if (mode == 'Spam') then
                if (click == 0) then
                    tcon2 = serv_rs.RenderStepped:Connect(spam_handleclick)
                else
                    spawn(function() 
                        while c_trigbot:IsEnabled() do 
                            spam_handleclick()
                            wait(click)
                        end
                    end)
                end
                if (rate == 0) then
                    tcon1 = serv_rs.RenderStepped:Connect(spam_handletarget)
                else
                    spawn(function() 
                        while c_trigbot:IsEnabled() do 
                            spam_handletarget()
                            wait(rate)
                        end
                    end)
                end
            else
                print(rate, rate == 0)
                if (rate == 0) then
                    tcon1 = serv_rs.RenderStepped:Connect(hold_handle)
                else
                    spawn(function() 
                        while c_trigbot:IsEnabled() do 
                            hold_handle()
                            wait(rate)
                        end
                    end)
                end
            end
        end)
        
        c_trigbot:Connect("Disabled",function() 
            wl = nil
            
            if (tcon1) then tcon1:Disconnect() tcon1 = nil end
            if (tcon2) then tcon2:Disconnect() tcon2 = nil end
        end)
        
        c_trigbot:SetTooltip('Automatically clicks when you mouse over a player')
    end
end
local m_player = ui:CreateMenu('Player') do 
    local p_antiafk     = m_player:AddMod('Anti-AFK'..donetxt)
    local p_anticrash   = m_player:AddMod('Anti-crash'..donetxt)
    local p_antifling   = m_player:AddMod('Anti-fling'..donetxt)
    local p_antiwarp    = m_player:AddMod('Anti-warp'..donetxt)
    local p_autoclick   = m_player:AddMod('Auto clicker')
    local p_fancy       = m_player:AddMod('Fancy chat')
    local p_flag        = m_player:AddMod('Fakelag'..donetxt)
    local p_flashback   = m_player:AddMod('Flashback'..donetxt)
    --local p_ftools      = m_player:AddMod('Funky tools')
    --local p_gtweaks     = m_player:AddMod('Game tweaks')
    local p_pathfind    = m_player:AddMod('Pathfinder')
    local p_radar       = m_player:AddMod('Radar')
    local p_respawn     = m_player:AddMod('Respawn'..donetxt, 'Toggle')
    local p_waypoints   = m_player:AddMod('Waypoints'..donetxt)
    
    -- Anti afk
    do 
        local p_afk_mode   = p_antiafk:AddDropdown('Mode', true)
        do 
            local _ = p_afk_mode:AddOption('Standard')
            :Select()
            :SetTooltip('Disables connections related to player idling. Impossible to detect, has no side-effects');
            
            p_afk_mode:AddOption('Move on idle'):SetTooltip('Automatically moves your character when the client idles')
            p_afk_mode:AddOption('Walk around'):SetTooltip('Randomly moves your character around. Useful for games with more afk checks than the default roblox ones')
        end
        
        
        local c
        local p = 'Standard'
        p_antiafk:Connect("Enabled", function() 
            if (p == 'Standard') then
                ratio(l_plr.Idled)
                return 
            end
            if (p == 'Move on idle') then
                c = l_plr.Idled:Connect(function() 
                    l_hum:MoveTo(l_humrp.Position + vec3(0, 0, 2))
                end)
                return 
            end
	    
            if (p == 'Walk around') then
                spawn(function() 
                    local base = l_humrp.Position
                    while (p_antiafk:IsEnabled()) do 
                        wait(mr()*8)
                        l_hum:MoveTo(base + vec3(
                            (mr()-.5)*15,
                            0,
                            (mr()-.5)*15)
                        )
                    end
                end)
                return
            end
        end)
        p_antiafk:Connect("Disabled", function()
            unratio(l_plr.Idled)
            
            if (c) then
                c:Disconnect()
                c = nil
            end
        end)
        p_afk_mode:Connect("SelectionChanged", function(v) 
            p = v
            if (p_antiafk:IsEnabled()) then
                p_antiafk:Disable()
                p_antiafk:Enable()
            end
        end)
    end
    -- Anticrash
    do 
        local sc = game:GetService("ScriptContext")
        
        local amnt = p_anticrash:AddSlider('Delay',{min=0.1,max=5,cur=2,step=0.1},true):SetTooltip('Anti-crash sensitivity. <b>Setting this too low may mess with your game. Leave it at the default if you don\'t know what this does.</b>')
        
        amnt:Connect("ValueChanged",function(v) 
            if (p_anticrash:IsEnabled()) then
                sc:SetTimeout(v)
            end
        end)
        
        p_anticrash:Connect("Toggled",function(t) 
            if t then
                sc:SetTimeout(amnt:GetValue())
            else
                sc:SetTimeout(99)
            end
        end)
    end
    -- Antifling
    do 
        local mode = p_antifling:AddDropdown('Method', true)
        do 
            mode:AddOption('Anchor'):Select():SetTooltip('Anchors your character when someone gets close to you, works the best but limits movement')
            mode:AddOption('Noclip'):SetTooltip('Activates noclip. However, it\'s only good at stopping weak flings, and you will still be slightly pushed around')
            mode:AddOption('Teleport'):SetTooltip('Teleports you away from them. Very funny to use but you\'ll likely be flung')
        end
        local distance = 25
	    local pcon
        
        p_antifling:AddSlider('Distance',{min=1,max=50,cur=25,step=0.1}):SetTooltip('How close a player has to be to you to trigger the antifling'):Connect("ValueChanged",function(v)distance=v;end)
        
        
	    p_antifling:Connect("Enabled", function() 
            local m = mode:GetSelection()
            if (m == 'Anchor') then
                pcon = serv_rs.Heartbeat:Connect(function() 
                    local self_pos = l_humrp.Position
                    l_humrp.Anchored = false
                    for i = 1, #p_players do 
                        local plr = p_players[i]
                        local rp = plr.rp
                        if (rp and ((rp.Position - self_pos).Magnitude) < distance) then
                            l_humrp.Anchored = true
                            break
                        end
                    end		
                end)                
            elseif (m == 'Noclip') then
                pcon = serv_rs.Heartbeat:Connect(function() 
                    local self_pos = l_humrp.Position
                    for i = 1, #p_players do 
                        local plr = p_players[i]
                        local rp = plr.rp
                        if (rp and ((rp.Position - self_pos).Magnitude) < distance) then
                            local c = l_chr:GetChildren()
                            for i = 1, #c do 
                                local v = c[i]
                                if (v:IsA("BasePart")) then
                                    v.CanCollide = false    
                                end
                            end
                            break
                        end
                    end		
                end)
            elseif (m == 'Teleport') then
                pcon = serv_rs.Heartbeat:Connect(function() 
                    local self_pos = l_humrp.Position
                    for i = 1, #p_players do 
                        local plr = p_players[i]
                        local rp = plr.rp
                        if (rp and ((rp.Position - self_pos).Magnitude) < distance) then
                            l_humrp.CFrame += vec3(mr(-100,100)*.1,mr(0,20)*.1,mr(-100,100)*.1)
                            break
                        end
                    end		
                end)
            end
	    end)
	    p_antifling:Connect("Disabled", function() 
	        if (pcon) then pcon:Disconnect() pcon = nil end		
	    end)
    
    
	    mode:Connect("SelectionChanged", function()
	        if (p_antifling:IsEnabled()) then
	            p_antifling:Disable()
	            p_antifling:Enable()
	        end
	    end)
    
	    mode:SetTooltip('The method Antifling uses')
    end
    -- Antiwarp
    do 
        local lerpslider = p_antiwarp:AddSlider('Lerp',{min=0,max=1,cur=1,step=0.01}):SetTooltip('How much you will be teleported back when antiwarp gets triggered')
        local distslider = p_antiwarp:AddSlider('Distance',{min=1,max=150,cur=20,step=0.1}):SetTooltip('How far you\'d have to be teleported before it gets set off')
        local lerp = 1
        local dist = 20
        
        lerpslider:Connect("ValueChanged",function(v)lerp=v;end)
        distslider:Connect("ValueChanged",function(v)dist=v;end)
        local con
        local cf1 = l_humrp and l_humrp.CFrame or cfn(0,0,0)
        local cf2 = l_humrp and l_humrp.CFrame or cfn(0,0,0)
        p_antiwarp:Connect("Enabled",function() 
            ratio(l_humrp.Changed)
            ratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            cf2 = l_humrp.CFrame
            con = serv_rs.Heartbeat:Connect(function() 
                cf1 = l_humrp.CFrame 
                if ((cf1.Position - cf2.Position).Magnitude > dist) then
                    local _ = cf1:lerp(cf2, lerp)
                    cf2 = _
                    l_humrp.CFrame = _
                else
                    cf2 = cf1
                end
            end)
        end)
        p_antiwarp:Connect("Disabled",function() 
            if (con) then con:Disconnect() con=nil end
            
            unratio(l_humrp.Changed)
            unratio(l_humrp:GetPropertyChangedSignal("CFrame"))
        end)
    end
    -- Autoclick
    do 
        local buttontype = p_autoclick:AddDropdown('Button',true)
        buttontype:AddOption('Left click')
        buttontype:AddOption('Right click')
        buttontype:AddOption('Custom')
        
        local customkey = p_autoclick:AddHotkey()
        
    end 
    -- Fake lag
    do 
        local methoddd = p_flag:AddDropdown('Method',true)
        methoddd:AddOption('Fake'):SetTooltip('Doesn\'t affect your network usage. Visualizer is more accurate than Fake, but still may have desync issues'):Select()
        methoddd:AddOption('Real'):SetTooltip('Limits your actual network usage. May lag more than just your movement. Visualizer is less accurate than Fake, but lag looks more realistic')
        
        local method = 'Fake'
        
        local rateslid = p_flag:AddSlider('Amount',{min=1,max=10,step=0.1,cur=3}):SetTooltip('Lag amount. The larger the number, the more lag you have')
        local lag = 3
        
        rateslid:Connect("ValueChanged",function(v)lag=v;end)
        
        
        local glitchrp
        p_flag:Connect("Enabled",function() 
            local fakerp = fakechar.HumanoidRootPart
            
            
            fakechar.Parent = workspace
            if (method == 'Fake') then
                local s = method
                spawn(function() 
                    while true do 
                        if (not p_flag:IsEnabled() or method ~= s) then break end
                        wait((mr(20,40)*.1) / lag)
                        if (not p_flag:IsEnabled() or method ~= s) then break end
                        
                        fakechar.Parent = workspace
                        fakerp.CFrame = l_humrp.CFrame
                        
                        glitchrp = l_humrp:Clone()
                        glitchrp.Parent = workspace
                        
                        wait(mr(1,lag)*.1)
                        fakechar.Parent = nil
                        if (glitchrp) then 
                            glitchrp:Destroy()
                        end
                    end 
                end)
            else
                spawn(function() 
                    local s = method
                    while true do 
                        if (not p_flag:IsEnabled() or method ~= s) then break end
                        wait(5 / lag)
                        if (not p_flag:IsEnabled() or method ~= s) then break end
                        
                        
                        fakechar.Parent = workspace
                        fakerp.CFrame = l_humrp.CFrame
                        
                        serv_net:SetOutgoingKBPSLimit(1)
                        
                        wait(mr(1,lag)*.1)
                        fakechar.Parent = nil
                        serv_net:SetOutgoingKBPSLimit(9e9)
                    end 
                end)
            end 
            
        end)
        
        p_flag:Connect("Disabled",function() 
            if (glitchrp) then glitchrp:Destroy() glitchrp = nil end 
            
            fakechar.Parent = nil
            serv_net:SetOutgoingKBPSLimit(9e9)
        end)
        
        methoddd:Connect("SelectionChanged",function(v) 
            method = v
            if (p_flag:IsEnabled()) then
                p_flag:Disable()
                p_flag:Enable()
            end
        end)
    end
    -- Flashback
    do 
        local flash_delay = p_flashback:AddSlider("Delay", {min=0,max=5,cur=0,step=0.1})
        flash_delay:SetTooltip('How long to wait before teleporting you back')
        
        local fb_con
        local resp_con
        
        p_flashback:Connect("Enabled", function() 
            
            local function bind(h) 
                h.Died:Connect(function() 
                    local pos = l_humrp.CFrame
                    l_plr.CharacterAdded:Wait()
                    delay(flash_delay:GetValue(), function() l_humrp.CFrame = pos end)
                end)
            end
            
            resp_con = l_plr.CharacterAdded:Connect(function() 
                wait()
                bind(l_hum)
            end)
            
            bind(l_hum)
        end)
        p_flashback:Connect("Disabled", function() 
            fb_con:Disconnect()
            resp_con:Disconnect()
        end)
    end
    -- Respawn
    do 
        p_respawn:Connect("Enabled", function() 
            l_hum:Destroy()
        end)
    end
    -- Waypoints
    do
        local waypoints
        local makewp = p_waypoints:AddInput('Make waypoint')
        local gotowp = p_waypoints:AddInput('Goto waypoint')
        local delewp = p_waypoints:AddInput('Delete waypoint')
        local deleall = p_waypoints:AddButton('Delete all waypoints')
        
        local folder
        
        local cg = game.CoreGui
        
        local function makewaypoint(text) 
            local new = {}
            new[1] = text
            new[2] = l_humrp.CFrame
            
            local a = inst("BillboardGui")
            local b = inst("BoxHandleAdornment")
            local c = inst("Part")
            local d = inst("TextLabel")
            
            
            c.Anchored = true
            c.CanCollide = false
            c.CanTouch = false
            c.Color = c3n(0,0,0)
            c.Name = getnext()
            c.Size = vec3(1, 1, 1)
            c.Position = new[2].Position
            c.Transparency = 1
            
            a.Adornee = c
            a.AlwaysOnTop = true
            a.LightInfluence = 0.8
            a.Size = dim2(1.5, 30, 0.75, 15)
            
            b.Adornee = c
            b.AlwaysOnTop = false
            b.ZIndex = 10
            b.Color3 = c3n(0,0,0)
            b.Size = vec3(1, 200, 1)
            b.SizeRelativeOffset = vec3(0, 200, 0)
            b.Transparency = 0.5
            
            d.BackgroundColor3 = colors['bg_header']
            d.BackgroundTransparency = 0.6
            d.BorderColor3 = colors['outline']
            d.BorderSizePixel = 1
            d.Font = 'SourceSans'
            d.Size = dim2sca(1,1)
            d.Text = text
            d.TextColor3 = colors['text1']
            d.TextScaled = true
            d.TextStrokeColor3 = colors['shadow']
            d.TextStrokeTransparency = 0
            
            
            
            c.Parent = folder
            a.Parent = folder
            b.Parent = folder
            d.Parent = a
            
            
            
            new[3] = a
            new[4] = b
            new[5] = c
            new[6] = d
            
            ins(waypoints, new)
        end
        
        
        makewp:Connect("Unfocused",function(text) 
            if (not p_waypoints:IsEnabled()) then p_waypoints:Enable() end
            
            for i = 1, #waypoints do
                local wp = waypoints[i]
                if (wp[1] == text) then
                    for i = 3, 5 do wp[i]:Destroy() end
                    rem(waypoints, i)
                    break
                end
            end 
            
            makewaypoint(text)
        end)
        
        delewp:Connect("Unfocused",function(text) 
            for i = 1, #waypoints do
                local wp = waypoints[i]
                if (wp[1] == text) then
                    for i = 3, 5 do wp[i]:Destroy() end
                    rem(waypoints, i)
                    break
                end
            end 
        end)
        
        gotowp:Connect("Unfocused",function(text) 
            for i = 1, #waypoints do
                local wp = waypoints[i]
                if (wp[1] == text) then
                    ratio(l_humrp.Changed)
                    ratio(l_humrp:GetPropertyChangedSignal("CFrame"))
                    l_humrp.CFrame = wp[2]
                    unratio(l_humrp.Changed)
                    unratio(l_humrp:GetPropertyChangedSignal("CFrame"))
                end
            end 
        end)
        
        deleall:Connect("Clicked",function() 
            for i = 1, #waypoints do
                local wp = waypoints[i]
                for i = 3, 5 do wp[i]:Destroy() end
                waypoints[i] = nil
            end
            cle(waypoints)
        end)
        
        p_waypoints:Connect("Enabled",function() 
            waypoints = {}
            
            folder = inst("Folder")
            folder.Name = getnext()
            folder.Parent = game.CoreGui
        end)
        
        p_waypoints:Connect("Disabled",function() 
            folder:Destroy()
            
            
            for i = 1, #waypoints do
                local wp = waypoints[i]
                for i = 3, 5 do wp[i]:Destroy() end
                waypoints[i] = nil
            end
            waypoints = nil
            
        end)
        
        deleall:SetTooltip('Deletes all waypoints. Preferable over untoggling and retoggling')
        makewp:SetTooltip('Makes a waypoint at your position with the name you type in')
        delewp:SetTooltip('Deletes all waypoints matching the name you type in')
    end
    
    p_antiafk:SetTooltip('Prevents you from being disconnected due to idling for too long')
    p_anticrash:SetTooltip('Prevents game scripts from while true do end\'ing you')
    p_antifling:SetTooltip('Prevents skids from flinging you, has several modes and a sensitivity option')
    p_antiwarp:SetTooltip('Prevents you from being teleported. Has options for sensitivity and lerp')
    p_autoclick:SetTooltip('Standard autoclicker')
    p_fancy:SetTooltip('Converts your chat letters into a fancier version. Has a toggleable mode and a non-toggleable mode')
    p_flag:SetTooltip('Makes your character look laggy. Similar to blink')
    p_flashback:SetTooltip('Teleports you back after you die. Has options for delayed teleport')
    --p_ftools:SetTooltip('Lets you equip and unequip multiple tools at once')
    --p_gtweaks:SetTooltip('Lets you configure various misc "forceable" settings like 3rd person, chat, inventories, and more')
    p_pathfind:SetTooltip('Pathfinder. Kinda like Baritone')
    p_radar:SetTooltip('Radar that displays where other players are')
    p_respawn:SetTooltip('Better version of resetting, can fix some glitches with reanimations')
    p_waypoints:SetTooltip('Lets you save positions and teleport to them later')
end
local m_movement = ui:CreateMenu('Movement') do 
    local m_airjump   = m_movement:AddMod('Air jump'..donetxt)
    local m_blink     = m_movement:AddMod('Blink'..donetxt)
    local m_clicktp   = m_movement:AddMod('Click TP'..donetxt)
    local m_flight    = m_movement:AddMod('Flight'..donetxt)
    local m_float     = m_movement:AddMod('Float'..donetxt)
    local m_highjump  = m_movement:AddMod('High jump')
    local m_jesus     = m_movement:AddMod('Jesus')
    local m_jetpack   = m_movement:AddMod('Jetpack')
    local m_noclip    = m_movement:AddMod('Noclip')
    local m_nofall    = m_movement:AddMod('Nofall'..donetxt)
    local m_noslow    = m_movement:AddMod('Noslowdown')
    local m_parkour   = m_movement:AddMod('Parkour'..donetxt)
    local m_phase     = m_movement:AddMod('Phase')
    local m_safewalk  = m_movement:AddMod('Safewalk')
    local m_speed     = m_movement:AddMod('Speed'..donetxt)
    local m_spider    = m_movement:AddMod('Spider')
    local m_step      = m_movement:AddMod('Step')
    local m_velocity  = m_movement:AddMod('Velocity'..donetxt)
    -- Airjump
    do 
        local mode = m_airjump:AddDropdown('Mode',true)
        mode:AddOption('Jump'):SetTooltip('Simply just jumps. If the game has something to prevent jumps, this will not work'):Select()
        mode:AddOption('Velocity'):SetTooltip('Changes your velocity. Bypasses jump prevention, but this is not as realistic as actually jumping')
        local velmount = m_airjump:AddSlider('Velocity amount', {min=-500,max=500,cur=70})
        
        local vel = 70
        local ajcon
        
        velmount:Connect("ValueChanged",function(v)vel=v;end)
        
        m_airjump:Connect("Enabled", function() 
            if (mode:GetSelection() == 'Jump') then
                if gpe then return end
                ajcon = serv_uis.InputBegan:Connect(function(io, gpe) 
                    if (io.KeyCode.Value == 32) then
                        l_hum:ChangeState(3)
                    end
                end)
            else
                ajcon = serv_uis.InputBegan:Connect(function(io, gpe) 
                    if gpe then return end 
                    if (io.KeyCode.Value == 32) then
                        l_humrp.Velocity = vec3(0, vel, 0)
                    end
                end)
            end
        end)
    
        m_airjump:Connect("Disabled", function() 
            ajcon:Disconnect()
        end)
        
        mode:Connect("SelectionChanged",function() 
            if (m_airjump:IsEnabled()) then
                m_airjump:Disable() 
                m_airjump:Enable()
            end
        end)
        
        mode:SetTooltip('Mode for Airjump to use')
        velmount:SetTooltip('Amount to set your velocity to for the Velocity mode')
    end
    -- Blink
    do 
        --local methoddd = m_blink:AddDropdown('Method',true)
        --methoddd:AddOption('Fake'):SetTooltip('Doesn\'t affect your network usage. Simply exploits a roblox glitch to freeze your character'):Select()
        --methoddd:AddOption('Network'):SetTooltip('Limits your actual network usage. Lags more than just your movement')
        
        local b 
        
        m_blink:Connect("Enabled",function() 
            --local method = methoddd:GetSelection()
            
            --if (method == 'Fake') then
            b = l_humrp:Clone()
            b.Parent = workspace
            
            fakechar.HumanoidRootPart.CFrame = l_humrp.CFrame
            fakechar.Parent = workspace
            --elseif (method == 'Network') then
            --    serv_net:SetOutgoingKBPSLimit(1)
            --end
        end)
        
        m_blink:Connect("Disabled",function() 
            if (b) then b:Destroy() b = nil end 
            
            fakechar.Parent = nil
            --serv_net:SetOutgoingKBPSLimit(9e9)
        end)
    end
    -- Click tp
    do 
        local k = m_clicktp:AddHotkey('Teleport key'):SetTooltip('The key you have to be pressing in order to TP')
        local key = Enum.KeyCode.LeftControl
        k:Connect("HotkeySet",function(kc)key=kc;end)
        k:SetHotkey(Enum.KeyCode.LeftControl)
        
        local mc
        
        m_clicktp:Connect("Toggled",function(t) 
            if (t) then
                local offset = vec3(0, 3, 0)
                mc = l_mouse.Button1Down:Connect(function() 
                    if (key) then
                        if (serv_uis:IsKeyDown(key)) then
                            local lv = l_humrp.CFrame.LookVector
                            local p = l_mouse.Hit.Position + offset
                            l_humrp.CFrame = cfn(p, p+lv)
                        end
                    else
                        local lv = l_humrp.CFrame.LookVector
                        local p = l_mouse.Hit.Position + offset
                        l_humrp.CFrame = cfn(p, p+lv)
                    end
                end)
            else
                mc:Disconnect()
            end
        end)
        
    end
    -- Float
    do 
        local mode = m_float:AddDropdown('Mode'):SetTooltip('What method Float will use')
        mode:AddOption('Undetectable'):SetTooltip('Directly changes your velocity. Isn\'t perfect, but it\'s undetectable'):Select()
        mode:AddOption('Velocity'):SetTooltip('Uses a bodymover. Has better results, but is easier to detect')
        
        local vel = m_float:AddSlider('Velocity',{min=-10,cur=0,max=10,step=0.1}):SetTooltip('The amount of velocity you\'ll have when floating')
        local amnt = 0
        
        vel:Connect("ValueChanged",a)
        
        mode:Connect("SelectionChanged",function() 
            if (m_float:IsEnabled()) then
                m_float:Disable()
                m_float:Enable()
            end
        end)
        
        local fcon
        local finst
        
        local a = function(v) amnt = v; end
        local b = function(v) finst.Velocity = vec3(0, v, 0) end
        
        
        
        m_float:Connect("Enabled",function() 
            local mode = mode:GetSelection()
            if (mode == 'Undetectable') then
                fcon = serv_rs.Heartbeat:Connect(function() 
                    local vel = l_humrp.Velocity
                    
                    l_humrp.Velocity = vec3(vel.X, amnt+1.15, vel.Z)
                end)
            elseif (mode == 'Velocity') then
                ratio(l_humrp.ChildAdded)
                ratio(l_humrp.DescendantAdded)
                
                finst = inst("BodyVelocity")
                finst.MaxForce = vec3(0, 9e9, 0)
                finst.Velocity = vec3(0, vel:GetValue(), 0)
                finst.Parent = l_humrp
                
                vel:Connect("ValueChanged",b)
            end
        end)
        m_float:Connect("Disabled",function() 
            if (finst) then finst:Destroy(); finst = nil end
            if (fcon) then fcon:Disconnect() fcon = nil end
            
            vel:Connect("ValueChanged",a)
            
            unratio(l_humrp.ChildAdded)
            unratio(l_humrp.DescendantAdded)
        end)
        
        
        
        
    end
    -- Nofall
    do 
        local modedd = m_nofall:AddDropdown('Mode', true):SetTooltip('The method Nofall uses')
        modedd:AddOption('Smart'):SetTooltip('Boosts you up a bit before you hit the ground'):Select()
        modedd:AddOption('Drop'):SetTooltip('Instantly teleports you down')
        
        local smarsens_slid = m_nofall:AddSlider('Smart vel. threshold',{min=30,max=300,cur=100,step=0.1}):SetTooltip('How fast you need to be falling before it can boost you')
        local dropsens_slid = m_nofall:AddSlider('Drop sensitivity',{min=5,max=50,cur=10,step=0.1}):SetTooltip('How high the fall has to be before it will teleport you')
        
        local smarsens = -100
        local dropsens = 10
        
        smarsens_slid:Connect("ValueChanged",function(v)smarsens=-v;end)
        dropsens_slid:Connect("ValueChanged",function(v)dropsens=v;end)
        
        local plrcon
        local rcon
        
        m_nofall:Connect("Enabled",function() 
            local down = vec3(0, -1000000, 0)
            local p = RaycastParams.new()
            p.FilterDescendantsInstances = {l_chr}
            p.FilterType = Enum.RaycastFilterType.Blacklist
            
            plrcon = l_plr.CharacterAdded:Connect(function(c) 
                p.FilterDescendantsInstances = {c}
            end)
            
            if (modedd:GetSelection() == 'Drop') then
                rcon = serv_rs.Heartbeat:Connect(function() 
                    local j = workspace:Raycast(l_humrp.Position, down, p)
                    if (j) then
                        if (j.Distance > dropsens) then
                            local hv = l_humrp.Velocity
                            if (hv.Y < 0) then
                                local p = j.Position
                                l_humrp.CFrame = cfn(p, p + l_humrp.CFrame.LookVector)
                                l_humrp.Velocity = vec3(hv.X, 10, hv.Z)
                            end
                        end
                    end
                end)
            else
                local holding = false
                rcon = serv_rs.Heartbeat:Connect(function() 
                    local j = workspace:Raycast(l_humrp.Position, down, p)
                    if (j and j.Distance < 8) then
                        if (holding) then return end
                        
                        local hv = l_humrp.Velocity
                        if (hv.Y < smarsens) then
                            l_humrp.Velocity = vec3(hv.X, 30, hv.Z)
                            holding = true
                            delay(0.5, function()
                                holding = false
                            end)
                        end
                    end
                end)
            end
        end)
        
        m_nofall:Connect("Disabled",function() 
            if (rcon) then rcon:Disconnect() rcon = nil end
            if (plrcon) then plrcon:Disconnect() plrcon = nil end
        end)
        
        modedd:Connect("SelectionChanged",function() 
            if (m_nofall:IsEnabled()) then
                m_nofall:Disable()
                m_nofall:Enable()
            end
        end)
    end
    -- Parkour
    do 
        local delayslid = m_parkour:AddSlider('Delay before jumping',{min=0,max=0.2,cur=0,step=0.01}):SetTooltip('How long to wait before jumping')
        local delay = 0
        local humcon
        
        delayslid:Connect("ValueChanged",function(v)delay=v;end)
        
        m_parkour:Connect("Toggled",function(t) 
            if (t) then
                local a = Enum.Material.Air
                humcon = l_hum:GetPropertyChangedSignal("FloorMaterial"):Connect(function() 
                    if (l_hum.FloorMaterial == a) then
                        if (delay == 0) then
                            if (l_hum.Jump) then return end
                            l_hum:ChangeState(3)
                        else
                            wait(delay)
                            if (l_hum.Jump) then return end
                            l_hum:ChangeState(3)
                        end
                    end
                end)
            else
                if (humcon) then humcon:Disconnect() humcon = nil end
            end
        end)
        
    end
    -- Flight
    do 
        local ascend_h = m_flight:AddHotkey('Ascend key')
        local descend_h = m_flight:AddHotkey('Descend key')
        local mode = m_flight:AddDropdown('Method', true)
        local turndir = m_flight:AddDropdown('Turn direction')
        local speedslider = m_flight:AddSlider('Speed',{min=0,max=300,step=0.1,cur=30})
        local camera = m_flight:AddToggle('Camera-based')
        
        
        mode:AddOption('Standard'):SetTooltip('Standard CFlight. Undetectable (within reason), unlike other scripts such as Inf Yield'):Select()
        mode:AddOption('Smooth'):SetTooltip('Just like Standard, but smooth')
        mode:AddOption('Vehicle'):SetTooltip('BodyPosition CFlight, may let you fly with vehicles in some games like Jailbreak. Has more protection than other scripts, but is still more detectable than Standard')
        
        
        turndir:AddOption('XYZ'):SetTooltip('Follows the camera\'s direction exactly. <b>This is the typical option in every other flight script</b>'):Select()
        turndir:AddOption('XZ'):SetTooltip('Follows the camera\'s direction on all axes but Y')
        turndir:AddOption('Up'):SetTooltip('Faces straight up, useful for carrying players')
        turndir:AddOption('Down'):SetTooltip('I really hope you can figure this one out')
        
        local fi1 -- flight inst 1 
        local fi2 -- flight inst 2  
        local fcon -- flight connection
        
        
        local cscon -- camera subject connection (vehicle fly)
        local clvcon -- connection to update camera look vector
        local clv -- camera look vector
        local normclv -- normal unmodified one
        
        local ask = Enum.KeyCode.E-- keycode for ascension
        local dsk = Enum.KeyCode.Q-- keycode for descension
        
        local speed = 30 -- speed 
        
        local cambased = true 
        camera:Enable()
        
        ascend_h:Connect("HotkeySet",function(j)ask=j or 0;end)
        descend_h:Connect("HotkeySet",function(k)dsk=k or 0;end)
        camera:Connect("Toggled",function(t)
            cambased=t;
            if (m_flight:IsEnabled()) then 
                m_flight:Disable()
                m_flight:Enable() 
            end
        end)
        turndir:Connect("SelectionChanged",function() 
            if (m_flight:IsEnabled()) then 
                m_flight:Disable()
                m_flight:Enable() 
            end
        end)
        mode:Connect("SelectionChanged",function() 
            if (m_flight:IsEnabled()) then 
                m_flight:Disable()
                m_flight:Enable() 
            end
        end)
        speedslider:Connect("ValueChanged",function(v)speed=v;end)
        
        m_flight:Connect("Enabled", function()
            clv = l_cam.CFrame.LookVector 
            normclv = clv
            
            ratio(l_humrp.Changed)
            ratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            ratio(l_humrp:GetPropertyChangedSignal("Velocity"))
            
            local curmod = mode:GetSelection()
            local curturn = turndir:GetSelection()
            
            local upp, downp, nonep = vec3(0, 1, 0), vec3(0, -1, 0), vec3(0,0,0)
            
            
            if (curturn == 'XYZ') then 
                clvcon = l_cam:GetPropertyChangedSignal("CFrame"):Connect(function() 
                    normclv = l_cam.CFrame.LookVector
                    clv = normclv
                end)
            elseif (curturn == 'XZ') then
                clvcon = l_cam:GetPropertyChangedSignal("CFrame"):Connect(function() 
                    normclv = l_cam.CFrame.LookVector
                    clv = vec3(normclv.X, 0, normclv.Z)
                end)
            elseif (curturn == 'Up') then
                if (cambased) then
                    clvcon = l_cam:GetPropertyChangedSignal("CFrame"):Connect(function() 
                        normclv = l_cam.CFrame.LookVector
                    end)
                end
                
                clv = upp
            elseif (curturn == 'Down') then
                if (cambased) then
                    clvcon = l_cam:GetPropertyChangedSignal("CFrame"):Connect(function() 
                        normclv = l_cam.CFrame.LookVector
                    end)
                end
                
                clv = downp
            end
            
            
            
            
            if (curmod == 'Standard') then
                local base = l_humrp.CFrame
                
                
                if (cambased) then
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        local f,b = serv_uis:IsKeyDown(119), serv_uis:IsKeyDown(115)
                        
                        l_hum:ChangeState(1)
                        l_humrp.Velocity = nonep
                        
                        base += (l_hum.MoveDirection * dt * 3 * speed)
                        base += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        base += ((f and vec3(0, normclv.Y, 0) or nonep) - (b and vec3(0, normclv.Y, 0) or nonep)*(dt*3*speed))
                        
                        local b = base.Position
                        l_humrp.CFrame = cfn(b, b + clv)
                    end)
                else
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        
                        l_hum:ChangeState(1)
                        l_humrp.Velocity = nonep
                        
                        base += (l_hum.MoveDirection * dt * 3 * speed)
                        base += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        
                        local b = base.Position
                        l_humrp.CFrame = cfn(b, b + clv)
                    end)
                end
            elseif (curmod == 'Smooth') then
                local base = l_humrp.CFrame
                
                fi1 = inst("Part")
                fi1.CFrame = base
                fi1.Transparency = 0.8
                fi1.CanCollide = false
                fi1.CanTouch = false
                fi1.Anchored = false
                fi1.Size = vec3(1, 1, 1)
                fi1.Parent = workspace
                
                local pos = inst("BodyPosition")
                pos.Position = base.Position
                pos.D = 1900
                pos.P = 125000
                pos.MaxForce = vec3(9e9, 9e9, 9e9)
                pos.Parent = fi1
                local gyro = inst("BodyGyro")
                gyro.D = 1900
                gyro.P = 125000
                gyro.MaxTorque = vec3(9e9, 9e9, 9e9)
                gyro.Parent = fi1
                
                if (cambased) then
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        local f,b = serv_uis:IsKeyDown(119), serv_uis:IsKeyDown(115)
                        
                        l_hum:ChangeState(1)
                        l_humrp.Velocity = nonep
                        
                        base += (l_hum.MoveDirection * dt * 3 * speed)
                        base += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        base += ((f and vec3(0, normclv.Y, 0) or nonep) - (b and vec3(0, normclv.Y, 0) or nonep)*(dt*3*speed))
                        
                        local b = base.Position
                        
                        pos.Position = b
                        gyro.CFrame = cfn(b, b + clv)
                        
                        l_humrp.CFrame = fi1.CFrame 
                    end)
                else
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        
                        l_hum:ChangeState(1)
                        l_humrp.Velocity = nonep
                        
                        base += (l_hum.MoveDirection * dt * 3 * speed)
                        base += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        
                        local b = base.Position
                        pos.Position = b
                        gyro.CFrame = cfn(b, b + clv)
                        
                        l_humrp.CFrame = fi1.CFrame                     
                    end)
                end
            elseif (curmod == 'Vehicle') then
                local base = l_humrp.CFrame
                
                ratio(l_humrp.ChildAdded)
                ratio(l_humrp.DescendantAdded)
                
                fi1 = inst("BodyPosition")
                fi1.Position = base.Position
                fi1.D = 1900
                fi1.P = 125000
                fi1.MaxForce = vec3(9e9, 9e9, 9e9)
                fi1.Parent = l_humrp
                
                fi2 = inst("BodyGyro")
                fi2.D = 1900
                fi2.P = 125000
                fi2.MaxTorque = vec3(9e9, 9e9, 9e9)
                fi2.Parent = l_humrp
                
                cscon = l_cam:GetPropertyChangedSignal("CameraSubject"):Connect(function() 
                    l_cam.CameraSubject = l_hum
                end)
                
                if (cambased) then
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        local f,b = serv_uis:IsKeyDown(119), serv_uis:IsKeyDown(115)
                        
                        l_hum:ChangeState(1)
                        --l_humrp.Velocity = vec3(0,0,0)
                        
                        base += (l_hum.MoveDirection * dt * 3 * speed)
                        base += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        base += ((f and vec3(0, normclv.Y, 0) or nonep) - (b and vec3(0, normclv.Y, 0) or nonep)*(dt*3*speed))
                        
                        local b = base.Position
                        
                        fi1.Position = b
                        fi2.CFrame = cfn(b, b + clv)
                    end)
                else
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        
                        l_hum:ChangeState(1)
                        --l_humrp.Velocity = vec3(0,0,0)
                        
                        base += (l_hum.MoveDirection * dt * 3 * speed)
                        base += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        
                        local b = base.Position
                        fi1.Position = b
                        fi2.CFrame = cfn(b, b + clv)                   
                    end)
                end
            end
        end)
        
        m_flight:Connect("Disabled",function() 
            if (fcon) then fcon:Disconnect() fcon = nil end 
            if (clvcon) then clvcon:Disconnect() clvcon = nil end
            if (fi1) then fi1:Destroy() fi1 = nil end
            if (fi2) then fi2:Destroy() fi2 = nil end
            if (cscon) then cscon:Destroy() cscon = nil end 
            l_hum:ChangeState(8)
            
            unratio(l_humrp.Changed)
            unratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            unratio(l_humrp:GetPropertyChangedSignal("Velocity"))
            unratio(l_humrp.ChildAdded)
            unratio(l_humrp.DescendantAdded)
        end)
        
        
        ascend_h:SetTooltip('When pressed you vertically ascend (move up)'):SetHotkey(Enum.KeyCode.E)
        descend_h:SetTooltip('When pressed you vertically descend (move down)'):SetHotkey(Enum.KeyCode.Q)
        mode:SetTooltip('The method Flight uses')
        speedslider:SetTooltip('The speed of your flight')
        camera:SetTooltip('When enabled, the direction of your camera affects your Y movement. <b>Leaving this on is the typical option in every other flight script</b>')
        turndir:SetTooltip('The direction your character faces')
    end
    -- Speed
    do 
        local mode = m_speed:AddDropdown('Mode',true)
        mode:AddOption('Standard'):SetTooltip('Standard CFrame speed. <b>Mostly</b> undetectable, unlike other scripts such as Inf Yield. Also known as TPWalk'):Select()
        mode:AddOption('Velocity'):SetTooltip('Changes your velocity, doesn\'t use any bodymovers. Because of friction, Velocity typically won\'t increase your speed unless it\'s set high or you jump.')
        mode:AddOption('Bhop'):SetTooltip('The exact same as Velocity, but it spam jumps. Useful for looking legit in games with bhop mechanics, like Arsenal')
        mode:AddOption('Part'):SetTooltip('Pushes you physically with a clientside part. Can also affect vehicles in certain games, such as Jailbreak')
        mode:AddOption('WalkSpeed'):SetTooltip('<font color="rgb(255,64,64)"><b>Insanely easy to detect. There\'s no good reason to use this mode. Doesn\'t come with any protection. Use Standard instead.</b></font>')
        
        local speedslider = m_speed:AddSlider('Speed',{min=0,max=200,cur=50,step=0.1})
        local speed = 50
        speedslider:Connect("ValueChanged",function(v)speed=v;end)
        local part
        local scon
        
        local ev = serv_rs.Heartbeat
        
        m_speed:Connect("Enabled",function() 
            local mode = mode:GetSelection()
            
            ratio(l_hum.Changed)
            ratio(l_hum:GetPropertyChangedSignal("Jump"))
            ratio(l_humrp.Changed)
            ratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            ratio(l_humrp:GetPropertyChangedSignal("Velocity"))
            
            if (scon) then scon:Disconnect() scon = nil end
            
            if (mode == 'Standard') then
                scon = ev:Connect(function(dt) 
                    l_humrp.CFrame += l_hum.MoveDirection * (5 * dt * speed)
                end)
            elseif (mode == 'Velocity') then
                scon = ev:Connect(function(dt) 
                    l_humrp.Velocity += l_hum.MoveDirection * (5 * dt * speed)
                end)
            elseif (mode == 'Bhop') then
                scon = serv_rs.RenderStepped:Connect(function(dt) 
                    local md = l_hum.MoveDirection
                    
                    l_humrp.Velocity += md * (5 * dt * speed)
                    l_hum.Jump = not (md.Magnitude < 0.01 and true or false)
                end)
            elseif (mode == 'Part') then
                part = inst("Part")
                part.Transparency = 0.8
                part.Size = vec3(4,4,1)
                part.CanTouch = false
                part.CanCollide = true
                part.Anchored = false
                part.Name = getnext()
                part.Parent = workspace
                scon = ev:Connect(function(dt) 
                    local md = l_hum.MoveDirection
                    local p = l_humrp.Position
                    
                    part.CFrame = cfn(p-(md), p)
                    part.Velocity = md * (dt * speed * 1200)
                    
                    l_hum:ChangeState(8)
                end)
            elseif (mode == 'WalkSpeed') then
                scon = ev:Connect(function() 
                    l_hum.WalkSpeed = speed
                end)
            end
        end)
        
        m_speed:Connect("Disabled",function() 
            if (scon) then scon:Disconnect() scon = nil end
            if (part) then part:Destroy() end
            
            unratio(l_hum.Changed)
            unratio(l_hum:GetPropertyChangedSignal("Jump"))
            unratio(l_humrp.Changed)
            unratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            unratio(l_humrp:GetPropertyChangedSignal("Velocity"))
        end)
        
        mode:Connect("SelectionChanged",function() 
            if (m_speed:IsEnabled()) then
                m_speed:Disable()
                m_speed:Enable()
            end
        end)
        
        mode:SetTooltip('Method used for the speedhack')
        speedslider:SetTooltip('Amount of speed')
    end
    -- Velocity
    do 
        local xslider = m_velocity:AddSlider('X',{min=0,max=100,cur=20,step=0.01}):SetTooltip('The minimum / max X velocity you can have')
        local yslider = m_velocity:AddSlider('Y',{min=0,max=100,cur=20,step=0.01}):SetTooltip('The minimum / max Y velocity you can have')
        local zslider = m_velocity:AddSlider('Z',{min=0,max=100,cur=20,step=0.01}):SetTooltip('The minimum / max Z velocity you can have')
        
        local x,y,z = 20,20,20
        
        xslider:Connect("ValueChanged",function(v)x=v;end)
        yslider:Connect("ValueChanged",function(v)y=v;end)
        zslider:Connect("ValueChanged",function(v)z=v;end)
        
        local velc
        m_velocity:Connect("Enabled",function() 
            velc = serv_rs.Stepped:Connect(function() 
                local v = l_humrp.Velocity
                l_humrp.Velocity = vec3(
                    mc(v.X,-x,x),
                    mc(v.Y,-y,y),
                    mc(v.Z,-z,z)
                )
            end)
        end)
        
        m_velocity:Connect("Disabled",function() 
            if (velc) then velc:Disconnect() velc = nil end
        end)
    end
    
    m_airjump:SetTooltip('Lets you jump in air, may bypass jump restrictions')
    m_blink:SetTooltip('Pseudo lagswitch, makes your character look frozen. <b>Do not combine with fakelag.</b>')
    m_clicktp:SetTooltip('Standard clickteleport')
    m_nofall:SetTooltip('Makes you instantly fall down, or bounce before you land. Useful for bypassing fall damage in games like Natural Disaster Survival')
    m_flight:SetTooltip('Standard flight, comes with a few bypasses')
    m_float:SetTooltip('Makes you float')
    m_highjump:SetTooltip('Increases how high you jump')
    m_jesus:SetTooltip('Lets you walk on non-collidable parts')
    m_jetpack:SetTooltip('Like flight but more velocity based')
    m_noclip:SetTooltip('Standard noclip, comes with a few bypasses')
    m_noslow:SetTooltip('Prevents you from being slowed down')
    m_parkour:SetTooltip('Jumps when you reach the end of a part')
    m_phase:SetTooltip('Like TPbot, but for movement rather than combat')
    m_safewalk:SetTooltip('Prevents you from walking off of a part')
    m_speed:SetTooltip('Speedhacks with various bypasses and settings')
    m_spider:SetTooltip('Climbs you up parts you walk into')
    m_step:SetTooltip('Teleports you on top of parts you walk into')
    m_velocity:SetTooltip('Limits your velocity')
end
local m_render = ui:CreateMenu('Render') do 
    
    local r_betterui    = m_render:AddMod('Better UI')
    local r_bread       = m_render:AddMod('Breadcrumbs')
    local r_camtweaks   = m_render:AddMod('Camera tweaks')
    local r_crosshair   = m_render:AddMod('Crosshair')
    local r_esp         = m_render:AddMod('ESP')
    local r_freecam     = m_render:AddMod('Freecam'..donetxt)
    local r_fullbright  = m_render:AddMod('Fullbright')
    local r_nametag     = m_render:AddMod('Nametags')
    local r_zoom        = m_render:AddMod('Zoom'..donetxt)
    
    -- Freecam
    do 
        -- Hotkeys
        local ascend_h = r_freecam:AddHotkey('Ascend key')
        local descend_h = r_freecam:AddHotkey('Descend key')
        -- Dropdowns
        local mode = r_freecam:AddDropdown('Method', true)
        local freezemode = r_freecam:AddDropdown('Freeze mode')
        -- sliders 
        local speedslider = r_freecam:AddSlider('Speed',{min=0,max=300,step=0.1,cur=30})
        -- buttons
        local gotocam = r_freecam:AddButton('Goto freecam')
        local resetcam = r_freecam:AddButton('Reset freecam position')
        -- toggles
        local camera = r_freecam:AddToggle('Camera-based')
        local resetonenable = r_freecam:AddToggle('Reset pos on enable')
        
        
        mode:AddOption('Standard'):SetTooltip('Standard freecam'):Select()
        mode:AddOption('Smooth'):SetTooltip('Just like Standard, but smooth')  
        mode:AddOption('Bypass'):SetTooltip('<b>Currently unfinished.</b> May bypass some anticheats / game mechanics that break freecam, but it\'s extremely janky')      
        freezemode:AddOption('Anchor'):SetTooltip('Anchors your character'):Select()
        freezemode:AddOption('Walkspeed'):SetTooltip('Sets your walkspeed to 0')
        freezemode:AddOption('Stuck'):SetTooltip('Constantly overwrites your position')
        
        local campart -- camera part
        local fcon -- flight connection
        
        local clvcon -- clv connection
        local cscon -- camera subject connection
        
        local ask = Enum.KeyCode.E-- keycode for ascension
        local dsk = Enum.KeyCode.Q-- keycode for descension
        
        local fcampos = l_humrp and l_humrp.Position or vec3(0,0,0)        
        local speed = 30 -- speed 
        
        local cambased = true 
        camera:Enable()
        
        ascend_h:Connect("HotkeySet",function(j)ask=j or 0;end)
        descend_h:Connect("HotkeySet",function(k)dsk=k or 0;end)
        camera:Connect("Toggled",function(t)
            cambased=t;
            if (r_freecam:IsEnabled()) then 
                r_freecam:Disable()
                r_freecam:Enable() 
            end
        end)
        mode:Connect("SelectionChanged",function() 
            if (r_freecam:IsEnabled()) then 
                r_freecam:Disable()
                r_freecam:Enable() 
            end
        end)
        freezemode:Connect("SelectionChanged",function() 
            if (r_freecam:IsEnabled()) then 
                r_freecam:Disable()
                r_freecam:Enable() 
            end
        end)
        speedslider:Connect("ValueChanged",function(v)speed=v;end)
        
        local stuckcon, stuckcf, oldwalk
        
        r_freecam:Connect("Enabled", function()
            
            local curmod = mode:GetSelection()        
            local upp, downp, nonep = vec3(0, 1, 0), vec3(0, -1, 0), vec3(0,0,0)
            
            if (resetonenable:IsEnabled()) then
                fcampos = l_humrp.Position
            end
            
            local normclv = l_cam.CFrame.LookVector
            clvcon = l_cam:GetPropertyChangedSignal("CFrame"):Connect(function() 
                normclv = l_cam.CFrame.LookVector
            end)
            
            if (curmod == 'Standard') then
                campart = inst("Part")
                campart.Position = fcampos
                campart.Transparency = 1
                campart.CanCollide = false
                campart.CanTouch = false
                campart.Anchored = true
                campart.Size = vec3(1, 1, 1)
                campart.Parent = workspace  
                
                l_cam.CameraSubject = campart
                cscon = l_cam:GetPropertyChangedSignal("CameraSubject"):Connect(function() 
                    if (l_cam.CameraSubject ~= campart) then
                        l_cam.CameraSubject = campart
                    end
                end)
                
                if (cambased) then
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        local f,b = serv_uis:IsKeyDown(119), serv_uis:IsKeyDown(115)
                        
                        fcampos += (l_hum.MoveDirection * dt * 3 * speed)
                        fcampos += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        fcampos += ((f and vec3(0, normclv.Y, 0) or nonep) - (b and vec3(0, normclv.Y, 0) or nonep)*(dt*3*speed))
                        
                        campart.Position = fcampos
                    end)
                else
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        
                        fcampos += (l_hum.MoveDirection * dt * 3 * speed)
                        fcampos += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        
                        campart.Position = fcampos
                    end)
                end
            elseif (curmod == 'Smooth') then
                campart = inst("Part")
                campart.Position = fcampos
                campart.Transparency = 1
                campart.CanCollide = false
                campart.CanTouch = false
                campart.Anchored = true
                campart.Size = vec3(1, 1, 1)
                campart.Parent = workspace  
                
                l_cam.CameraSubject = campart
                cscon = l_cam:GetPropertyChangedSignal("CameraSubject"):Connect(function() 
                    if (l_cam.CameraSubject ~= campart) then
                        l_cam.CameraSubject = campart
                    end
                end)
                
                
                local pos = inst("BodyPosition")
                pos.Position = fcampos
                pos.D = 1900
                pos.P = 125000
                pos.MaxForce = vec3(9e9, 9e9, 9e9)
                pos.Parent = campart
                
                campart.Anchored = false
                
                if (cambased) then
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        local f,b = serv_uis:IsKeyDown(119), serv_uis:IsKeyDown(115)
                        
                        fcampos += (l_hum.MoveDirection * dt * 3 * speed)
                        fcampos += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        fcampos += ((f and vec3(0, normclv.Y, 0) or nonep) - (b and vec3(0, normclv.Y, 0) or nonep)*(dt*3*speed))
                        
                        pos.Position = fcampos
                    end)
                else
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        
                        fcampos += (l_hum.MoveDirection * dt * 3 * speed)
                        fcampos += (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        
                        pos.Position = fcampos
                    end)
                end
            
            elseif (curmod == 'Bypass') then
                
                l_cam.CameraSubject = l_hum
                cscon = l_cam:GetPropertyChangedSignal("CameraSubject"):Connect(function() 
                    if (l_cam.CameraSubject ~= l_hum) then
                        l_cam.CameraSubject = l_hum
                    end
                end)
                
                if (cambased) then
                    local cf = cfn(l_humrp.Position, l_humrp.Position + vec3(0, 0, 1))
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        l_humrp.CFrame = cf
                        
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        local f,b = serv_uis:IsKeyDown(119), serv_uis:IsKeyDown(115)
                        
                        local movevec = (l_hum.MoveDirection * dt * 3 * speed)
                        local upvec = (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        local cupvec = ((f and vec3(0, normclv.Y, 0) or nonep) - (b and vec3(0, normclv.Y, 0) or nonep)*(dt*3*speed))
                        
                        fcampos += movevec
                        fcampos -= upvec
                        fcampos -= cupvec
                        
                        local normalized = cfn(fcampos):ToObjectSpace(cf)
                        
                        l_hum.CameraOffset = (normalized).Position
                    end)
                else
                    local cf = cfn(l_humrp.Position, l_humrp.Position + vec3(0, 0, 1))
                    fcon = serv_rs.Heartbeat:Connect(function(dt) 
                        l_humrp.CFrame = cf
                        
                        local up = serv_uis:IsKeyDown(ask)
                        local down = serv_uis:IsKeyDown(dsk)
                        
                        local movevec = (l_hum.MoveDirection * dt * 3 * speed)
                        local upvec = (((up and upp or nonep) + (down and downp or nonep))*(dt*3*speed))
                        
                        fcampos += movevec
                        fcampos -= upvec
                        
                        local normalized = cfn(fcampos):ToObjectSpace(cf)
                        
                        l_hum.CameraOffset = (normalized).Position
                    end)
                end
            end
            
            local fmode = freezemode:GetSelection()
            
            
            if (fmode == 'Anchor') then
                l_humrp.Anchored = true
                
            elseif (fmode == 'Walkspeed') then
                oldwalk = l_hum.WalkSpeed
                l_hum.WalkSpeed = 0
                
            elseif (fmode == 'Stuck') then
                
                stuckcf = l_humrp.CFrame
                ratio(l_humrp.Changed)
                ratio(l_humrp:GetPropertyChangedSignal("CFrame"))
                stuckcon = serv_rs.Heartbeat:Connect(function() 
                    l_humrp.CFrame = stuckcf
                end)
            end
        end)
        
        r_freecam:Connect("Disabled",function() 
            
            if (fcon) then 
                fcon:Disconnect() 
                fcon = nil 
            end 
            if (clvcon) then 
                clvcon:Disconnect() 
                clvcon = nil 
            end
            if (campart) then 
                campart:Destroy() 
                campart = nil 
            end
            if (cscon) then 
                cscon:Disconnect() 
                cscon = nil 
            end
            
            l_cam.CameraSubject = l_hum
            l_hum.CameraOffset = vec3(0, 0, 0)
            
            if (l_humrp.Anchored == true) then
                l_humrp.Anchored = false
            
            elseif (l_hum.WalkSpeed == 0) then
                l_humrp.WalkSpeed = (oldwalk == 0 and 16 or oldwalk) -- Prevent getting infinitely stuck
            end
            if (stuckcon) then
                stuckcon:Disconnect()
                stuckcon = nil
                unratio(l_humrp.Changed)
                unratio(l_humrp:GetPropertyChangedSignal("CFrame"))
            end
        end)
        
        gotocam:Connect("Clicked",function() 
            local pos = campart.Position
            local new = cfn(pos, pos+l_humrp.CFrame.LookVector)
            stuckcf = new
            l_humrp.CFrame = new
        end)
        
        resetcam:Connect("Clicked",function() 
            fcampos = l_humrp.Position
        end)
        
        ascend_h:SetTooltip('When pressed the freecam vertically ascends'):SetHotkey(Enum.KeyCode.E)
        camera:SetTooltip('When enabled, the direction of your camera affects your Y movement. <b>Leaving this on is the typical option in every other freecam script</b>')
        descend_h:SetTooltip('When pressed the freecam vertically descends'):SetHotkey(Enum.KeyCode.Q)
        mode:SetTooltip('The method Freecam uses')
        speedslider:SetTooltip('The speed of your freecam flight')
        freezemode:SetTooltip('The method used to make your character not move')
        gotocam:SetTooltip('Brings you to the camera')
        resetcam:SetTooltip('Resets the camera\'s position')
        resetonenable:SetTooltip('Resets the camera\'s position when Freecam gets enabled')
    end
    -- Esp
    do 
        --r_esp:AddSlider('')
    end
    -- Zoom
    do 
        local slider = r_zoom:AddSlider('Zoom amount',{min=0,max=150,cur=30,step=0.1}):SetTooltip('The amount to zoom in by')
                
        r_zoom:Connect("Toggled",function(t) 
            if (t) then
                l_cam.FieldOfView = 70-(slider:GetValue()*.5)
                slider:Connect("ValueChanged",function(v) 
                    l_cam.FieldOfView = 70-(v*.5)
                end)
            else
                slider:Connect("ValueChanged",nil)
                l_cam.FieldOfView = 70
            end
        end)

    end
    
	r_fullbright:SetTooltip('Fullbright with different presets for different games')
    r_betterui:SetTooltip("Improves existing Roblox UIs, like the chat and inventory")
    r_bread:SetTooltip('Leaves a trail behind')
    r_camtweaks:SetTooltip('Options for configuring the camera, like noclip-cam, maxzoom, smooth camera, etc. For 3rd person, use Game tweaks under Misc')
    r_crosshair:SetTooltip('Crosshair configuration')
    r_esp:SetTooltip('Configurable ESP')
    r_freecam:SetTooltip('Standard freecam')
    r_nametag:SetTooltip('Better nametags')
    r_zoom:SetTooltip('Like Optifine\'s zoom')
    
    
end
local m_ui = ui:CreateMenu('UI') do 
    local u_cmd = m_ui:AddMod('Command bar')
    local u_jeff = m_ui:AddMod('Jeff'..donetxt)
    local u_plr = m_ui:AddMod('Player notifications'..donetxt)
    -- jeff 
    do 
        local _
        u_jeff:Connect("Toggled", function(t) 
            if (t) then
                _ = inst("ImageLabel")
                _.Size = dim2off(250, 250)
                _.BackgroundTransparency = 1
                _.Position = dim2(1, -250, 1, 0)
                _.Image = "rbxassetid://8723094657"
                _.ResampleMode = 'Pixelated'
                _.Parent = ui:GetScreen()
                
                ctwn(_, {Position = dim2(1, -250, 1, -130)}, 25)
            else
                _:Destroy()
            end
            
        end)
    end
    -- plr
    do 
        local rfriends = u_plr:AddToggle('Roblox friends only'):SetTooltip('Only send notifications if they are your roblox friend')
        local sound = u_plr:AddToggle('Play sound'):SetTooltip('Play the notif sound'):Enable()
        
        local h = true
        sound:Connect("Toggled",function(t)h=t;end)
        
        local join
        local leave 
        
        u_plr:Connect("Enabled",function() 
            join = serv_players.PlayerAdded:Connect(function(p) 
                if (l_plr:IsFriendsWith(p.UserId)) then
                    ui:Notify('Friend joined',p.Name..' has joined your server',2.5,h and 2 or 3)
                else
                    if (not rfriends:IsEnabled()) then
                        ui:Notify('Player joined',p.Name..' has joined the server',2.5,h and 2 or 3)
                    end
                end
            end)
            leave = serv_players.PlayerRemoving:Connect(function(p) 
                if (l_plr:IsFriendsWith(p.UserId)) then
                    ui:Notify('Friend left',p.Name..' has left your server',2.5,h and 1 or 3)
                else
                    if (not rfriends:IsEnabled()) then
                        ui:Notify('Player left',p.Name..' has left the server',2.5,h and 1 or 3)
                    end
                end
            end)
        end)
        u_plr:Connect("Disabled",function() 
            join:Disconnect()
            leave:Disconnect()
        end)
    end
    
    u_cmd:SetTooltip('Redline command bar. Quickly toggle modules, do quick actions like chatting and leaving, and more')
    u_jeff:SetTooltip('I forgot what this does')
    u_plr:SetTooltip('Get notifications when a player joins / leaves')
end
local m_server = ui:CreateMenu('Server') do 
    local s_priv = m_server:AddMod('Private server', 'Button')
    local s_rejoin = m_server:AddMod('Rejoin'..donetxt, 'Button')
    local s_shop = m_server:AddMod('Serverhop', 'Button')
    local s_viewer = m_server:AddMod('Server browser')
    s_rejoin:Connect("Clicked",function() 
        if #serv_players:GetPlayers() <= 1 then
        	l_plr:Kick("\nRejoining, one second...")
        	wait(0.3)
        	serv_tp:Teleport(game.PlaceId, l_plr)
        else
        	serv_tp:TeleportToPlaceInstance(game.PlaceId, game.JobId, l_plr)
        end
    end)
    
    s_priv:SetTooltip('Hops you to the smallest server. <b>Don\'t hop too many times, or you\'ll get error 268</b>')
    s_rejoin:SetTooltip('Rejoins you into the current server. <b>Don\'t rejoin too many times, or you\'ll get error 268</b>')
    s_shop:SetTooltip('Server hops. <b>Don\'t hop too many times, or you\'ll get error 268</b>')
    s_viewer:SetTooltip('Lets you view all the existing servers and hop to them')
end
local m_integrations = ui:CreateMenu('Integrations') do 
    local m_alt = m_integrations:AddMod('Alt manager')
    local m_rpc = m_integrations:AddMod('Discord Rich Presence')
	
    -- rpc
    do 
        m_rpc:Connect("Enabled",function() 
            ui:Notify('Rich Presence failed', 'Currently unfinished', 3, 1)
        end)
    end
    
    m_alt:SetTooltip('Roblox Alt Manager integration. Requires the 3rd party Roblox Alt Manager program.')
    m_rpc:SetTooltip('Discord Rich Presence integration')
end
local m_search = ui:CreateMenu('Search') do 
    local _ = m_search:AddMod('Enter module name', 'Textbox')
    _:SetTooltip('Search for a module')
    _:Connect("Unfocused", function(t, t2)
        if (not t2) then return end 
        
        local mods = ui:GetModules()
        for i = 1, #mods do 
            local mod = mods[i]
            if (mod.setvis) then mod:setvis(true, false) end
        end
    end)
    
    _:Connect("TextChanged", function(t) 
        local mods = ui:GetModules()
        for i = 1, #mods do 
            local mod = mods[i]
            if (mod.Name:lower():match(t)) then
                if (mod.setvis) then 
                    mod:setvis(true, true) 
                end
            else
                if (mod.setvis) then 
                    mod:setvis(true, false) 
                end
            end
        end
    end)
end
local m_changelog = ui:CreateMenu('Changelog') do 
    m_changelog:AddMod('Version 0.1.1',nil,true):AddLabel([[ - Finished Fakelag and Blink
- Almost finished Triggerbot, team check and spam may have issues
- Started work on Antiaim]]) 

    m_changelog:AddMod('Version 0.1.0',nil,true):AddLabel([[ - Added Fakelag mod
- Added Sound option to Player notifs
- Added another notification sound
- Added changelog menu, new changes will be documented here
- Added server browser mod
- Finished Parkour, Velocity, and Nofall
- Made mouse unlock when the Redline window is open
- Marked Jeff and Player notifs as done
- Removed Logs since player logs aren't that important
- Renamed Fastfall to Nofall]])
end

_G.RLLoaded = true
ui:Notify('Redline ('..REDLINEVER..') loaded', 'Redline is now ready to use. Press RightShift to begin.', 5, 2)
